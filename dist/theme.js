/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@mui/material/colors/blue.js":
/*!***************************************************!*\
  !*** ./node_modules/@mui/material/colors/blue.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const blue = {
  50: '#e3f2fd',
  100: '#bbdefb',
  200: '#90caf9',
  300: '#64b5f6',
  400: '#42a5f5',
  500: '#2196f3',
  600: '#1e88e5',
  700: '#1976d2',
  800: '#1565c0',
  900: '#0d47a1',
  A100: '#82b1ff',
  A200: '#448aff',
  A400: '#2979ff',
  A700: '#2962ff'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (blue);

/***/ }),

/***/ "./node_modules/@mui/material/colors/common.js":
/*!*****************************************************!*\
  !*** ./node_modules/@mui/material/colors/common.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const common = {
  black: '#000',
  white: '#fff'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (common);

/***/ }),

/***/ "./node_modules/@mui/material/colors/green.js":
/*!****************************************************!*\
  !*** ./node_modules/@mui/material/colors/green.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const green = {
  50: '#e8f5e9',
  100: '#c8e6c9',
  200: '#a5d6a7',
  300: '#81c784',
  400: '#66bb6a',
  500: '#4caf50',
  600: '#43a047',
  700: '#388e3c',
  800: '#2e7d32',
  900: '#1b5e20',
  A100: '#b9f6ca',
  A200: '#69f0ae',
  A400: '#00e676',
  A700: '#00c853'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (green);

/***/ }),

/***/ "./node_modules/@mui/material/colors/grey.js":
/*!***************************************************!*\
  !*** ./node_modules/@mui/material/colors/grey.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const grey = {
  50: '#fafafa',
  100: '#f5f5f5',
  200: '#eeeeee',
  300: '#e0e0e0',
  400: '#bdbdbd',
  500: '#9e9e9e',
  600: '#757575',
  700: '#616161',
  800: '#424242',
  900: '#212121',
  A100: '#f5f5f5',
  A200: '#eeeeee',
  A400: '#bdbdbd',
  A700: '#616161'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (grey);

/***/ }),

/***/ "./node_modules/@mui/material/colors/lightBlue.js":
/*!********************************************************!*\
  !*** ./node_modules/@mui/material/colors/lightBlue.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const lightBlue = {
  50: '#e1f5fe',
  100: '#b3e5fc',
  200: '#81d4fa',
  300: '#4fc3f7',
  400: '#29b6f6',
  500: '#03a9f4',
  600: '#039be5',
  700: '#0288d1',
  800: '#0277bd',
  900: '#01579b',
  A100: '#80d8ff',
  A200: '#40c4ff',
  A400: '#00b0ff',
  A700: '#0091ea'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lightBlue);

/***/ }),

/***/ "./node_modules/@mui/material/colors/orange.js":
/*!*****************************************************!*\
  !*** ./node_modules/@mui/material/colors/orange.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const orange = {
  50: '#fff3e0',
  100: '#ffe0b2',
  200: '#ffcc80',
  300: '#ffb74d',
  400: '#ffa726',
  500: '#ff9800',
  600: '#fb8c00',
  700: '#f57c00',
  800: '#ef6c00',
  900: '#e65100',
  A100: '#ffd180',
  A200: '#ffab40',
  A400: '#ff9100',
  A700: '#ff6d00'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (orange);

/***/ }),

/***/ "./node_modules/@mui/material/colors/purple.js":
/*!*****************************************************!*\
  !*** ./node_modules/@mui/material/colors/purple.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const purple = {
  50: '#f3e5f5',
  100: '#e1bee7',
  200: '#ce93d8',
  300: '#ba68c8',
  400: '#ab47bc',
  500: '#9c27b0',
  600: '#8e24aa',
  700: '#7b1fa2',
  800: '#6a1b9a',
  900: '#4a148c',
  A100: '#ea80fc',
  A200: '#e040fb',
  A400: '#d500f9',
  A700: '#aa00ff'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (purple);

/***/ }),

/***/ "./node_modules/@mui/material/colors/red.js":
/*!**************************************************!*\
  !*** ./node_modules/@mui/material/colors/red.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const red = {
  50: '#ffebee',
  100: '#ffcdd2',
  200: '#ef9a9a',
  300: '#e57373',
  400: '#ef5350',
  500: '#f44336',
  600: '#e53935',
  700: '#d32f2f',
  800: '#c62828',
  900: '#b71c1c',
  A100: '#ff8a80',
  A200: '#ff5252',
  A400: '#ff1744',
  A700: '#d50000'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (red);

/***/ }),

/***/ "./node_modules/@mui/material/styles/createMixins.js":
/*!***********************************************************!*\
  !*** ./node_modules/@mui/material/styles/createMixins.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createMixins)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");

function createMixins(breakpoints, mixins) {
  return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    toolbar: {
      minHeight: 56,
      [breakpoints.up('xs')]: {
        '@media (orientation: landscape)': {
          minHeight: 48
        }
      },
      [breakpoints.up('sm')]: {
        minHeight: 64
      }
    }
  }, mixins);
}

/***/ }),

/***/ "./node_modules/@mui/material/styles/createPalette.js":
/*!************************************************************!*\
  !*** ./node_modules/@mui/material/styles/createPalette.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dark: () => (/* binding */ dark),
/* harmony export */   "default": () => (/* binding */ createPalette),
/* harmony export */   light: () => (/* binding */ light)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var _mui_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @mui/utils */ "./node_modules/@mui/utils/esm/deepmerge.js");
/* harmony import */ var _mui_system__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @mui/system */ "./node_modules/@mui/system/esm/colorManipulator.js");
/* harmony import */ var _colors_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../colors/common */ "./node_modules/@mui/material/colors/common.js");
/* harmony import */ var _colors_grey__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../colors/grey */ "./node_modules/@mui/material/colors/grey.js");
/* harmony import */ var _colors_purple__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../colors/purple */ "./node_modules/@mui/material/colors/purple.js");
/* harmony import */ var _colors_red__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../colors/red */ "./node_modules/@mui/material/colors/red.js");
/* harmony import */ var _colors_orange__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../colors/orange */ "./node_modules/@mui/material/colors/orange.js");
/* harmony import */ var _colors_blue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../colors/blue */ "./node_modules/@mui/material/colors/blue.js");
/* harmony import */ var _colors_lightBlue__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../colors/lightBlue */ "./node_modules/@mui/material/colors/lightBlue.js");
/* harmony import */ var _colors_green__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../colors/green */ "./node_modules/@mui/material/colors/green.js");



const _excluded = ["mode", "contrastThreshold", "tonalOffset"];










const light = {
  // The colors used to style the text.
  text: {
    // The most important text.
    primary: 'rgba(0, 0, 0, 0.87)',
    // Secondary text.
    secondary: 'rgba(0, 0, 0, 0.6)',
    // Disabled text have even lower visual prominence.
    disabled: 'rgba(0, 0, 0, 0.38)'
  },
  // The color used to divide different elements.
  divider: 'rgba(0, 0, 0, 0.12)',
  // The background colors used to style the surfaces.
  // Consistency between these values is important.
  background: {
    paper: _colors_common__WEBPACK_IMPORTED_MODULE_2__["default"].white,
    default: _colors_common__WEBPACK_IMPORTED_MODULE_2__["default"].white
  },
  // The colors used to style the action elements.
  action: {
    // The color of an active action like an icon button.
    active: 'rgba(0, 0, 0, 0.54)',
    // The color of an hovered action.
    hover: 'rgba(0, 0, 0, 0.04)',
    hoverOpacity: 0.04,
    // The color of a selected action.
    selected: 'rgba(0, 0, 0, 0.08)',
    selectedOpacity: 0.08,
    // The color of a disabled action.
    disabled: 'rgba(0, 0, 0, 0.26)',
    // The background color of a disabled action.
    disabledBackground: 'rgba(0, 0, 0, 0.12)',
    disabledOpacity: 0.38,
    focus: 'rgba(0, 0, 0, 0.12)',
    focusOpacity: 0.12,
    activatedOpacity: 0.12
  }
};
const dark = {
  text: {
    primary: _colors_common__WEBPACK_IMPORTED_MODULE_2__["default"].white,
    secondary: 'rgba(255, 255, 255, 0.7)',
    disabled: 'rgba(255, 255, 255, 0.5)',
    icon: 'rgba(255, 255, 255, 0.5)'
  },
  divider: 'rgba(255, 255, 255, 0.12)',
  background: {
    paper: '#121212',
    default: '#121212'
  },
  action: {
    active: _colors_common__WEBPACK_IMPORTED_MODULE_2__["default"].white,
    hover: 'rgba(255, 255, 255, 0.08)',
    hoverOpacity: 0.08,
    selected: 'rgba(255, 255, 255, 0.16)',
    selectedOpacity: 0.16,
    disabled: 'rgba(255, 255, 255, 0.3)',
    disabledBackground: 'rgba(255, 255, 255, 0.12)',
    disabledOpacity: 0.38,
    focus: 'rgba(255, 255, 255, 0.12)',
    focusOpacity: 0.12,
    activatedOpacity: 0.24
  }
};
function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === 'light') {
      intent.light = (0,_mui_system__WEBPACK_IMPORTED_MODULE_3__.lighten)(intent.main, tonalOffsetLight);
    } else if (direction === 'dark') {
      intent.dark = (0,_mui_system__WEBPACK_IMPORTED_MODULE_3__.darken)(intent.main, tonalOffsetDark);
    }
  }
}
function getDefaultPrimary(mode = 'light') {
  if (mode === 'dark') {
    return {
      main: _colors_blue__WEBPACK_IMPORTED_MODULE_4__["default"][200],
      light: _colors_blue__WEBPACK_IMPORTED_MODULE_4__["default"][50],
      dark: _colors_blue__WEBPACK_IMPORTED_MODULE_4__["default"][400]
    };
  }
  return {
    main: _colors_blue__WEBPACK_IMPORTED_MODULE_4__["default"][700],
    light: _colors_blue__WEBPACK_IMPORTED_MODULE_4__["default"][400],
    dark: _colors_blue__WEBPACK_IMPORTED_MODULE_4__["default"][800]
  };
}
function getDefaultSecondary(mode = 'light') {
  if (mode === 'dark') {
    return {
      main: _colors_purple__WEBPACK_IMPORTED_MODULE_5__["default"][200],
      light: _colors_purple__WEBPACK_IMPORTED_MODULE_5__["default"][50],
      dark: _colors_purple__WEBPACK_IMPORTED_MODULE_5__["default"][400]
    };
  }
  return {
    main: _colors_purple__WEBPACK_IMPORTED_MODULE_5__["default"][500],
    light: _colors_purple__WEBPACK_IMPORTED_MODULE_5__["default"][300],
    dark: _colors_purple__WEBPACK_IMPORTED_MODULE_5__["default"][700]
  };
}
function getDefaultError(mode = 'light') {
  if (mode === 'dark') {
    return {
      main: _colors_red__WEBPACK_IMPORTED_MODULE_6__["default"][500],
      light: _colors_red__WEBPACK_IMPORTED_MODULE_6__["default"][300],
      dark: _colors_red__WEBPACK_IMPORTED_MODULE_6__["default"][700]
    };
  }
  return {
    main: _colors_red__WEBPACK_IMPORTED_MODULE_6__["default"][700],
    light: _colors_red__WEBPACK_IMPORTED_MODULE_6__["default"][400],
    dark: _colors_red__WEBPACK_IMPORTED_MODULE_6__["default"][800]
  };
}
function getDefaultInfo(mode = 'light') {
  if (mode === 'dark') {
    return {
      main: _colors_lightBlue__WEBPACK_IMPORTED_MODULE_7__["default"][400],
      light: _colors_lightBlue__WEBPACK_IMPORTED_MODULE_7__["default"][300],
      dark: _colors_lightBlue__WEBPACK_IMPORTED_MODULE_7__["default"][700]
    };
  }
  return {
    main: _colors_lightBlue__WEBPACK_IMPORTED_MODULE_7__["default"][700],
    light: _colors_lightBlue__WEBPACK_IMPORTED_MODULE_7__["default"][500],
    dark: _colors_lightBlue__WEBPACK_IMPORTED_MODULE_7__["default"][900]
  };
}
function getDefaultSuccess(mode = 'light') {
  if (mode === 'dark') {
    return {
      main: _colors_green__WEBPACK_IMPORTED_MODULE_8__["default"][400],
      light: _colors_green__WEBPACK_IMPORTED_MODULE_8__["default"][300],
      dark: _colors_green__WEBPACK_IMPORTED_MODULE_8__["default"][700]
    };
  }
  return {
    main: _colors_green__WEBPACK_IMPORTED_MODULE_8__["default"][800],
    light: _colors_green__WEBPACK_IMPORTED_MODULE_8__["default"][500],
    dark: _colors_green__WEBPACK_IMPORTED_MODULE_8__["default"][900]
  };
}
function getDefaultWarning(mode = 'light') {
  if (mode === 'dark') {
    return {
      main: _colors_orange__WEBPACK_IMPORTED_MODULE_9__["default"][400],
      light: _colors_orange__WEBPACK_IMPORTED_MODULE_9__["default"][300],
      dark: _colors_orange__WEBPACK_IMPORTED_MODULE_9__["default"][700]
    };
  }
  return {
    main: '#ed6c02',
    // closest to orange[800] that pass 3:1.
    light: _colors_orange__WEBPACK_IMPORTED_MODULE_9__["default"][500],
    dark: _colors_orange__WEBPACK_IMPORTED_MODULE_9__["default"][900]
  };
}
function createPalette(palette) {
  const {
      mode = 'light',
      contrastThreshold = 3,
      tonalOffset = 0.2
    } = palette,
    other = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(palette, _excluded);
  const primary = palette.primary || getDefaultPrimary(mode);
  const secondary = palette.secondary || getDefaultSecondary(mode);
  const error = palette.error || getDefaultError(mode);
  const info = palette.info || getDefaultInfo(mode);
  const success = palette.success || getDefaultSuccess(mode);
  const warning = palette.warning || getDefaultWarning(mode);

  // Use the same logic as
  // Bootstrap: https://github.com/twbs/bootstrap/blob/1d6e3710dd447de1a200f29e8fa521f8a0908f70/scss/_functions.scss#L59
  // and material-components-web https://github.com/material-components/material-components-web/blob/ac46b8863c4dab9fc22c4c662dc6bd1b65dd652f/packages/mdc-theme/_functions.scss#L54
  function getContrastText(background) {
    const contrastText = (0,_mui_system__WEBPACK_IMPORTED_MODULE_3__.getContrastRatio)(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    if (true) {
      const contrast = (0,_mui_system__WEBPACK_IMPORTED_MODULE_3__.getContrastRatio)(background, contrastText);
      if (contrast < 3) {
        console.error([`MUI: The contrast ratio of ${contrast}:1 for ${contrastText} on ${background}`, 'falls below the WCAG recommended absolute minimum contrast ratio of 3:1.', 'https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast'].join('\n'));
      }
    }
    return contrastText;
  }
  const augmentColor = ({
    color,
    name,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, color);
    if (!color.main && color[mainShade]) {
      color.main = color[mainShade];
    }
    if (!color.hasOwnProperty('main')) {
      throw new Error( true ? `MUI: The color${name ? ` (${name})` : ''} provided to augmentColor(color) is invalid.
The color object needs to have a \`main\` property or a \`${mainShade}\` property.` : 0);
    }
    if (typeof color.main !== 'string') {
      throw new Error( true ? `MUI: The color${name ? ` (${name})` : ''} provided to augmentColor(color) is invalid.
\`color.main\` should be a string, but \`${JSON.stringify(color.main)}\` was provided instead.

Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });` : 0);
    }
    addLightOrDark(color, 'light', lightShade, tonalOffset);
    addLightOrDark(color, 'dark', darkShade, tonalOffset);
    if (!color.contrastText) {
      color.contrastText = getContrastText(color.main);
    }
    return color;
  };
  const modes = {
    dark,
    light
  };
  if (true) {
    if (!modes[mode]) {
      console.error(`MUI: The palette mode \`${mode}\` is not supported.`);
    }
  }
  const paletteOutput = (0,_mui_utils__WEBPACK_IMPORTED_MODULE_10__["default"])((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    // A collection of common colors.
    common: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, _colors_common__WEBPACK_IMPORTED_MODULE_2__["default"]),
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor({
      color: primary,
      name: 'primary'
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor({
      color: secondary,
      name: 'secondary',
      mainShade: 'A400',
      lightShade: 'A200',
      darkShade: 'A700'
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor({
      color: error,
      name: 'error'
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: augmentColor({
      color: warning,
      name: 'warning'
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: augmentColor({
      color: info,
      name: 'info'
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: augmentColor({
      color: success,
      name: 'success'
    }),
    // The grey colors.
    grey: _colors_grey__WEBPACK_IMPORTED_MODULE_11__["default"],
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText,
    // Generate a rich color object.
    augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset
  }, modes[mode]), other);
  return paletteOutput;
}

/***/ }),

/***/ "./node_modules/@mui/material/styles/createTheme.js":
/*!**********************************************************!*\
  !*** ./node_modules/@mui/material/styles/createTheme.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createMuiTheme: () => (/* binding */ createMuiTheme),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var _mui_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @mui/utils */ "./node_modules/@mui/utils/esm/deepmerge.js");
/* harmony import */ var _mui_system__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @mui/system */ "./node_modules/@mui/system/esm/createTheme/createTheme.js");
/* harmony import */ var _mui_system__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @mui/system */ "./node_modules/@mui/system/esm/styleFunctionSx/defaultSxConfig.js");
/* harmony import */ var _mui_system__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @mui/system */ "./node_modules/@mui/system/esm/styleFunctionSx/styleFunctionSx.js");
/* harmony import */ var _mui_utils_generateUtilityClass__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @mui/utils/generateUtilityClass */ "./node_modules/@mui/utils/esm/generateUtilityClass/generateUtilityClass.js");
/* harmony import */ var _createMixins__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./createMixins */ "./node_modules/@mui/material/styles/createMixins.js");
/* harmony import */ var _createPalette__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createPalette */ "./node_modules/@mui/material/styles/createPalette.js");
/* harmony import */ var _createTypography__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./createTypography */ "./node_modules/@mui/material/styles/createTypography.js");
/* harmony import */ var _shadows__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./shadows */ "./node_modules/@mui/material/styles/shadows.js");
/* harmony import */ var _createTransitions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./createTransitions */ "./node_modules/@mui/material/styles/createTransitions.js");
/* harmony import */ var _zIndex__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./zIndex */ "./node_modules/@mui/material/styles/zIndex.js");



const _excluded = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];









function createTheme(options = {}, ...args) {
  const {
      mixins: mixinsInput = {},
      palette: paletteInput = {},
      transitions: transitionsInput = {},
      typography: typographyInput = {}
    } = options,
    other = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(options, _excluded);
  if (options.vars) {
    throw new Error( true ? `MUI: \`vars\` is a private field used for CSS variables support.
Please use another name.` : 0);
  }
  const palette = (0,_createPalette__WEBPACK_IMPORTED_MODULE_2__["default"])(paletteInput);
  const systemTheme = (0,_mui_system__WEBPACK_IMPORTED_MODULE_3__["default"])(options);
  let muiTheme = (0,_mui_utils__WEBPACK_IMPORTED_MODULE_4__["default"])(systemTheme, {
    mixins: (0,_createMixins__WEBPACK_IMPORTED_MODULE_5__["default"])(systemTheme.breakpoints, mixinsInput),
    palette,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: _shadows__WEBPACK_IMPORTED_MODULE_6__["default"].slice(),
    typography: (0,_createTypography__WEBPACK_IMPORTED_MODULE_7__["default"])(palette, typographyInput),
    transitions: (0,_createTransitions__WEBPACK_IMPORTED_MODULE_8__["default"])(transitionsInput),
    zIndex: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, _zIndex__WEBPACK_IMPORTED_MODULE_9__["default"])
  });
  muiTheme = (0,_mui_utils__WEBPACK_IMPORTED_MODULE_4__["default"])(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => (0,_mui_utils__WEBPACK_IMPORTED_MODULE_4__["default"])(acc, argument), muiTheme);
  if (true) {
    // TODO v6: Refactor to use globalStateClassesMapping from @mui/utils once `readOnly` state class is used in Rating component.
    const stateClasses = ['active', 'checked', 'completed', 'disabled', 'error', 'expanded', 'focused', 'focusVisible', 'required', 'selected'];
    const traverse = (node, component) => {
      let key;

      // eslint-disable-next-line guard-for-in, no-restricted-syntax
      for (key in node) {
        const child = node[key];
        if (stateClasses.indexOf(key) !== -1 && Object.keys(child).length > 0) {
          if (true) {
            const stateClass = (0,_mui_utils_generateUtilityClass__WEBPACK_IMPORTED_MODULE_10__["default"])('', key);
            console.error([`MUI: The \`${component}\` component increases ` + `the CSS specificity of the \`${key}\` internal state.`, 'You can not override it like this: ', JSON.stringify(node, null, 2), '', `Instead, you need to use the '&.${stateClass}' syntax:`, JSON.stringify({
              root: {
                [`&.${stateClass}`]: child
              }
            }, null, 2), '', 'https://mui.com/r/state-classes-guide'].join('\n'));
          }
          // Remove the style to prevent global conflicts.
          node[key] = {};
        }
      }
    };
    Object.keys(muiTheme.components).forEach(component => {
      const styleOverrides = muiTheme.components[component].styleOverrides;
      if (styleOverrides && component.indexOf('Mui') === 0) {
        traverse(styleOverrides, component);
      }
    });
  }
  muiTheme.unstable_sxConfig = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, _mui_system__WEBPACK_IMPORTED_MODULE_11__["default"], other == null ? void 0 : other.unstable_sxConfig);
  muiTheme.unstable_sx = function sx(props) {
    return (0,_mui_system__WEBPACK_IMPORTED_MODULE_12__["default"])({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
let warnedOnce = false;
function createMuiTheme(...args) {
  if (true) {
    if (!warnedOnce) {
      warnedOnce = true;
      console.error(['MUI: the createMuiTheme function was renamed to createTheme.', '', "You should use `import { createTheme } from '@mui/material/styles'`"].join('\n'));
    }
  }
  return createTheme(...args);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createTheme);

/***/ }),

/***/ "./node_modules/@mui/material/styles/createTransitions.js":
/*!****************************************************************!*\
  !*** ./node_modules/@mui/material/styles/createTransitions.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createTransitions),
/* harmony export */   duration: () => (/* binding */ duration),
/* harmony export */   easing: () => (/* binding */ easing)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");


const _excluded = ["duration", "easing", "delay"];
// Follow https://material.google.com/motion/duration-easing.html#duration-easing-natural-easing-curves
// to learn the context in which each easing should be used.
const easing = {
  // This is the most common easing curve.
  easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: 'cubic-bezier(0.0, 0, 0.2, 1)',
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: 'cubic-bezier(0.4, 0, 1, 1)',
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: 'cubic-bezier(0.4, 0, 0.6, 1)'
};

// Follow https://m2.material.io/guidelines/motion/duration-easing.html#duration-easing-common-durations
// to learn when use what timing
const duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height) {
  if (!height) {
    return 0;
  }
  const constant = height / 36;

  // https://www.wolframalpha.com/input/?i=(4+%2B+15+*+(x+%2F+36+)+**+0.25+%2B+(x+%2F+36)+%2F+5)+*+10
  return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
}
function createTransitions(inputTransitions) {
  const mergedEasing = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, easing, inputTransitions.easing);
  const mergedDuration = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, duration, inputTransitions.duration);
  const create = (props = ['all'], options = {}) => {
    const {
        duration: durationOption = mergedDuration.standard,
        easing: easingOption = mergedEasing.easeInOut,
        delay = 0
      } = options,
      other = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(options, _excluded);
    if (true) {
      const isString = value => typeof value === 'string';
      // IE11 support, replace with Number.isNaN
      // eslint-disable-next-line no-restricted-globals
      const isNumber = value => !isNaN(parseFloat(value));
      if (!isString(props) && !Array.isArray(props)) {
        console.error('MUI: Argument "props" must be a string or Array.');
      }
      if (!isNumber(durationOption) && !isString(durationOption)) {
        console.error(`MUI: Argument "duration" must be a number or a string but found ${durationOption}.`);
      }
      if (!isString(easingOption)) {
        console.error('MUI: Argument "easing" must be a string.');
      }
      if (!isNumber(delay) && !isString(delay)) {
        console.error('MUI: Argument "delay" must be a number or a string.');
      }
      if (typeof options !== 'object') {
        console.error(['MUI: Secong argument of transition.create must be an object.', "Arguments should be either `create('prop1', options)` or `create(['prop1', 'prop2'], options)`"].join('\n'));
      }
      if (Object.keys(other).length !== 0) {
        console.error(`MUI: Unrecognized argument(s) [${Object.keys(other).join(',')}].`);
      }
    }
    return (Array.isArray(props) ? props : [props]).map(animatedProp => `${animatedProp} ${typeof durationOption === 'string' ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === 'string' ? delay : formatMs(delay)}`).join(',');
  };
  return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({
    getAutoHeightDuration,
    create
  }, inputTransitions, {
    easing: mergedEasing,
    duration: mergedDuration
  });
}

/***/ }),

/***/ "./node_modules/@mui/material/styles/createTypography.js":
/*!***************************************************************!*\
  !*** ./node_modules/@mui/material/styles/createTypography.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createTypography)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var _mui_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @mui/utils */ "./node_modules/@mui/utils/esm/deepmerge.js");


const _excluded = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];

function round(value) {
  return Math.round(value * 1e5) / 1e5;
}
const caseAllCaps = {
  textTransform: 'uppercase'
};
const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';

/**
 * @see @link{https://m2.material.io/design/typography/the-type-system.html}
 * @see @link{https://m2.material.io/design/typography/understanding-typography.html}
 */
function createTypography(palette, typography) {
  const _ref = typeof typography === 'function' ? typography(palette) : typography,
    {
      fontFamily = defaultFontFamily,
      // The default font size of the Material Specification.
      fontSize = 14,
      // px
      fontWeightLight = 300,
      fontWeightRegular = 400,
      fontWeightMedium = 500,
      fontWeightBold = 700,
      // Tell MUI what's the font-size on the html element.
      // 16px is the default font-size used by browsers.
      htmlFontSize = 16,
      // Apply the CSS properties to all the variants.
      allVariants,
      pxToRem: pxToRem2
    } = _ref,
    other = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(_ref, _excluded);
  if (true) {
    if (typeof fontSize !== 'number') {
      console.error('MUI: `fontSize` is required to be a number.');
    }
    if (typeof htmlFontSize !== 'number') {
      console.error('MUI: `htmlFontSize` is required to be a number.');
    }
  }
  const coef = fontSize / 14;
  const pxToRem = pxToRem2 || (size => `${size / htmlFontSize * coef}rem`);
  const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    fontFamily,
    fontWeight,
    fontSize: pxToRem(size),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight
  }, fontFamily === defaultFontFamily ? {
    letterSpacing: `${round(letterSpacing / size)}em`
  } : {}, casing, allVariants);
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: 'inherit',
      fontWeight: 'inherit',
      fontSize: 'inherit',
      lineHeight: 'inherit',
      letterSpacing: 'inherit'
    }
  };
  return (0,_mui_utils__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    htmlFontSize,
    pxToRem,
    fontFamily,
    fontSize,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold
  }, variants), other, {
    clone: false // No need to clone deep
  });
}

/***/ }),

/***/ "./node_modules/@mui/material/styles/shadows.js":
/*!******************************************************!*\
  !*** ./node_modules/@mui/material/styles/shadows.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const shadowKeyUmbraOpacity = 0.2;
const shadowKeyPenumbraOpacity = 0.14;
const shadowAmbientShadowOpacity = 0.12;
function createShadow(...px) {
  return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(',');
}

// Values from https://github.com/material-components/material-components-web/blob/be8747f94574669cb5e7add1a7c54fa41a89cec7/packages/mdc-elevation/_variables.scss
const shadows = ['none', createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (shadows);

/***/ }),

/***/ "./node_modules/@mui/material/styles/zIndex.js":
/*!*****************************************************!*\
  !*** ./node_modules/@mui/material/styles/zIndex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// We need to centralize the zIndex definitions as they work
// like global values in the browser.
const zIndex = {
  mobileStepper: 1000,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (zIndex);

/***/ }),

/***/ "./node_modules/@mui/system/esm/borders.js":
/*!*************************************************!*\
  !*** ./node_modules/@mui/system/esm/borders.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   border: () => (/* binding */ border),
/* harmony export */   borderBottom: () => (/* binding */ borderBottom),
/* harmony export */   borderBottomColor: () => (/* binding */ borderBottomColor),
/* harmony export */   borderColor: () => (/* binding */ borderColor),
/* harmony export */   borderLeft: () => (/* binding */ borderLeft),
/* harmony export */   borderLeftColor: () => (/* binding */ borderLeftColor),
/* harmony export */   borderRadius: () => (/* binding */ borderRadius),
/* harmony export */   borderRight: () => (/* binding */ borderRight),
/* harmony export */   borderRightColor: () => (/* binding */ borderRightColor),
/* harmony export */   borderTop: () => (/* binding */ borderTop),
/* harmony export */   borderTopColor: () => (/* binding */ borderTopColor),
/* harmony export */   borderTransform: () => (/* binding */ borderTransform),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   outline: () => (/* binding */ outline),
/* harmony export */   outlineColor: () => (/* binding */ outlineColor)
/* harmony export */ });
/* harmony import */ var _responsivePropType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./responsivePropType */ "./node_modules/@mui/system/esm/responsivePropType.js");
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style */ "./node_modules/@mui/system/esm/style.js");
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./compose */ "./node_modules/@mui/system/esm/compose.js");
/* harmony import */ var _spacing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./spacing */ "./node_modules/@mui/system/esm/spacing.js");
/* harmony import */ var _breakpoints__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./breakpoints */ "./node_modules/@mui/system/esm/breakpoints.js");





function borderTransform(value) {
  if (typeof value !== 'number') {
    return value;
  }
  return `${value}px solid`;
}
function createBorderStyle(prop, transform) {
  return (0,_style__WEBPACK_IMPORTED_MODULE_0__["default"])({
    prop,
    themeKey: 'borders',
    transform
  });
}
const border = createBorderStyle('border', borderTransform);
const borderTop = createBorderStyle('borderTop', borderTransform);
const borderRight = createBorderStyle('borderRight', borderTransform);
const borderBottom = createBorderStyle('borderBottom', borderTransform);
const borderLeft = createBorderStyle('borderLeft', borderTransform);
const borderColor = createBorderStyle('borderColor');
const borderTopColor = createBorderStyle('borderTopColor');
const borderRightColor = createBorderStyle('borderRightColor');
const borderBottomColor = createBorderStyle('borderBottomColor');
const borderLeftColor = createBorderStyle('borderLeftColor');
const outline = createBorderStyle('outline', borderTransform);
const outlineColor = createBorderStyle('outlineColor');

// false positive
// eslint-disable-next-line react/function-component-definition
const borderRadius = props => {
  if (props.borderRadius !== undefined && props.borderRadius !== null) {
    const transformer = (0,_spacing__WEBPACK_IMPORTED_MODULE_1__.createUnaryUnit)(props.theme, 'shape.borderRadius', 4, 'borderRadius');
    const styleFromPropValue = propValue => ({
      borderRadius: (0,_spacing__WEBPACK_IMPORTED_MODULE_1__.getValue)(transformer, propValue)
    });
    return (0,_breakpoints__WEBPACK_IMPORTED_MODULE_2__.handleBreakpoints)(props, props.borderRadius, styleFromPropValue);
  }
  return null;
};
borderRadius.propTypes =  true ? {
  borderRadius: _responsivePropType__WEBPACK_IMPORTED_MODULE_3__["default"]
} : 0;
borderRadius.filterProps = ['borderRadius'];
const borders = (0,_compose__WEBPACK_IMPORTED_MODULE_4__["default"])(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (borders);

/***/ }),

/***/ "./node_modules/@mui/system/esm/breakpoints.js":
/*!*****************************************************!*\
  !*** ./node_modules/@mui/system/esm/breakpoints.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   computeBreakpointsBase: () => (/* binding */ computeBreakpointsBase),
/* harmony export */   createEmptyBreakpointObject: () => (/* binding */ createEmptyBreakpointObject),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   handleBreakpoints: () => (/* binding */ handleBreakpoints),
/* harmony export */   mergeBreakpointsInOrder: () => (/* binding */ mergeBreakpointsInOrder),
/* harmony export */   removeUnusedBreakpoints: () => (/* binding */ removeUnusedBreakpoints),
/* harmony export */   resolveBreakpointValues: () => (/* binding */ resolveBreakpointValues),
/* harmony export */   values: () => (/* binding */ values)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _mui_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @mui/utils */ "./node_modules/@mui/utils/esm/deepmerge.js");
/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./merge */ "./node_modules/@mui/system/esm/merge.js");





// The breakpoint **start** at this value.
// For instance with the first breakpoint xs: [xs, sm[.
const values = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536 // large screen
};
const defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ['xs', 'sm', 'md', 'lg', 'xl'],
  up: key => `@media (min-width:${values[key]}px)`
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme = props.theme || {};
  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
      return acc;
    }, {});
  }
  if (typeof propValue === 'object') {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      // key is breakpoint
      if (Object.keys(themeBreakpoints.values || values).indexOf(breakpoint) !== -1) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  const output = styleFromPropValue(propValue);
  return output;
}
function breakpoints(styleFunction) {
  // false positive
  // eslint-disable-next-line react/function-component-definition
  const newStyleFunction = props => {
    const theme = props.theme || {};
    const base = styleFunction(props);
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    const extended = themeBreakpoints.keys.reduce((acc, key) => {
      if (props[key]) {
        acc = acc || {};
        acc[themeBreakpoints.up(key)] = styleFunction((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
          theme
        }, props[key]));
      }
      return acc;
    }, null);
    return (0,_merge__WEBPACK_IMPORTED_MODULE_1__["default"])(base, extended);
  };
  newStyleFunction.propTypes =  true ? (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, styleFunction.propTypes, {
    xs: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().object),
    sm: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().object),
    md: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().object),
    lg: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().object),
    xl: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().object)
  }) : 0;
  newStyleFunction.filterProps = ['xs', 'sm', 'md', 'lg', 'xl', ...styleFunction.filterProps];
  return newStyleFunction;
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
  var _breakpointsInput$key;
  const breakpointsInOrder = (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key) => {
    const breakpointStyleKey = breakpointsInput.up(key);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
function removeUnusedBreakpoints(breakpointKeys, style) {
  return breakpointKeys.reduce((acc, key) => {
    const breakpointOutput = acc[key];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
    if (isBreakpointUnused) {
      delete acc[key];
    }
    return acc;
  }, style);
}
function mergeBreakpointsInOrder(breakpointsInput, ...styles) {
  const emptyBreakpoints = createEmptyBreakpointObject(breakpointsInput);
  const mergedOutput = [emptyBreakpoints, ...styles].reduce((prev, next) => (0,_mui_utils__WEBPACK_IMPORTED_MODULE_3__["default"])(prev, next), {});
  return removeUnusedBreakpoints(Object.keys(emptyBreakpoints), mergedOutput);
}

// compute base for responsive values; e.g.,
// [1,2,3] => {xs: true, sm: true, md: true}
// {xs: 1, sm: 2, md: 3} => {xs: true, sm: true, md: true}
function computeBreakpointsBase(breakpointValues, themeBreakpoints) {
  // fixed value
  if (typeof breakpointValues !== 'object') {
    return {};
  }
  const base = {};
  const breakpointsKeys = Object.keys(themeBreakpoints);
  if (Array.isArray(breakpointValues)) {
    breakpointsKeys.forEach((breakpoint, i) => {
      if (i < breakpointValues.length) {
        base[breakpoint] = true;
      }
    });
  } else {
    breakpointsKeys.forEach(breakpoint => {
      if (breakpointValues[breakpoint] != null) {
        base[breakpoint] = true;
      }
    });
  }
  return base;
}
function resolveBreakpointValues({
  values: breakpointValues,
  breakpoints: themeBreakpoints,
  base: customBase
}) {
  const base = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);
  const keys = Object.keys(base);
  if (keys.length === 0) {
    return breakpointValues;
  }
  let previous;
  return keys.reduce((acc, breakpoint, i) => {
    if (Array.isArray(breakpointValues)) {
      acc[breakpoint] = breakpointValues[i] != null ? breakpointValues[i] : breakpointValues[previous];
      previous = i;
    } else if (typeof breakpointValues === 'object') {
      acc[breakpoint] = breakpointValues[breakpoint] != null ? breakpointValues[breakpoint] : breakpointValues[previous];
      previous = breakpoint;
    } else {
      acc[breakpoint] = breakpointValues;
    }
    return acc;
  }, {});
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (breakpoints);

/***/ }),

/***/ "./node_modules/@mui/system/esm/colorManipulator.js":
/*!**********************************************************!*\
  !*** ./node_modules/@mui/system/esm/colorManipulator.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   alpha: () => (/* binding */ alpha),
/* harmony export */   colorChannel: () => (/* binding */ colorChannel),
/* harmony export */   darken: () => (/* binding */ darken),
/* harmony export */   decomposeColor: () => (/* binding */ decomposeColor),
/* harmony export */   emphasize: () => (/* binding */ emphasize),
/* harmony export */   getContrastRatio: () => (/* binding */ getContrastRatio),
/* harmony export */   getLuminance: () => (/* binding */ getLuminance),
/* harmony export */   hexToRgb: () => (/* binding */ hexToRgb),
/* harmony export */   hslToRgb: () => (/* binding */ hslToRgb),
/* harmony export */   lighten: () => (/* binding */ lighten),
/* harmony export */   private_safeAlpha: () => (/* binding */ private_safeAlpha),
/* harmony export */   private_safeColorChannel: () => (/* binding */ private_safeColorChannel),
/* harmony export */   private_safeDarken: () => (/* binding */ private_safeDarken),
/* harmony export */   private_safeEmphasize: () => (/* binding */ private_safeEmphasize),
/* harmony export */   private_safeLighten: () => (/* binding */ private_safeLighten),
/* harmony export */   recomposeColor: () => (/* binding */ recomposeColor),
/* harmony export */   rgbToHex: () => (/* binding */ rgbToHex)
/* harmony export */ });
/* harmony import */ var _mui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mui/utils */ "./node_modules/@mui/utils/esm/clamp/clamp.js");

/* eslint-disable @typescript-eslint/naming-convention */

/**
 * Returns a number whose value is limited to the given range.
 * @param {number} value The value to be clamped
 * @param {number} min The lower boundary of the output range
 * @param {number} max The upper boundary of the output range
 * @returns {number} A number in the range [min, max]
 */
function clampWrapper(value, min = 0, max = 1) {
  if (true) {
    if (value < min || value > max) {
      console.error(`MUI: The value provided ${value} is out of range [${min}, ${max}].`);
    }
  }
  return (0,_mui_utils__WEBPACK_IMPORTED_MODULE_0__["default"])(value, min, max);
}

/**
 * Converts a color from CSS hex format to CSS rgb format.
 * @param {string} color - Hex color, i.e. #nnn or #nnnnnn
 * @returns {string} A CSS rgb color string
 */
function hexToRgb(color) {
  color = color.slice(1);
  const re = new RegExp(`.{1,${color.length >= 6 ? 2 : 1}}`, 'g');
  let colors = color.match(re);
  if (colors && colors[0].length === 1) {
    colors = colors.map(n => n + n);
  }
  return colors ? `rgb${colors.length === 4 ? 'a' : ''}(${colors.map((n, index) => {
    return index < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1000) / 1000;
  }).join(', ')})` : '';
}
function intToHex(int) {
  const hex = int.toString(16);
  return hex.length === 1 ? `0${hex}` : hex;
}

/**
 * Returns an object with the type and values of a color.
 *
 * Note: Does not support rgb % values.
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @returns {object} - A MUI color object: {type: string, values: number[]}
 */
function decomposeColor(color) {
  // Idempotent
  if (color.type) {
    return color;
  }
  if (color.charAt(0) === '#') {
    return decomposeColor(hexToRgb(color));
  }
  const marker = color.indexOf('(');
  const type = color.substring(0, marker);
  if (['rgb', 'rgba', 'hsl', 'hsla', 'color'].indexOf(type) === -1) {
    throw new Error( true ? `MUI: Unsupported \`${color}\` color.
The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().` : 0);
  }
  let values = color.substring(marker + 1, color.length - 1);
  let colorSpace;
  if (type === 'color') {
    values = values.split(' ');
    colorSpace = values.shift();
    if (values.length === 4 && values[3].charAt(0) === '/') {
      values[3] = values[3].slice(1);
    }
    if (['srgb', 'display-p3', 'a98-rgb', 'prophoto-rgb', 'rec-2020'].indexOf(colorSpace) === -1) {
      throw new Error( true ? `MUI: unsupported \`${colorSpace}\` color space.
The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.` : 0);
    }
  } else {
    values = values.split(',');
  }
  values = values.map(value => parseFloat(value));
  return {
    type,
    values,
    colorSpace
  };
}

/**
 * Returns a channel created from the input color.
 *
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @returns {string} - The channel for the color, that can be used in rgba or hsla colors
 */
const colorChannel = color => {
  const decomposedColor = decomposeColor(color);
  return decomposedColor.values.slice(0, 3).map((val, idx) => decomposedColor.type.indexOf('hsl') !== -1 && idx !== 0 ? `${val}%` : val).join(' ');
};
const private_safeColorChannel = (color, warning) => {
  try {
    return colorChannel(color);
  } catch (error) {
    if (warning && "development" !== 'production') {
      console.warn(warning);
    }
    return color;
  }
};

/**
 * Converts a color object with type and values to a string.
 * @param {object} color - Decomposed color
 * @param {string} color.type - One of: 'rgb', 'rgba', 'hsl', 'hsla', 'color'
 * @param {array} color.values - [n,n,n] or [n,n,n,n]
 * @returns {string} A CSS color string
 */
function recomposeColor(color) {
  const {
    type,
    colorSpace
  } = color;
  let {
    values
  } = color;
  if (type.indexOf('rgb') !== -1) {
    // Only convert the first 3 values to int (i.e. not alpha)
    values = values.map((n, i) => i < 3 ? parseInt(n, 10) : n);
  } else if (type.indexOf('hsl') !== -1) {
    values[1] = `${values[1]}%`;
    values[2] = `${values[2]}%`;
  }
  if (type.indexOf('color') !== -1) {
    values = `${colorSpace} ${values.join(' ')}`;
  } else {
    values = `${values.join(', ')}`;
  }
  return `${type}(${values})`;
}

/**
 * Converts a color from CSS rgb format to CSS hex format.
 * @param {string} color - RGB color, i.e. rgb(n, n, n)
 * @returns {string} A CSS rgb color string, i.e. #nnnnnn
 */
function rgbToHex(color) {
  // Idempotent
  if (color.indexOf('#') === 0) {
    return color;
  }
  const {
    values
  } = decomposeColor(color);
  return `#${values.map((n, i) => intToHex(i === 3 ? Math.round(255 * n) : n)).join('')}`;
}

/**
 * Converts a color from hsl format to rgb format.
 * @param {string} color - HSL color values
 * @returns {string} rgb color values
 */
function hslToRgb(color) {
  color = decomposeColor(color);
  const {
    values
  } = color;
  const h = values[0];
  const s = values[1] / 100;
  const l = values[2] / 100;
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  let type = 'rgb';
  const rgb = [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
  if (color.type === 'hsla') {
    type += 'a';
    rgb.push(values[3]);
  }
  return recomposeColor({
    type,
    values: rgb
  });
}
/**
 * The relative brightness of any point in a color space,
 * normalized to 0 for darkest black and 1 for lightest white.
 *
 * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @returns {number} The relative brightness of the color in the range 0 - 1
 */
function getLuminance(color) {
  color = decomposeColor(color);
  let rgb = color.type === 'hsl' || color.type === 'hsla' ? decomposeColor(hslToRgb(color)).values : color.values;
  rgb = rgb.map(val => {
    if (color.type !== 'color') {
      val /= 255; // normalized
    }
    return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
  });

  // Truncate at 3 digits
  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}

/**
 * Calculates the contrast ratio between two colors.
 *
 * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
 * @param {string} foreground - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @param {string} background - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @returns {number} A contrast ratio value in the range 0 - 21.
 */
function getContrastRatio(foreground, background) {
  const lumA = getLuminance(foreground);
  const lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}

/**
 * Sets the absolute transparency of a color.
 * Any existing alpha values are overwritten.
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @param {number} value - value to set the alpha channel to in the range 0 - 1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */
function alpha(color, value) {
  color = decomposeColor(color);
  value = clampWrapper(value);
  if (color.type === 'rgb' || color.type === 'hsl') {
    color.type += 'a';
  }
  if (color.type === 'color') {
    color.values[3] = `/${value}`;
  } else {
    color.values[3] = value;
  }
  return recomposeColor(color);
}
function private_safeAlpha(color, value, warning) {
  try {
    return alpha(color, value);
  } catch (error) {
    if (warning && "development" !== 'production') {
      console.warn(warning);
    }
    return color;
  }
}

/**
 * Darkens a color.
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @param {number} coefficient - multiplier in the range 0 - 1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */
function darken(color, coefficient) {
  color = decomposeColor(color);
  coefficient = clampWrapper(coefficient);
  if (color.type.indexOf('hsl') !== -1) {
    color.values[2] *= 1 - coefficient;
  } else if (color.type.indexOf('rgb') !== -1 || color.type.indexOf('color') !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color.values[i] *= 1 - coefficient;
    }
  }
  return recomposeColor(color);
}
function private_safeDarken(color, coefficient, warning) {
  try {
    return darken(color, coefficient);
  } catch (error) {
    if (warning && "development" !== 'production') {
      console.warn(warning);
    }
    return color;
  }
}

/**
 * Lightens a color.
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @param {number} coefficient - multiplier in the range 0 - 1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */
function lighten(color, coefficient) {
  color = decomposeColor(color);
  coefficient = clampWrapper(coefficient);
  if (color.type.indexOf('hsl') !== -1) {
    color.values[2] += (100 - color.values[2]) * coefficient;
  } else if (color.type.indexOf('rgb') !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color.values[i] += (255 - color.values[i]) * coefficient;
    }
  } else if (color.type.indexOf('color') !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color.values[i] += (1 - color.values[i]) * coefficient;
    }
  }
  return recomposeColor(color);
}
function private_safeLighten(color, coefficient, warning) {
  try {
    return lighten(color, coefficient);
  } catch (error) {
    if (warning && "development" !== 'production') {
      console.warn(warning);
    }
    return color;
  }
}

/**
 * Darken or lighten a color, depending on its luminance.
 * Light colors are darkened, dark colors are lightened.
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @param {number} coefficient=0.15 - multiplier in the range 0 - 1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */
function emphasize(color, coefficient = 0.15) {
  return getLuminance(color) > 0.5 ? darken(color, coefficient) : lighten(color, coefficient);
}
function private_safeEmphasize(color, coefficient, warning) {
  try {
    return private_safeEmphasize(color, coefficient);
  } catch (error) {
    if (warning && "development" !== 'production') {
      console.warn(warning);
    }
    return color;
  }
}

/***/ }),

/***/ "./node_modules/@mui/system/esm/compose.js":
/*!*************************************************!*\
  !*** ./node_modules/@mui/system/esm/compose.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./merge */ "./node_modules/@mui/system/esm/merge.js");

function compose(...styles) {
  const handlers = styles.reduce((acc, style) => {
    style.filterProps.forEach(prop => {
      acc[prop] = style;
    });
    return acc;
  }, {});

  // false positive
  // eslint-disable-next-line react/function-component-definition
  const fn = props => {
    return Object.keys(props).reduce((acc, prop) => {
      if (handlers[prop]) {
        return (0,_merge__WEBPACK_IMPORTED_MODULE_0__["default"])(acc, handlers[prop](props));
      }
      return acc;
    }, {});
  };
  fn.propTypes =  true ? styles.reduce((acc, style) => Object.assign(acc, style.propTypes), {}) : 0;
  fn.filterProps = styles.reduce((acc, style) => acc.concat(style.filterProps), []);
  return fn;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (compose);

/***/ }),

/***/ "./node_modules/@mui/system/esm/createTheme/createBreakpoints.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@mui/system/esm/createTheme/createBreakpoints.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   breakpointKeys: () => (/* binding */ breakpointKeys),
/* harmony export */   "default": () => (/* binding */ createBreakpoints)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");


const _excluded = ["values", "unit", "step"];
// Sorted ASC by size. That's important.
// It can't be configured as it's used statically for propTypes.
const breakpointKeys = ['xs', 'sm', 'md', 'lg', 'xl'];
const sortBreakpointsValues = values => {
  const breakpointsAsArray = Object.keys(values).map(key => ({
    key,
    val: values[key]
  })) || [];
  // Sort in ascending order
  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, acc, {
      [obj.key]: obj.val
    });
  }, {});
};

// Keep in mind that @media is inclusive by the CSS specification.
function createBreakpoints(breakpoints) {
  const {
      // The breakpoint **start** at this value.
      // For instance with the first breakpoint xs: [xs, sm).
      values = {
        xs: 0,
        // phone
        sm: 600,
        // tablet
        md: 900,
        // small laptop
        lg: 1200,
        // desktop
        xl: 1536 // large screen
      },
      unit = 'px',
      step = 5
    } = breakpoints,
    other = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(breakpoints, _excluded);
  const sortedValues = sortBreakpointsValues(values);
  const keys = Object.keys(sortedValues);
  function up(key) {
    const value = typeof values[key] === 'number' ? values[key] : key;
    return `@media (min-width:${value}${unit})`;
  }
  function down(key) {
    const value = typeof values[key] === 'number' ? values[key] : key;
    return `@media (max-width:${value - step / 100}${unit})`;
  }
  function between(start, end) {
    const endIndex = keys.indexOf(end);
    return `@media (min-width:${typeof values[start] === 'number' ? values[start] : start}${unit}) and ` + `(max-width:${(endIndex !== -1 && typeof values[keys[endIndex]] === 'number' ? values[keys[endIndex]] : end) - step / 100}${unit})`;
  }
  function only(key) {
    if (keys.indexOf(key) + 1 < keys.length) {
      return between(key, keys[keys.indexOf(key) + 1]);
    }
    return up(key);
  }
  function not(key) {
    // handle first and last key separately, for better readability
    const keyIndex = keys.indexOf(key);
    if (keyIndex === 0) {
      return up(keys[1]);
    }
    if (keyIndex === keys.length - 1) {
      return down(keys[keyIndex]);
    }
    return between(key, keys[keys.indexOf(key) + 1]).replace('@media', '@media not all and');
  }
  return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({
    keys,
    values: sortedValues,
    up,
    down,
    between,
    only,
    not,
    unit
  }, other);
}

/***/ }),

/***/ "./node_modules/@mui/system/esm/createTheme/createSpacing.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@mui/system/esm/createTheme/createSpacing.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createSpacing)
/* harmony export */ });
/* harmony import */ var _spacing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../spacing */ "./node_modules/@mui/system/esm/spacing.js");


// The different signatures imply different meaning for their arguments that can't be expressed structurally.
// We express the difference with variable names.

function createSpacing(spacingInput = 8) {
  // Already transformed.
  if (spacingInput.mui) {
    return spacingInput;
  }

  // Material Design layouts are visually balanced. Most measurements align to an 8dp grid, which aligns both spacing and the overall layout.
  // Smaller components, such as icons, can align to a 4dp grid.
  // https://m2.material.io/design/layout/understanding-layout.html
  const transform = (0,_spacing__WEBPACK_IMPORTED_MODULE_0__.createUnarySpacing)({
    spacing: spacingInput
  });
  const spacing = (...argsInput) => {
    if (true) {
      if (!(argsInput.length <= 4)) {
        console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${argsInput.length}`);
      }
    }
    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map(argument => {
      const output = transform(argument);
      return typeof output === 'number' ? `${output}px` : output;
    }).join(' ');
  };
  spacing.mui = true;
  return spacing;
}

/***/ }),

/***/ "./node_modules/@mui/system/esm/createTheme/createTheme.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@mui/system/esm/createTheme/createTheme.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var _mui_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @mui/utils */ "./node_modules/@mui/utils/esm/deepmerge.js");
/* harmony import */ var _createBreakpoints__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createBreakpoints */ "./node_modules/@mui/system/esm/createTheme/createBreakpoints.js");
/* harmony import */ var _shape__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shape */ "./node_modules/@mui/system/esm/createTheme/shape.js");
/* harmony import */ var _createSpacing__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createSpacing */ "./node_modules/@mui/system/esm/createTheme/createSpacing.js");
/* harmony import */ var _styleFunctionSx_styleFunctionSx__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../styleFunctionSx/styleFunctionSx */ "./node_modules/@mui/system/esm/styleFunctionSx/styleFunctionSx.js");
/* harmony import */ var _styleFunctionSx_defaultSxConfig__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../styleFunctionSx/defaultSxConfig */ "./node_modules/@mui/system/esm/styleFunctionSx/defaultSxConfig.js");


const _excluded = ["breakpoints", "palette", "spacing", "shape"];






function createTheme(options = {}, ...args) {
  const {
      breakpoints: breakpointsInput = {},
      palette: paletteInput = {},
      spacing: spacingInput,
      shape: shapeInput = {}
    } = options,
    other = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(options, _excluded);
  const breakpoints = (0,_createBreakpoints__WEBPACK_IMPORTED_MODULE_2__["default"])(breakpointsInput);
  const spacing = (0,_createSpacing__WEBPACK_IMPORTED_MODULE_3__["default"])(spacingInput);
  let muiTheme = (0,_mui_utils__WEBPACK_IMPORTED_MODULE_4__["default"])({
    breakpoints,
    direction: 'ltr',
    components: {},
    // Inject component definitions.
    palette: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
      mode: 'light'
    }, paletteInput),
    spacing,
    shape: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, _shape__WEBPACK_IMPORTED_MODULE_5__["default"], shapeInput)
  }, other);
  muiTheme = args.reduce((acc, argument) => (0,_mui_utils__WEBPACK_IMPORTED_MODULE_4__["default"])(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, _styleFunctionSx_defaultSxConfig__WEBPACK_IMPORTED_MODULE_6__["default"], other == null ? void 0 : other.unstable_sxConfig);
  muiTheme.unstable_sx = function sx(props) {
    return (0,_styleFunctionSx_styleFunctionSx__WEBPACK_IMPORTED_MODULE_7__["default"])({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createTheme);

/***/ }),

/***/ "./node_modules/@mui/system/esm/createTheme/shape.js":
/*!***********************************************************!*\
  !*** ./node_modules/@mui/system/esm/createTheme/shape.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const shape = {
  borderRadius: 4
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (shape);

/***/ }),

/***/ "./node_modules/@mui/system/esm/cssGrid.js":
/*!*************************************************!*\
  !*** ./node_modules/@mui/system/esm/cssGrid.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   columnGap: () => (/* binding */ columnGap),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   gap: () => (/* binding */ gap),
/* harmony export */   gridArea: () => (/* binding */ gridArea),
/* harmony export */   gridAutoColumns: () => (/* binding */ gridAutoColumns),
/* harmony export */   gridAutoFlow: () => (/* binding */ gridAutoFlow),
/* harmony export */   gridAutoRows: () => (/* binding */ gridAutoRows),
/* harmony export */   gridColumn: () => (/* binding */ gridColumn),
/* harmony export */   gridRow: () => (/* binding */ gridRow),
/* harmony export */   gridTemplateAreas: () => (/* binding */ gridTemplateAreas),
/* harmony export */   gridTemplateColumns: () => (/* binding */ gridTemplateColumns),
/* harmony export */   gridTemplateRows: () => (/* binding */ gridTemplateRows),
/* harmony export */   rowGap: () => (/* binding */ rowGap)
/* harmony export */ });
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./style */ "./node_modules/@mui/system/esm/style.js");
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./compose */ "./node_modules/@mui/system/esm/compose.js");
/* harmony import */ var _spacing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./spacing */ "./node_modules/@mui/system/esm/spacing.js");
/* harmony import */ var _breakpoints__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./breakpoints */ "./node_modules/@mui/system/esm/breakpoints.js");
/* harmony import */ var _responsivePropType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./responsivePropType */ "./node_modules/@mui/system/esm/responsivePropType.js");






// false positive
// eslint-disable-next-line react/function-component-definition
const gap = props => {
  if (props.gap !== undefined && props.gap !== null) {
    const transformer = (0,_spacing__WEBPACK_IMPORTED_MODULE_0__.createUnaryUnit)(props.theme, 'spacing', 8, 'gap');
    const styleFromPropValue = propValue => ({
      gap: (0,_spacing__WEBPACK_IMPORTED_MODULE_0__.getValue)(transformer, propValue)
    });
    return (0,_breakpoints__WEBPACK_IMPORTED_MODULE_1__.handleBreakpoints)(props, props.gap, styleFromPropValue);
  }
  return null;
};
gap.propTypes =  true ? {
  gap: _responsivePropType__WEBPACK_IMPORTED_MODULE_2__["default"]
} : 0;
gap.filterProps = ['gap'];

// false positive
// eslint-disable-next-line react/function-component-definition
const columnGap = props => {
  if (props.columnGap !== undefined && props.columnGap !== null) {
    const transformer = (0,_spacing__WEBPACK_IMPORTED_MODULE_0__.createUnaryUnit)(props.theme, 'spacing', 8, 'columnGap');
    const styleFromPropValue = propValue => ({
      columnGap: (0,_spacing__WEBPACK_IMPORTED_MODULE_0__.getValue)(transformer, propValue)
    });
    return (0,_breakpoints__WEBPACK_IMPORTED_MODULE_1__.handleBreakpoints)(props, props.columnGap, styleFromPropValue);
  }
  return null;
};
columnGap.propTypes =  true ? {
  columnGap: _responsivePropType__WEBPACK_IMPORTED_MODULE_2__["default"]
} : 0;
columnGap.filterProps = ['columnGap'];

// false positive
// eslint-disable-next-line react/function-component-definition
const rowGap = props => {
  if (props.rowGap !== undefined && props.rowGap !== null) {
    const transformer = (0,_spacing__WEBPACK_IMPORTED_MODULE_0__.createUnaryUnit)(props.theme, 'spacing', 8, 'rowGap');
    const styleFromPropValue = propValue => ({
      rowGap: (0,_spacing__WEBPACK_IMPORTED_MODULE_0__.getValue)(transformer, propValue)
    });
    return (0,_breakpoints__WEBPACK_IMPORTED_MODULE_1__.handleBreakpoints)(props, props.rowGap, styleFromPropValue);
  }
  return null;
};
rowGap.propTypes =  true ? {
  rowGap: _responsivePropType__WEBPACK_IMPORTED_MODULE_2__["default"]
} : 0;
rowGap.filterProps = ['rowGap'];
const gridColumn = (0,_style__WEBPACK_IMPORTED_MODULE_3__["default"])({
  prop: 'gridColumn'
});
const gridRow = (0,_style__WEBPACK_IMPORTED_MODULE_3__["default"])({
  prop: 'gridRow'
});
const gridAutoFlow = (0,_style__WEBPACK_IMPORTED_MODULE_3__["default"])({
  prop: 'gridAutoFlow'
});
const gridAutoColumns = (0,_style__WEBPACK_IMPORTED_MODULE_3__["default"])({
  prop: 'gridAutoColumns'
});
const gridAutoRows = (0,_style__WEBPACK_IMPORTED_MODULE_3__["default"])({
  prop: 'gridAutoRows'
});
const gridTemplateColumns = (0,_style__WEBPACK_IMPORTED_MODULE_3__["default"])({
  prop: 'gridTemplateColumns'
});
const gridTemplateRows = (0,_style__WEBPACK_IMPORTED_MODULE_3__["default"])({
  prop: 'gridTemplateRows'
});
const gridTemplateAreas = (0,_style__WEBPACK_IMPORTED_MODULE_3__["default"])({
  prop: 'gridTemplateAreas'
});
const gridArea = (0,_style__WEBPACK_IMPORTED_MODULE_3__["default"])({
  prop: 'gridArea'
});
const grid = (0,_compose__WEBPACK_IMPORTED_MODULE_4__["default"])(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (grid);

/***/ }),

/***/ "./node_modules/@mui/system/esm/memoize.js":
/*!*************************************************!*\
  !*** ./node_modules/@mui/system/esm/memoize.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ memoize)
/* harmony export */ });
function memoize(fn) {
  const cache = {};
  return arg => {
    if (cache[arg] === undefined) {
      cache[arg] = fn(arg);
    }
    return cache[arg];
  };
}

/***/ }),

/***/ "./node_modules/@mui/system/esm/merge.js":
/*!***********************************************!*\
  !*** ./node_modules/@mui/system/esm/merge.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _mui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mui/utils */ "./node_modules/@mui/utils/esm/deepmerge.js");

function merge(acc, item) {
  if (!item) {
    return acc;
  }
  return (0,_mui_utils__WEBPACK_IMPORTED_MODULE_0__["default"])(acc, item, {
    clone: false // No need to clone deep, it's way faster.
  });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (merge);

/***/ }),

/***/ "./node_modules/@mui/system/esm/palette.js":
/*!*************************************************!*\
  !*** ./node_modules/@mui/system/esm/palette.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   backgroundColor: () => (/* binding */ backgroundColor),
/* harmony export */   bgcolor: () => (/* binding */ bgcolor),
/* harmony export */   color: () => (/* binding */ color),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   paletteTransform: () => (/* binding */ paletteTransform)
/* harmony export */ });
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style */ "./node_modules/@mui/system/esm/style.js");
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compose */ "./node_modules/@mui/system/esm/compose.js");


function paletteTransform(value, userValue) {
  if (userValue === 'grey') {
    return userValue;
  }
  return value;
}
const color = (0,_style__WEBPACK_IMPORTED_MODULE_0__["default"])({
  prop: 'color',
  themeKey: 'palette',
  transform: paletteTransform
});
const bgcolor = (0,_style__WEBPACK_IMPORTED_MODULE_0__["default"])({
  prop: 'bgcolor',
  cssProperty: 'backgroundColor',
  themeKey: 'palette',
  transform: paletteTransform
});
const backgroundColor = (0,_style__WEBPACK_IMPORTED_MODULE_0__["default"])({
  prop: 'backgroundColor',
  themeKey: 'palette',
  transform: paletteTransform
});
const palette = (0,_compose__WEBPACK_IMPORTED_MODULE_1__["default"])(color, bgcolor, backgroundColor);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (palette);

/***/ }),

/***/ "./node_modules/@mui/system/esm/responsivePropType.js":
/*!************************************************************!*\
  !*** ./node_modules/@mui/system/esm/responsivePropType.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);

const responsivePropType =  true ? prop_types__WEBPACK_IMPORTED_MODULE_0___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_0___default().number), (prop_types__WEBPACK_IMPORTED_MODULE_0___default().string), (prop_types__WEBPACK_IMPORTED_MODULE_0___default().object), (prop_types__WEBPACK_IMPORTED_MODULE_0___default().array)]) : 0;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (responsivePropType);

/***/ }),

/***/ "./node_modules/@mui/system/esm/sizing.js":
/*!************************************************!*\
  !*** ./node_modules/@mui/system/esm/sizing.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   boxSizing: () => (/* binding */ boxSizing),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   height: () => (/* binding */ height),
/* harmony export */   maxHeight: () => (/* binding */ maxHeight),
/* harmony export */   maxWidth: () => (/* binding */ maxWidth),
/* harmony export */   minHeight: () => (/* binding */ minHeight),
/* harmony export */   minWidth: () => (/* binding */ minWidth),
/* harmony export */   sizeHeight: () => (/* binding */ sizeHeight),
/* harmony export */   sizeWidth: () => (/* binding */ sizeWidth),
/* harmony export */   sizingTransform: () => (/* binding */ sizingTransform),
/* harmony export */   width: () => (/* binding */ width)
/* harmony export */ });
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style */ "./node_modules/@mui/system/esm/style.js");
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./compose */ "./node_modules/@mui/system/esm/compose.js");
/* harmony import */ var _breakpoints__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./breakpoints */ "./node_modules/@mui/system/esm/breakpoints.js");



function sizingTransform(value) {
  return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
const width = (0,_style__WEBPACK_IMPORTED_MODULE_0__["default"])({
  prop: 'width',
  transform: sizingTransform
});
const maxWidth = props => {
  if (props.maxWidth !== undefined && props.maxWidth !== null) {
    const styleFromPropValue = propValue => {
      var _props$theme, _props$theme2;
      const breakpoint = ((_props$theme = props.theme) == null || (_props$theme = _props$theme.breakpoints) == null || (_props$theme = _props$theme.values) == null ? void 0 : _props$theme[propValue]) || _breakpoints__WEBPACK_IMPORTED_MODULE_1__.values[propValue];
      if (!breakpoint) {
        return {
          maxWidth: sizingTransform(propValue)
        };
      }
      if (((_props$theme2 = props.theme) == null || (_props$theme2 = _props$theme2.breakpoints) == null ? void 0 : _props$theme2.unit) !== 'px') {
        return {
          maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
        };
      }
      return {
        maxWidth: breakpoint
      };
    };
    return (0,_breakpoints__WEBPACK_IMPORTED_MODULE_1__.handleBreakpoints)(props, props.maxWidth, styleFromPropValue);
  }
  return null;
};
maxWidth.filterProps = ['maxWidth'];
const minWidth = (0,_style__WEBPACK_IMPORTED_MODULE_0__["default"])({
  prop: 'minWidth',
  transform: sizingTransform
});
const height = (0,_style__WEBPACK_IMPORTED_MODULE_0__["default"])({
  prop: 'height',
  transform: sizingTransform
});
const maxHeight = (0,_style__WEBPACK_IMPORTED_MODULE_0__["default"])({
  prop: 'maxHeight',
  transform: sizingTransform
});
const minHeight = (0,_style__WEBPACK_IMPORTED_MODULE_0__["default"])({
  prop: 'minHeight',
  transform: sizingTransform
});
const sizeWidth = (0,_style__WEBPACK_IMPORTED_MODULE_0__["default"])({
  prop: 'size',
  cssProperty: 'width',
  transform: sizingTransform
});
const sizeHeight = (0,_style__WEBPACK_IMPORTED_MODULE_0__["default"])({
  prop: 'size',
  cssProperty: 'height',
  transform: sizingTransform
});
const boxSizing = (0,_style__WEBPACK_IMPORTED_MODULE_0__["default"])({
  prop: 'boxSizing'
});
const sizing = (0,_compose__WEBPACK_IMPORTED_MODULE_2__["default"])(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sizing);

/***/ }),

/***/ "./node_modules/@mui/system/esm/spacing.js":
/*!*************************************************!*\
  !*** ./node_modules/@mui/system/esm/spacing.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createUnarySpacing: () => (/* binding */ createUnarySpacing),
/* harmony export */   createUnaryUnit: () => (/* binding */ createUnaryUnit),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getStyleFromPropValue: () => (/* binding */ getStyleFromPropValue),
/* harmony export */   getValue: () => (/* binding */ getValue),
/* harmony export */   margin: () => (/* binding */ margin),
/* harmony export */   marginKeys: () => (/* binding */ marginKeys),
/* harmony export */   padding: () => (/* binding */ padding),
/* harmony export */   paddingKeys: () => (/* binding */ paddingKeys)
/* harmony export */ });
/* harmony import */ var _responsivePropType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./responsivePropType */ "./node_modules/@mui/system/esm/responsivePropType.js");
/* harmony import */ var _breakpoints__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./breakpoints */ "./node_modules/@mui/system/esm/breakpoints.js");
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./style */ "./node_modules/@mui/system/esm/style.js");
/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./merge */ "./node_modules/@mui/system/esm/merge.js");
/* harmony import */ var _memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./memoize */ "./node_modules/@mui/system/esm/memoize.js");





const properties = {
  m: 'margin',
  p: 'padding'
};
const directions = {
  t: 'Top',
  r: 'Right',
  b: 'Bottom',
  l: 'Left',
  x: ['Left', 'Right'],
  y: ['Top', 'Bottom']
};
const aliases = {
  marginX: 'mx',
  marginY: 'my',
  paddingX: 'px',
  paddingY: 'py'
};

// memoize() impact:
// From 300,000 ops/sec
// To 350,000 ops/sec
const getCssProperties = (0,_memoize__WEBPACK_IMPORTED_MODULE_0__["default"])(prop => {
  // It's not a shorthand notation.
  if (prop.length > 2) {
    if (aliases[prop]) {
      prop = aliases[prop];
    } else {
      return [prop];
    }
  }
  const [a, b] = prop.split('');
  const property = properties[a];
  const direction = directions[b] || '';
  return Array.isArray(direction) ? direction.map(dir => property + dir) : [property + direction];
});
const marginKeys = ['m', 'mt', 'mr', 'mb', 'ml', 'mx', 'my', 'margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'marginX', 'marginY', 'marginInline', 'marginInlineStart', 'marginInlineEnd', 'marginBlock', 'marginBlockStart', 'marginBlockEnd'];
const paddingKeys = ['p', 'pt', 'pr', 'pb', 'pl', 'px', 'py', 'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'paddingX', 'paddingY', 'paddingInline', 'paddingInlineStart', 'paddingInlineEnd', 'paddingBlock', 'paddingBlockStart', 'paddingBlockEnd'];
const spacingKeys = [...marginKeys, ...paddingKeys];
function createUnaryUnit(theme, themeKey, defaultValue, propName) {
  var _getPath;
  const themeSpacing = (_getPath = (0,_style__WEBPACK_IMPORTED_MODULE_1__.getPath)(theme, themeKey, false)) != null ? _getPath : defaultValue;
  if (typeof themeSpacing === 'number') {
    return abs => {
      if (typeof abs === 'string') {
        return abs;
      }
      if (true) {
        if (typeof abs !== 'number') {
          console.error(`MUI: Expected ${propName} argument to be a number or a string, got ${abs}.`);
        }
      }
      return themeSpacing * abs;
    };
  }
  if (Array.isArray(themeSpacing)) {
    return abs => {
      if (typeof abs === 'string') {
        return abs;
      }
      if (true) {
        if (!Number.isInteger(abs)) {
          console.error([`MUI: The \`theme.${themeKey}\` array type cannot be combined with non integer values.` + `You should either use an integer value that can be used as index, or define the \`theme.${themeKey}\` as a number.`].join('\n'));
        } else if (abs > themeSpacing.length - 1) {
          console.error([`MUI: The value provided (${abs}) overflows.`, `The supported values are: ${JSON.stringify(themeSpacing)}.`, `${abs} > ${themeSpacing.length - 1}, you need to add the missing values.`].join('\n'));
        }
      }
      return themeSpacing[abs];
    };
  }
  if (typeof themeSpacing === 'function') {
    return themeSpacing;
  }
  if (true) {
    console.error([`MUI: The \`theme.${themeKey}\` value (${themeSpacing}) is invalid.`, 'It should be a number, an array or a function.'].join('\n'));
  }
  return () => undefined;
}
function createUnarySpacing(theme) {
  return createUnaryUnit(theme, 'spacing', 8, 'spacing');
}
function getValue(transformer, propValue) {
  if (typeof propValue === 'string' || propValue == null) {
    return propValue;
  }
  const abs = Math.abs(propValue);
  const transformed = transformer(abs);
  if (propValue >= 0) {
    return transformed;
  }
  if (typeof transformed === 'number') {
    return -transformed;
  }
  return `-${transformed}`;
}
function getStyleFromPropValue(cssProperties, transformer) {
  return propValue => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue(transformer, propValue);
    return acc;
  }, {});
}
function resolveCssProperty(props, keys, prop, transformer) {
  // Using a hash computation over an array iteration could be faster, but with only 28 items,
  // it's doesn't worth the bundle size.
  if (keys.indexOf(prop) === -1) {
    return null;
  }
  const cssProperties = getCssProperties(prop);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
  const propValue = props[prop];
  return (0,_breakpoints__WEBPACK_IMPORTED_MODULE_2__.handleBreakpoints)(props, propValue, styleFromPropValue);
}
function style(props, keys) {
  const transformer = createUnarySpacing(props.theme);
  return Object.keys(props).map(prop => resolveCssProperty(props, keys, prop, transformer)).reduce(_merge__WEBPACK_IMPORTED_MODULE_3__["default"], {});
}
function margin(props) {
  return style(props, marginKeys);
}
margin.propTypes =  true ? marginKeys.reduce((obj, key) => {
  obj[key] = _responsivePropType__WEBPACK_IMPORTED_MODULE_4__["default"];
  return obj;
}, {}) : 0;
margin.filterProps = marginKeys;
function padding(props) {
  return style(props, paddingKeys);
}
padding.propTypes =  true ? paddingKeys.reduce((obj, key) => {
  obj[key] = _responsivePropType__WEBPACK_IMPORTED_MODULE_4__["default"];
  return obj;
}, {}) : 0;
padding.filterProps = paddingKeys;
function spacing(props) {
  return style(props, spacingKeys);
}
spacing.propTypes =  true ? spacingKeys.reduce((obj, key) => {
  obj[key] = _responsivePropType__WEBPACK_IMPORTED_MODULE_4__["default"];
  return obj;
}, {}) : 0;
spacing.filterProps = spacingKeys;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (spacing);

/***/ }),

/***/ "./node_modules/@mui/system/esm/style.js":
/*!***********************************************!*\
  !*** ./node_modules/@mui/system/esm/style.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getPath: () => (/* binding */ getPath),
/* harmony export */   getStyleValue: () => (/* binding */ getStyleValue)
/* harmony export */ });
/* harmony import */ var _mui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mui/utils */ "./node_modules/@mui/utils/esm/capitalize/capitalize.js");
/* harmony import */ var _responsivePropType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./responsivePropType */ "./node_modules/@mui/system/esm/responsivePropType.js");
/* harmony import */ var _breakpoints__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./breakpoints */ "./node_modules/@mui/system/esm/breakpoints.js");



function getPath(obj, path, checkVars = true) {
  if (!path || typeof path !== 'string') {
    return null;
  }

  // Check if CSS variables are used
  if (obj && obj.vars && checkVars) {
    const val = `vars.${path}`.split('.').reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
    if (val != null) {
      return val;
    }
  }
  return path.split('.').reduce((acc, item) => {
    if (acc && acc[item] != null) {
      return acc[item];
    }
    return null;
  }, obj);
}
function getStyleValue(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
  let value;
  if (typeof themeMapping === 'function') {
    value = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value = themeMapping[propValueFinal] || userValue;
  } else {
    value = getPath(themeMapping, propValueFinal) || userValue;
  }
  if (transform) {
    value = transform(value, userValue, themeMapping);
  }
  return value;
}
function style(options) {
  const {
    prop,
    cssProperty = options.prop,
    themeKey,
    transform
  } = options;

  // false positive
  // eslint-disable-next-line react/function-component-definition
  const fn = props => {
    if (props[prop] == null) {
      return null;
    }
    const propValue = props[prop];
    const theme = props.theme;
    const themeMapping = getPath(theme, themeKey) || {};
    const styleFromPropValue = propValueFinal => {
      let value = getStyleValue(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === 'string') {
        // Haven't found value
        value = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === 'default' ? '' : (0,_mui_utils__WEBPACK_IMPORTED_MODULE_0__["default"])(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return (0,_breakpoints__WEBPACK_IMPORTED_MODULE_1__.handleBreakpoints)(props, propValue, styleFromPropValue);
  };
  fn.propTypes =  true ? {
    [prop]: _responsivePropType__WEBPACK_IMPORTED_MODULE_2__["default"]
  } : 0;
  fn.filterProps = [prop];
  return fn;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (style);

/***/ }),

/***/ "./node_modules/@mui/system/esm/styleFunctionSx/defaultSxConfig.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@mui/system/esm/styleFunctionSx/defaultSxConfig.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _spacing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../spacing */ "./node_modules/@mui/system/esm/spacing.js");
/* harmony import */ var _borders__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../borders */ "./node_modules/@mui/system/esm/borders.js");
/* harmony import */ var _cssGrid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cssGrid */ "./node_modules/@mui/system/esm/cssGrid.js");
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../palette */ "./node_modules/@mui/system/esm/palette.js");
/* harmony import */ var _sizing__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../sizing */ "./node_modules/@mui/system/esm/sizing.js");





const defaultSxConfig = {
  // borders
  border: {
    themeKey: 'borders',
    transform: _borders__WEBPACK_IMPORTED_MODULE_0__.borderTransform
  },
  borderTop: {
    themeKey: 'borders',
    transform: _borders__WEBPACK_IMPORTED_MODULE_0__.borderTransform
  },
  borderRight: {
    themeKey: 'borders',
    transform: _borders__WEBPACK_IMPORTED_MODULE_0__.borderTransform
  },
  borderBottom: {
    themeKey: 'borders',
    transform: _borders__WEBPACK_IMPORTED_MODULE_0__.borderTransform
  },
  borderLeft: {
    themeKey: 'borders',
    transform: _borders__WEBPACK_IMPORTED_MODULE_0__.borderTransform
  },
  borderColor: {
    themeKey: 'palette'
  },
  borderTopColor: {
    themeKey: 'palette'
  },
  borderRightColor: {
    themeKey: 'palette'
  },
  borderBottomColor: {
    themeKey: 'palette'
  },
  borderLeftColor: {
    themeKey: 'palette'
  },
  outline: {
    themeKey: 'borders',
    transform: _borders__WEBPACK_IMPORTED_MODULE_0__.borderTransform
  },
  outlineColor: {
    themeKey: 'palette'
  },
  borderRadius: {
    themeKey: 'shape.borderRadius',
    style: _borders__WEBPACK_IMPORTED_MODULE_0__.borderRadius
  },
  // palette
  color: {
    themeKey: 'palette',
    transform: _palette__WEBPACK_IMPORTED_MODULE_1__.paletteTransform
  },
  bgcolor: {
    themeKey: 'palette',
    cssProperty: 'backgroundColor',
    transform: _palette__WEBPACK_IMPORTED_MODULE_1__.paletteTransform
  },
  backgroundColor: {
    themeKey: 'palette',
    transform: _palette__WEBPACK_IMPORTED_MODULE_1__.paletteTransform
  },
  // spacing
  p: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.padding
  },
  pt: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.padding
  },
  pr: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.padding
  },
  pb: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.padding
  },
  pl: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.padding
  },
  px: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.padding
  },
  py: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.padding
  },
  padding: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.padding
  },
  paddingTop: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.padding
  },
  paddingRight: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.padding
  },
  paddingBottom: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.padding
  },
  paddingLeft: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.padding
  },
  paddingX: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.padding
  },
  paddingY: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.padding
  },
  paddingInline: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.padding
  },
  paddingInlineStart: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.padding
  },
  paddingInlineEnd: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.padding
  },
  paddingBlock: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.padding
  },
  paddingBlockStart: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.padding
  },
  paddingBlockEnd: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.padding
  },
  m: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.margin
  },
  mt: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.margin
  },
  mr: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.margin
  },
  mb: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.margin
  },
  ml: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.margin
  },
  mx: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.margin
  },
  my: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.margin
  },
  margin: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.margin
  },
  marginTop: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.margin
  },
  marginRight: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.margin
  },
  marginBottom: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.margin
  },
  marginLeft: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.margin
  },
  marginX: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.margin
  },
  marginY: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.margin
  },
  marginInline: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.margin
  },
  marginInlineStart: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.margin
  },
  marginInlineEnd: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.margin
  },
  marginBlock: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.margin
  },
  marginBlockStart: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.margin
  },
  marginBlockEnd: {
    style: _spacing__WEBPACK_IMPORTED_MODULE_2__.margin
  },
  // display
  displayPrint: {
    cssProperty: false,
    transform: value => ({
      '@media print': {
        display: value
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: _cssGrid__WEBPACK_IMPORTED_MODULE_3__.gap
  },
  rowGap: {
    style: _cssGrid__WEBPACK_IMPORTED_MODULE_3__.rowGap
  },
  columnGap: {
    style: _cssGrid__WEBPACK_IMPORTED_MODULE_3__.columnGap
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: 'zIndex'
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: 'shadows'
  },
  // sizing
  width: {
    transform: _sizing__WEBPACK_IMPORTED_MODULE_4__.sizingTransform
  },
  maxWidth: {
    style: _sizing__WEBPACK_IMPORTED_MODULE_4__.maxWidth
  },
  minWidth: {
    transform: _sizing__WEBPACK_IMPORTED_MODULE_4__.sizingTransform
  },
  height: {
    transform: _sizing__WEBPACK_IMPORTED_MODULE_4__.sizingTransform
  },
  maxHeight: {
    transform: _sizing__WEBPACK_IMPORTED_MODULE_4__.sizingTransform
  },
  minHeight: {
    transform: _sizing__WEBPACK_IMPORTED_MODULE_4__.sizingTransform
  },
  boxSizing: {},
  // typography
  fontFamily: {
    themeKey: 'typography'
  },
  fontSize: {
    themeKey: 'typography'
  },
  fontStyle: {
    themeKey: 'typography'
  },
  fontWeight: {
    themeKey: 'typography'
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: false,
    themeKey: 'typography'
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (defaultSxConfig);

/***/ }),

/***/ "./node_modules/@mui/system/esm/styleFunctionSx/styleFunctionSx.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@mui/system/esm/styleFunctionSx/styleFunctionSx.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   unstable_createStyleFunctionSx: () => (/* binding */ unstable_createStyleFunctionSx)
/* harmony export */ });
/* harmony import */ var _mui_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @mui/utils */ "./node_modules/@mui/utils/esm/capitalize/capitalize.js");
/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../merge */ "./node_modules/@mui/system/esm/merge.js");
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../style */ "./node_modules/@mui/system/esm/style.js");
/* harmony import */ var _breakpoints__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../breakpoints */ "./node_modules/@mui/system/esm/breakpoints.js");
/* harmony import */ var _defaultSxConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./defaultSxConfig */ "./node_modules/@mui/system/esm/styleFunctionSx/defaultSxConfig.js");





function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
  const union = new Set(allKeys);
  return objects.every(object => union.size === Object.keys(object).length);
}
function callIfFn(maybeFn, arg) {
  return typeof maybeFn === 'function' ? maybeFn(arg) : maybeFn;
}

// eslint-disable-next-line @typescript-eslint/naming-convention
function unstable_createStyleFunctionSx() {
  function getThemeValue(prop, val, theme, config) {
    const props = {
      [prop]: val,
      theme
    };
    const options = config[prop];
    if (!options) {
      return {
        [prop]: val
      };
    }
    const {
      cssProperty = prop,
      themeKey,
      transform,
      style
    } = options;
    if (val == null) {
      return null;
    }

    // TODO v6: remove, see https://github.com/mui/material-ui/pull/38123
    if (themeKey === 'typography' && val === 'inherit') {
      return {
        [prop]: val
      };
    }
    const themeMapping = (0,_style__WEBPACK_IMPORTED_MODULE_0__.getPath)(theme, themeKey) || {};
    if (style) {
      return style(props);
    }
    const styleFromPropValue = propValueFinal => {
      let value = (0,_style__WEBPACK_IMPORTED_MODULE_0__.getStyleValue)(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === 'string') {
        // Haven't found value
        value = (0,_style__WEBPACK_IMPORTED_MODULE_0__.getStyleValue)(themeMapping, transform, `${prop}${propValueFinal === 'default' ? '' : (0,_mui_utils__WEBPACK_IMPORTED_MODULE_1__["default"])(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return (0,_breakpoints__WEBPACK_IMPORTED_MODULE_2__.handleBreakpoints)(props, val, styleFromPropValue);
  }
  function styleFunctionSx(props) {
    var _theme$unstable_sxCon;
    const {
      sx,
      theme = {}
    } = props || {};
    if (!sx) {
      return null; // Emotion & styled-components will neglect null
    }
    const config = (_theme$unstable_sxCon = theme.unstable_sxConfig) != null ? _theme$unstable_sxCon : _defaultSxConfig__WEBPACK_IMPORTED_MODULE_3__["default"];

    /*
     * Receive `sxInput` as object or callback
     * and then recursively check keys & values to create media query object styles.
     * (the result will be used in `styled`)
     */
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === 'function') {
        sxObject = sxInput(theme);
      } else if (typeof sxInput !== 'object') {
        // value
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = (0,_breakpoints__WEBPACK_IMPORTED_MODULE_2__.createEmptyBreakpointObject)(theme.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css = emptyBreakpoints;
      Object.keys(sxObject).forEach(styleKey => {
        const value = callIfFn(sxObject[styleKey], theme);
        if (value !== null && value !== undefined) {
          if (typeof value === 'object') {
            if (config[styleKey]) {
              css = (0,_merge__WEBPACK_IMPORTED_MODULE_4__["default"])(css, getThemeValue(styleKey, value, theme, config));
            } else {
              const breakpointsValues = (0,_breakpoints__WEBPACK_IMPORTED_MODULE_2__.handleBreakpoints)({
                theme
              }, value, x => ({
                [styleKey]: x
              }));
              if (objectsHaveSameKeys(breakpointsValues, value)) {
                css[styleKey] = styleFunctionSx({
                  sx: value,
                  theme
                });
              } else {
                css = (0,_merge__WEBPACK_IMPORTED_MODULE_4__["default"])(css, breakpointsValues);
              }
            }
          } else {
            css = (0,_merge__WEBPACK_IMPORTED_MODULE_4__["default"])(css, getThemeValue(styleKey, value, theme, config));
          }
        }
      });
      return (0,_breakpoints__WEBPACK_IMPORTED_MODULE_2__.removeUnusedBreakpoints)(breakpointsKeys, css);
    }
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  return styleFunctionSx;
}
const styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ['sx'];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (styleFunctionSx);

/***/ }),

/***/ "./node_modules/@mui/utils/esm/ClassNameGenerator/ClassNameGenerator.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@mui/utils/esm/ClassNameGenerator/ClassNameGenerator.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const defaultGenerator = componentName => componentName;
const createClassNameGenerator = () => {
  let generate = defaultGenerator;
  return {
    configure(generator) {
      generate = generator;
    },
    generate(componentName) {
      return generate(componentName);
    },
    reset() {
      generate = defaultGenerator;
    }
  };
};
const ClassNameGenerator = createClassNameGenerator();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ClassNameGenerator);

/***/ }),

/***/ "./node_modules/@mui/utils/esm/capitalize/capitalize.js":
/*!**************************************************************!*\
  !*** ./node_modules/@mui/utils/esm/capitalize/capitalize.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ capitalize)
/* harmony export */ });

// It should to be noted that this function isn't equivalent to `text-transform: capitalize`.
//
// A strict capitalization should uppercase the first letter of each word in the sentence.
// We only handle the first word.
function capitalize(string) {
  if (typeof string !== 'string') {
    throw new Error( true ? `MUI: \`capitalize(string)\` expects a string argument.` : 0);
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
}

/***/ }),

/***/ "./node_modules/@mui/utils/esm/clamp/clamp.js":
/*!****************************************************!*\
  !*** ./node_modules/@mui/utils/esm/clamp/clamp.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function clamp(val, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER) {
  return Math.max(min, Math.min(val, max));
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (clamp);

/***/ }),

/***/ "./node_modules/@mui/utils/esm/deepmerge.js":
/*!**************************************************!*\
  !*** ./node_modules/@mui/utils/esm/deepmerge.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ deepmerge),
/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");

// https://github.com/sindresorhus/is-plain-obj/blob/main/index.js
function isPlainObject(item) {
  if (typeof item !== 'object' || item === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(item);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
}
function deepClone(source) {
  if (!isPlainObject(source)) {
    return source;
  }
  const output = {};
  Object.keys(source).forEach(key => {
    output[key] = deepClone(source[key]);
  });
  return output;
}
function deepmerge(target, source, options = {
  clone: true
}) {
  const output = options.clone ? (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, target) : target;
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach(key => {
      // Avoid prototype pollution
      if (key === '__proto__') {
        return;
      }
      if (isPlainObject(source[key]) && key in target && isPlainObject(target[key])) {
        // Since `output` is a clone of `target` and we have narrowed `target` in this block we can cast to the same type.
        output[key] = deepmerge(target[key], source[key], options);
      } else if (options.clone) {
        output[key] = isPlainObject(source[key]) ? deepClone(source[key]) : source[key];
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}

/***/ }),

/***/ "./node_modules/@mui/utils/esm/generateUtilityClass/generateUtilityClass.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@mui/utils/esm/generateUtilityClass/generateUtilityClass.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ generateUtilityClass),
/* harmony export */   globalStateClasses: () => (/* binding */ globalStateClasses),
/* harmony export */   isGlobalState: () => (/* binding */ isGlobalState)
/* harmony export */ });
/* harmony import */ var _ClassNameGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ClassNameGenerator */ "./node_modules/@mui/utils/esm/ClassNameGenerator/ClassNameGenerator.js");

const globalStateClasses = {
  active: 'active',
  checked: 'checked',
  completed: 'completed',
  disabled: 'disabled',
  error: 'error',
  expanded: 'expanded',
  focused: 'focused',
  focusVisible: 'focusVisible',
  open: 'open',
  readOnly: 'readOnly',
  required: 'required',
  selected: 'selected'
};
function generateUtilityClass(componentName, slot, globalStatePrefix = 'Mui') {
  const globalStateClass = globalStateClasses[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${_ClassNameGenerator__WEBPACK_IMPORTED_MODULE_0__["default"].generate(componentName)}-${slot}`;
}
function isGlobalState(slot) {
  return globalStateClasses[slot] !== undefined;
}

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = __webpack_require__(/*! ./lib/has */ "./node_modules/prop-types/lib/has.js");

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) { /**/ }
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +
              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/prop-types/node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var has = __webpack_require__(/*! ./lib/has */ "./node_modules/prop-types/lib/has.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bigint: createPrimitiveTypeChecker('bigint'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message, data) {
    this.message = message;
    this.data = data && typeof data === 'object' ? data: {};
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError(
          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),
          {expectedType: expectedType}
        );
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : 0;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      var expectedTypes = [];
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
        if (checkerResult == null) {
          return null;
        }
        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
          expectedTypes.push(checkerResult.data.expectedType);
        }
      }
      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function invalidValidatorError(componentName, location, propFullName, key, type) {
    return new PropTypeError(
      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +
      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'
    );
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (typeof checker !== 'function') {
          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (has(shapeTypes, key) && typeof checker !== 'function') {
          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
        }
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/prop-types/node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/prop-types/lib/has.js":
/*!********************************************!*\
  !*** ./node_modules/prop-types/lib/has.js ***!
  \********************************************/
/***/ ((module) => {

module.exports = Function.call.bind(Object.prototype.hasOwnProperty);


/***/ }),

/***/ "./node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/prop-types/node_modules/react-is/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/prop-types/node_modules/react-is/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/extends.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _extends)
/* harmony export */ });
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _objectWithoutPropertiesLoose)
/* harmony export */ });
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!***********************!*\
  !*** ./src/theme.jsx ***!
  \***********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   darkTheme: () => (/* binding */ darkTheme)
/* harmony export */ });
/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mui/material */ "./node_modules/@mui/material/styles/createTheme.js");

var darkTheme = (0,_mui_material__WEBPACK_IMPORTED_MODULE_0__["default"])({
  palette: {
    mode: "dark"
  },
  components: {
    MuiCssBaseline: {
      styleOverrides: {
        body: {
          scrollbarColor: "#ffffff #959595",
          "&::-webkit-scrollbar, & *::-webkit-scrollbar": {
            width: "5px",
            backgroundColor: "transparent"
          },
          "&::-webkit-scrollbar-thumb, & *::-webkit-scrollbar-thumb": {
            borderRadius: 8,
            backgroundColor: "#ffffff",
            minHeight: 24,
            border: "none"
          },
          "&::-webkit-scrollbar-thumb:focus, & *::-webkit-scrollbar-thumb:focus": {
            backgroundColor: "#6b6b6b"
          },
          "&::-webkit-scrollbar-thumb:active, & *::-webkit-scrollbar-thumb:active": {
            backgroundColor: "#6b6b6b"
          },
          "&::-webkit-scrollbar-thumb:hover, & *::-webkit-scrollbar-thumb:hover": {
            backgroundColor: "#6b6b6b"
          },
          "&::-webkit-scrollbar-corner, & *::-webkit-scrollbar-corner": {
            backgroundColor: "#959595"
          }
        }
      }
    }
  }
});
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGhlbWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLElBQUk7Ozs7Ozs7Ozs7Ozs7OztBQ2hCbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxNQUFNOzs7Ozs7Ozs7Ozs7Ozs7QUNKckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7QUNoQnBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsSUFBSTs7Ozs7Ozs7Ozs7Ozs7O0FDaEJuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLFNBQVM7Ozs7Ozs7Ozs7Ozs7OztBQ2hCeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxNQUFNOzs7Ozs7Ozs7Ozs7Ozs7QUNoQnJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsTUFBTTs7Ozs7Ozs7Ozs7Ozs7O0FDaEJyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQndDO0FB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QixHQUFHO0FBQ0g7QUFDQSxXQUFXLDZDQUFPO0FBQ2xCLEdBQUc7QUFDSDtBQUNBLFdBQVcsNkNBQU87QUFDbEIsR0FBRztBQUNIO0FBQ0EsV0FBVyw2Q0FBTztBQUNsQixHQUFHO0FBQ0g7QUFDQSxXQUFXLDZDQUFPO0FBQ2xCLEdBQUc7QUFDSDtBQUNBLFdBQVcsNkNBQU87QUFDbEIsR0FBRztBQUNIO0FBQ0EsV0FBVyw2Q0FBTztBQUNsQixHQUFHO0FBQ0g7QUFDQSxXQUFXLDZDQUFPO0FBQ2xCLEdBQUc7QUFDSDtBQUNBLFdBQVcsNENBQU07QUFDakIsR0FBRztBQUNIO0FBQ0EsV0FBVyw0Q0FBTTtBQUNqQixHQUFHO0FBQ0g7QUFDQSxXQUFXLDRDQUFNO0FBQ2pCLEdBQUc7QUFDSDtBQUNBLFdBQVcsNENBQU07QUFDakIsR0FBRztBQUNIO0FBQ0EsV0FBVyw0Q0FBTTtBQUNqQixHQUFHO0FBQ0g7QUFDQSxXQUFXLDRDQUFNO0FBQ2pCLEdBQUc7QUFDSDtBQUNBLFdBQVcsNENBQU07QUFDakIsR0FBRztBQUNIO0FBQ0EsV0FBVyw0Q0FBTTtBQUNqQixHQUFHO0FBQ0g7QUFDQSxXQUFXLDRDQUFNO0FBQ2pCLEdBQUc7QUFDSDtBQUNBLFdBQVcsNENBQU07QUFDakIsR0FBRztBQUNIO0FBQ0EsV0FBVyw0Q0FBTTtBQUNqQixHQUFHO0FBQ0g7QUFDQSxXQUFXLDRDQUFNO0FBQ2pCLEdBQUc7QUFDSDtBQUNBLFdBQVcsNENBQU07QUFDakIsR0FBRztBQUNIO0FBQ0EsV0FBVyw0Q0FBTTtBQUNqQixHQUFHO0FBQ0g7QUFDQSxXQUFXLDRDQUFNO0FBQ2pCLEdBQUc7QUFDSDtBQUNBLFdBQVcsNENBQU07QUFDakIsR0FBRztBQUNIO0FBQ0EsV0FBVyw0Q0FBTTtBQUNqQixHQUFHO0FBQ0g7QUFDQSxXQUFXLDRDQUFNO0FBQ2pCLEdBQUc7QUFDSDtBQUNBLFdBQVcsNENBQU07QUFDakIsR0FBRztBQUNIO0FBQ0EsV0FBVyw0Q0FBTTtBQUNqQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTLEtBQXFDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QUNGQyxjQUFjLEVBQUUsaUJBQWlCO1VBQ2pDLDhDQUE4QyxFQUFFO1lBQzVDQyxLQUFLLEVBQUUsS0FBSztZQUNaQyxlQUFlLEVBQUU7VUFDckIsQ0FBQztVQUNELDBEQUEwRCxFQUFFO1lBQ3hEQyxZQUFZLEVBQUUsQ0FBQztZQUNmRCxlQUFlLEVBQUUsU0FBUztZQUMxQkUsU0FBUyxFQUFFLEVBQUU7WUFDYkMsTUFBTSxFQUFFO1VBQ1osQ0FBQztVQUNELHNFQUFzRSxFQUFFO1lBQ3BFSCxlQUFlLEVBQUU7VUFDckIsQ0FBQztVQUNELHdFQUF3RSxFQUFFO1lBQ3RFQSxlQUFlLEVBQUU7VUFDckIsQ0FBQztVQUNELHNFQUFzRSxFQUFFO1lBQ3BFQSxlQUFlLEVBQUU7VUFDckIsQ0FBQztVQUNELDREQUE0RCxFQUFFO1lBQzFEQSxlQUFlLEVBQUU7VUFDckI7UUFDSjtNQUNKO0lBQ0o7RUFDSjtBQUNKLENBQUMsQ0FBQyxDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2FiaXNhYmkvLi9ub2RlX21vZHVsZXMvQG11aS9tYXRlcmlhbC9jb2xvcnMvYmx1ZS5qcyIsIndlYnBhY2s6Ly93YWJpc2FiaS8uL25vZGVfbW9kdWxlcy9AbXVpL21hdGVyaWFsL2NvbG9ycy9jb21tb24uanMiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvLi9ub2RlX21vZHVsZXMvQG11aS9tYXRlcmlhbC9jb2xvcnMvZ3JlZW4uanMiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvLi9ub2RlX21vZHVsZXMvQG11aS9tYXRlcmlhbC9jb2xvcnMvZ3JleS5qcyIsIndlYnBhY2s6Ly93YWJpc2FiaS8uL25vZGVfbW9kdWxlcy9AbXVpL21hdGVyaWFsL2NvbG9ycy9saWdodEJsdWUuanMiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvLi9ub2RlX21vZHVsZXMvQG11aS9tYXRlcmlhbC9jb2xvcnMvb3JhbmdlLmpzIiwid2VicGFjazovL3dhYmlzYWJpLy4vbm9kZV9tb2R1bGVzL0BtdWkvbWF0ZXJpYWwvY29sb3JzL3B1cnBsZS5qcyIsIndlYnBhY2s6Ly93YWJpc2FiaS8uL25vZGVfbW9kdWxlcy9AbXVpL21hdGVyaWFsL2NvbG9ycy9yZWQuanMiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvLi9ub2RlX21vZHVsZXMvQG11aS9tYXRlcmlhbC9zdHlsZXMvY3JlYXRlTWl4aW5zLmpzIiwid2VicGFjazovL3dhYmlzYWJpLy4vbm9kZV9tb2R1bGVzL0BtdWkvbWF0ZXJpYWwvc3R5bGVzL2NyZWF0ZVBhbGV0dGUuanMiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvLi9ub2RlX21vZHVsZXMvQG11aS9tYXRlcmlhbC9zdHlsZXMvY3JlYXRlVGhlbWUuanMiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvLi9ub2RlX21vZHVsZXMvQG11aS9tYXRlcmlhbC9zdHlsZXMvY3JlYXRlVHJhbnNpdGlvbnMuanMiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvLi9ub2RlX21vZHVsZXMvQG11aS9tYXRlcmlhbC9zdHlsZXMvY3JlYXRlVHlwb2dyYXBoeS5qcyIsIndlYnBhY2s6Ly93YWJpc2FiaS8uL25vZGVfbW9kdWxlcy9AbXVpL21hdGVyaWFsL3N0eWxlcy9zaGFkb3dzLmpzIiwid2VicGFjazovL3dhYmlzYWJpLy4vbm9kZV9tb2R1bGVzL0BtdWkvbWF0ZXJpYWwvc3R5bGVzL3pJbmRleC5qcyIsIndlYnBhY2s6Ly93YWJpc2FiaS8uL25vZGVfbW9kdWxlcy9AbXVpL3N5c3RlbS9lc20vYm9yZGVycy5qcyIsIndlYnBhY2s6Ly93YWJpc2FiaS8uL25vZGVfbW9kdWxlcy9AbXVpL3N5c3RlbS9lc20vYnJlYWtwb2ludHMuanMiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvLi9ub2RlX21vZHVsZXMvQG11aS9zeXN0ZW0vZXNtL2NvbG9yTWFuaXB1bGF0b3IuanMiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvLi9ub2RlX21vZHVsZXMvQG11aS9zeXN0ZW0vZXNtL2NvbXBvc2UuanMiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvLi9ub2RlX21vZHVsZXMvQG11aS9zeXN0ZW0vZXNtL2NyZWF0ZVRoZW1lL2NyZWF0ZUJyZWFrcG9pbnRzLmpzIiwid2VicGFjazovL3dhYmlzYWJpLy4vbm9kZV9tb2R1bGVzL0BtdWkvc3lzdGVtL2VzbS9jcmVhdGVUaGVtZS9jcmVhdGVTcGFjaW5nLmpzIiwid2VicGFjazovL3dhYmlzYWJpLy4vbm9kZV9tb2R1bGVzL0BtdWkvc3lzdGVtL2VzbS9jcmVhdGVUaGVtZS9jcmVhdGVUaGVtZS5qcyIsIndlYnBhY2s6Ly93YWJpc2FiaS8uL25vZGVfbW9kdWxlcy9AbXVpL3N5c3RlbS9lc20vY3JlYXRlVGhlbWUvc2hhcGUuanMiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvLi9ub2RlX21vZHVsZXMvQG11aS9zeXN0ZW0vZXNtL2Nzc0dyaWQuanMiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvLi9ub2RlX21vZHVsZXMvQG11aS9zeXN0ZW0vZXNtL21lbW9pemUuanMiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvLi9ub2RlX21vZHVsZXMvQG11aS9zeXN0ZW0vZXNtL21lcmdlLmpzIiwid2VicGFjazovL3dhYmlzYWJpLy4vbm9kZV9tb2R1bGVzL0BtdWkvc3lzdGVtL2VzbS9wYWxldHRlLmpzIiwid2VicGFjazovL3dhYmlzYWJpLy4vbm9kZV9tb2R1bGVzL0BtdWkvc3lzdGVtL2VzbS9yZXNwb25zaXZlUHJvcFR5cGUuanMiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvLi9ub2RlX21vZHVsZXMvQG11aS9zeXN0ZW0vZXNtL3NpemluZy5qcyIsIndlYnBhY2s6Ly93YWJpc2FiaS8uL25vZGVfbW9kdWxlcy9AbXVpL3N5c3RlbS9lc20vc3BhY2luZy5qcyIsIndlYnBhY2s6Ly93YWJpc2FiaS8uL25vZGVfbW9kdWxlcy9AbXVpL3N5c3RlbS9lc20vc3R5bGUuanMiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvLi9ub2RlX21vZHVsZXMvQG11aS9zeXN0ZW0vZXNtL3N0eWxlRnVuY3Rpb25TeC9kZWZhdWx0U3hDb25maWcuanMiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvLi9ub2RlX21vZHVsZXMvQG11aS9zeXN0ZW0vZXNtL3N0eWxlRnVuY3Rpb25TeC9zdHlsZUZ1bmN0aW9uU3guanMiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvLi9ub2RlX21vZHVsZXMvQG11aS91dGlscy9lc20vQ2xhc3NOYW1lR2VuZXJhdG9yL0NsYXNzTmFtZUdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly93YWJpc2FiaS8uL25vZGVfbW9kdWxlcy9AbXVpL3V0aWxzL2VzbS9jYXBpdGFsaXplL2NhcGl0YWxpemUuanMiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvLi9ub2RlX21vZHVsZXMvQG11aS91dGlscy9lc20vY2xhbXAvY2xhbXAuanMiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvLi9ub2RlX21vZHVsZXMvQG11aS91dGlscy9lc20vZGVlcG1lcmdlLmpzIiwid2VicGFjazovL3dhYmlzYWJpLy4vbm9kZV9tb2R1bGVzL0BtdWkvdXRpbHMvZXNtL2dlbmVyYXRlVXRpbGl0eUNsYXNzL2dlbmVyYXRlVXRpbGl0eUNsYXNzLmpzIiwid2VicGFjazovL3dhYmlzYWJpLy4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly93YWJpc2FiaS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwid2VicGFjazovL3dhYmlzYWJpLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvaGFzLmpzIiwid2VicGFjazovL3dhYmlzYWJpLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly93YWJpc2FiaS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyIsIndlYnBhY2s6Ly93YWJpc2FiaS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzLmpzIiwid2VicGFjazovL3dhYmlzYWJpLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UuanMiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3dhYmlzYWJpL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vd2FiaXNhYmkvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly93YWJpc2FiaS8uL3NyYy90aGVtZS5qc3giXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYmx1ZSA9IHtcbiAgNTA6ICcjZTNmMmZkJyxcbiAgMTAwOiAnI2JiZGVmYicsXG4gIDIwMDogJyM5MGNhZjknLFxuICAzMDA6ICcjNjRiNWY2JyxcbiAgNDAwOiAnIzQyYTVmNScsXG4gIDUwMDogJyMyMTk2ZjMnLFxuICA2MDA6ICcjMWU4OGU1JyxcbiAgNzAwOiAnIzE5NzZkMicsXG4gIDgwMDogJyMxNTY1YzAnLFxuICA5MDA6ICcjMGQ0N2ExJyxcbiAgQTEwMDogJyM4MmIxZmYnLFxuICBBMjAwOiAnIzQ0OGFmZicsXG4gIEE0MDA6ICcjMjk3OWZmJyxcbiAgQTcwMDogJyMyOTYyZmYnXG59O1xuZXhwb3J0IGRlZmF1bHQgYmx1ZTsiLCJjb25zdCBjb21tb24gPSB7XG4gIGJsYWNrOiAnIzAwMCcsXG4gIHdoaXRlOiAnI2ZmZidcbn07XG5leHBvcnQgZGVmYXVsdCBjb21tb247IiwiY29uc3QgZ3JlZW4gPSB7XG4gIDUwOiAnI2U4ZjVlOScsXG4gIDEwMDogJyNjOGU2YzknLFxuICAyMDA6ICcjYTVkNmE3JyxcbiAgMzAwOiAnIzgxYzc4NCcsXG4gIDQwMDogJyM2NmJiNmEnLFxuICA1MDA6ICcjNGNhZjUwJyxcbiAgNjAwOiAnIzQzYTA0NycsXG4gIDcwMDogJyMzODhlM2MnLFxuICA4MDA6ICcjMmU3ZDMyJyxcbiAgOTAwOiAnIzFiNWUyMCcsXG4gIEExMDA6ICcjYjlmNmNhJyxcbiAgQTIwMDogJyM2OWYwYWUnLFxuICBBNDAwOiAnIzAwZTY3NicsXG4gIEE3MDA6ICcjMDBjODUzJ1xufTtcbmV4cG9ydCBkZWZhdWx0IGdyZWVuOyIsImNvbnN0IGdyZXkgPSB7XG4gIDUwOiAnI2ZhZmFmYScsXG4gIDEwMDogJyNmNWY1ZjUnLFxuICAyMDA6ICcjZWVlZWVlJyxcbiAgMzAwOiAnI2UwZTBlMCcsXG4gIDQwMDogJyNiZGJkYmQnLFxuICA1MDA6ICcjOWU5ZTllJyxcbiAgNjAwOiAnIzc1NzU3NScsXG4gIDcwMDogJyM2MTYxNjEnLFxuICA4MDA6ICcjNDI0MjQyJyxcbiAgOTAwOiAnIzIxMjEyMScsXG4gIEExMDA6ICcjZjVmNWY1JyxcbiAgQTIwMDogJyNlZWVlZWUnLFxuICBBNDAwOiAnI2JkYmRiZCcsXG4gIEE3MDA6ICcjNjE2MTYxJ1xufTtcbmV4cG9ydCBkZWZhdWx0IGdyZXk7IiwiY29uc3QgbGlnaHRCbHVlID0ge1xuICA1MDogJyNlMWY1ZmUnLFxuICAxMDA6ICcjYjNlNWZjJyxcbiAgMjAwOiAnIzgxZDRmYScsXG4gIDMwMDogJyM0ZmMzZjcnLFxuICA0MDA6ICcjMjliNmY2JyxcbiAgNTAwOiAnIzAzYTlmNCcsXG4gIDYwMDogJyMwMzliZTUnLFxuICA3MDA6ICcjMDI4OGQxJyxcbiAgODAwOiAnIzAyNzdiZCcsXG4gIDkwMDogJyMwMTU3OWInLFxuICBBMTAwOiAnIzgwZDhmZicsXG4gIEEyMDA6ICcjNDBjNGZmJyxcbiAgQTQwMDogJyMwMGIwZmYnLFxuICBBNzAwOiAnIzAwOTFlYSdcbn07XG5leHBvcnQgZGVmYXVsdCBsaWdodEJsdWU7IiwiY29uc3Qgb3JhbmdlID0ge1xuICA1MDogJyNmZmYzZTAnLFxuICAxMDA6ICcjZmZlMGIyJyxcbiAgMjAwOiAnI2ZmY2M4MCcsXG4gIDMwMDogJyNmZmI3NGQnLFxuICA0MDA6ICcjZmZhNzI2JyxcbiAgNTAwOiAnI2ZmOTgwMCcsXG4gIDYwMDogJyNmYjhjMDAnLFxuICA3MDA6ICcjZjU3YzAwJyxcbiAgODAwOiAnI2VmNmMwMCcsXG4gIDkwMDogJyNlNjUxMDAnLFxuICBBMTAwOiAnI2ZmZDE4MCcsXG4gIEEyMDA6ICcjZmZhYjQwJyxcbiAgQTQwMDogJyNmZjkxMDAnLFxuICBBNzAwOiAnI2ZmNmQwMCdcbn07XG5leHBvcnQgZGVmYXVsdCBvcmFuZ2U7IiwiY29uc3QgcHVycGxlID0ge1xuICA1MDogJyNmM2U1ZjUnLFxuICAxMDA6ICcjZTFiZWU3JyxcbiAgMjAwOiAnI2NlOTNkOCcsXG4gIDMwMDogJyNiYTY4YzgnLFxuICA0MDA6ICcjYWI0N2JjJyxcbiAgNTAwOiAnIzljMjdiMCcsXG4gIDYwMDogJyM4ZTI0YWEnLFxuICA3MDA6ICcjN2IxZmEyJyxcbiAgODAwOiAnIzZhMWI5YScsXG4gIDkwMDogJyM0YTE0OGMnLFxuICBBMTAwOiAnI2VhODBmYycsXG4gIEEyMDA6ICcjZTA0MGZiJyxcbiAgQTQwMDogJyNkNTAwZjknLFxuICBBNzAwOiAnI2FhMDBmZidcbn07XG5leHBvcnQgZGVmYXVsdCBwdXJwbGU7IiwiY29uc3QgcmVkID0ge1xuICA1MDogJyNmZmViZWUnLFxuICAxMDA6ICcjZmZjZGQyJyxcbiAgMjAwOiAnI2VmOWE5YScsXG4gIDMwMDogJyNlNTczNzMnLFxuICA0MDA6ICcjZWY1MzUwJyxcbiAgNTAwOiAnI2Y0NDMzNicsXG4gIDYwMDogJyNlNTM5MzUnLFxuICA3MDA6ICcjZDMyZjJmJyxcbiAgODAwOiAnI2M2MjgyOCcsXG4gIDkwMDogJyNiNzFjMWMnLFxuICBBMTAwOiAnI2ZmOGE4MCcsXG4gIEEyMDA6ICcjZmY1MjUyJyxcbiAgQTQwMDogJyNmZjE3NDQnLFxuICBBNzAwOiAnI2Q1MDAwMCdcbn07XG5leHBvcnQgZGVmYXVsdCByZWQ7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVNaXhpbnMoYnJlYWtwb2ludHMsIG1peGlucykge1xuICByZXR1cm4gX2V4dGVuZHMoe1xuICAgIHRvb2xiYXI6IHtcbiAgICAgIG1pbkhlaWdodDogNTYsXG4gICAgICBbYnJlYWtwb2ludHMudXAoJ3hzJyldOiB7XG4gICAgICAgICdAbWVkaWEgKG9yaWVudGF0aW9uOiBsYW5kc2NhcGUpJzoge1xuICAgICAgICAgIG1pbkhlaWdodDogNDhcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFticmVha3BvaW50cy51cCgnc20nKV06IHtcbiAgICAgICAgbWluSGVpZ2h0OiA2NFxuICAgICAgfVxuICAgIH1cbiAgfSwgbWl4aW5zKTtcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZVwiO1xuaW1wb3J0IF9mb3JtYXRNdWlFcnJvck1lc3NhZ2UgZnJvbSBcIkBtdWkvdXRpbHMvZm9ybWF0TXVpRXJyb3JNZXNzYWdlXCI7XG5jb25zdCBfZXhjbHVkZWQgPSBbXCJtb2RlXCIsIFwiY29udHJhc3RUaHJlc2hvbGRcIiwgXCJ0b25hbE9mZnNldFwiXTtcbmltcG9ydCB7IGRlZXBtZXJnZSB9IGZyb20gJ0BtdWkvdXRpbHMnO1xuaW1wb3J0IHsgZGFya2VuLCBnZXRDb250cmFzdFJhdGlvLCBsaWdodGVuIH0gZnJvbSAnQG11aS9zeXN0ZW0nO1xuaW1wb3J0IGNvbW1vbiBmcm9tICcuLi9jb2xvcnMvY29tbW9uJztcbmltcG9ydCBncmV5IGZyb20gJy4uL2NvbG9ycy9ncmV5JztcbmltcG9ydCBwdXJwbGUgZnJvbSAnLi4vY29sb3JzL3B1cnBsZSc7XG5pbXBvcnQgcmVkIGZyb20gJy4uL2NvbG9ycy9yZWQnO1xuaW1wb3J0IG9yYW5nZSBmcm9tICcuLi9jb2xvcnMvb3JhbmdlJztcbmltcG9ydCBibHVlIGZyb20gJy4uL2NvbG9ycy9ibHVlJztcbmltcG9ydCBsaWdodEJsdWUgZnJvbSAnLi4vY29sb3JzL2xpZ2h0Qmx1ZSc7XG5pbXBvcnQgZ3JlZW4gZnJvbSAnLi4vY29sb3JzL2dyZWVuJztcbmV4cG9ydCBjb25zdCBsaWdodCA9IHtcbiAgLy8gVGhlIGNvbG9ycyB1c2VkIHRvIHN0eWxlIHRoZSB0ZXh0LlxuICB0ZXh0OiB7XG4gICAgLy8gVGhlIG1vc3QgaW1wb3J0YW50IHRleHQuXG4gICAgcHJpbWFyeTogJ3JnYmEoMCwgMCwgMCwgMC44NyknLFxuICAgIC8vIFNlY29uZGFyeSB0ZXh0LlxuICAgIHNlY29uZGFyeTogJ3JnYmEoMCwgMCwgMCwgMC42KScsXG4gICAgLy8gRGlzYWJsZWQgdGV4dCBoYXZlIGV2ZW4gbG93ZXIgdmlzdWFsIHByb21pbmVuY2UuXG4gICAgZGlzYWJsZWQ6ICdyZ2JhKDAsIDAsIDAsIDAuMzgpJ1xuICB9LFxuICAvLyBUaGUgY29sb3IgdXNlZCB0byBkaXZpZGUgZGlmZmVyZW50IGVsZW1lbnRzLlxuICBkaXZpZGVyOiAncmdiYSgwLCAwLCAwLCAwLjEyKScsXG4gIC8vIFRoZSBiYWNrZ3JvdW5kIGNvbG9ycyB1c2VkIHRvIHN0eWxlIHRoZSBzdXJmYWNlcy5cbiAgLy8gQ29uc2lzdGVuY3kgYmV0d2VlbiB0aGVzZSB2YWx1ZXMgaXMgaW1wb3J0YW50LlxuICBiYWNrZ3JvdW5kOiB7XG4gICAgcGFwZXI6IGNvbW1vbi53aGl0ZSxcbiAgICBkZWZhdWx0OiBjb21tb24ud2hpdGVcbiAgfSxcbiAgLy8gVGhlIGNvbG9ycyB1c2VkIHRvIHN0eWxlIHRoZSBhY3Rpb24gZWxlbWVudHMuXG4gIGFjdGlvbjoge1xuICAgIC8vIFRoZSBjb2xvciBvZiBhbiBhY3RpdmUgYWN0aW9uIGxpa2UgYW4gaWNvbiBidXR0b24uXG4gICAgYWN0aXZlOiAncmdiYSgwLCAwLCAwLCAwLjU0KScsXG4gICAgLy8gVGhlIGNvbG9yIG9mIGFuIGhvdmVyZWQgYWN0aW9uLlxuICAgIGhvdmVyOiAncmdiYSgwLCAwLCAwLCAwLjA0KScsXG4gICAgaG92ZXJPcGFjaXR5OiAwLjA0LFxuICAgIC8vIFRoZSBjb2xvciBvZiBhIHNlbGVjdGVkIGFjdGlvbi5cbiAgICBzZWxlY3RlZDogJ3JnYmEoMCwgMCwgMCwgMC4wOCknLFxuICAgIHNlbGVjdGVkT3BhY2l0eTogMC4wOCxcbiAgICAvLyBUaGUgY29sb3Igb2YgYSBkaXNhYmxlZCBhY3Rpb24uXG4gICAgZGlzYWJsZWQ6ICdyZ2JhKDAsIDAsIDAsIDAuMjYpJyxcbiAgICAvLyBUaGUgYmFja2dyb3VuZCBjb2xvciBvZiBhIGRpc2FibGVkIGFjdGlvbi5cbiAgICBkaXNhYmxlZEJhY2tncm91bmQ6ICdyZ2JhKDAsIDAsIDAsIDAuMTIpJyxcbiAgICBkaXNhYmxlZE9wYWNpdHk6IDAuMzgsXG4gICAgZm9jdXM6ICdyZ2JhKDAsIDAsIDAsIDAuMTIpJyxcbiAgICBmb2N1c09wYWNpdHk6IDAuMTIsXG4gICAgYWN0aXZhdGVkT3BhY2l0eTogMC4xMlxuICB9XG59O1xuZXhwb3J0IGNvbnN0IGRhcmsgPSB7XG4gIHRleHQ6IHtcbiAgICBwcmltYXJ5OiBjb21tb24ud2hpdGUsXG4gICAgc2Vjb25kYXJ5OiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpJyxcbiAgICBkaXNhYmxlZDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC41KScsXG4gICAgaWNvbjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSdcbiAgfSxcbiAgZGl2aWRlcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4xMiknLFxuICBiYWNrZ3JvdW5kOiB7XG4gICAgcGFwZXI6ICcjMTIxMjEyJyxcbiAgICBkZWZhdWx0OiAnIzEyMTIxMidcbiAgfSxcbiAgYWN0aW9uOiB7XG4gICAgYWN0aXZlOiBjb21tb24ud2hpdGUsXG4gICAgaG92ZXI6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMDgpJyxcbiAgICBob3Zlck9wYWNpdHk6IDAuMDgsXG4gICAgc2VsZWN0ZWQ6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTYpJyxcbiAgICBzZWxlY3RlZE9wYWNpdHk6IDAuMTYsXG4gICAgZGlzYWJsZWQ6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyknLFxuICAgIGRpc2FibGVkQmFja2dyb3VuZDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4xMiknLFxuICAgIGRpc2FibGVkT3BhY2l0eTogMC4zOCxcbiAgICBmb2N1czogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4xMiknLFxuICAgIGZvY3VzT3BhY2l0eTogMC4xMixcbiAgICBhY3RpdmF0ZWRPcGFjaXR5OiAwLjI0XG4gIH1cbn07XG5mdW5jdGlvbiBhZGRMaWdodE9yRGFyayhpbnRlbnQsIGRpcmVjdGlvbiwgc2hhZGUsIHRvbmFsT2Zmc2V0KSB7XG4gIGNvbnN0IHRvbmFsT2Zmc2V0TGlnaHQgPSB0b25hbE9mZnNldC5saWdodCB8fCB0b25hbE9mZnNldDtcbiAgY29uc3QgdG9uYWxPZmZzZXREYXJrID0gdG9uYWxPZmZzZXQuZGFyayB8fCB0b25hbE9mZnNldCAqIDEuNTtcbiAgaWYgKCFpbnRlbnRbZGlyZWN0aW9uXSkge1xuICAgIGlmIChpbnRlbnQuaGFzT3duUHJvcGVydHkoc2hhZGUpKSB7XG4gICAgICBpbnRlbnRbZGlyZWN0aW9uXSA9IGludGVudFtzaGFkZV07XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdsaWdodCcpIHtcbiAgICAgIGludGVudC5saWdodCA9IGxpZ2h0ZW4oaW50ZW50Lm1haW4sIHRvbmFsT2Zmc2V0TGlnaHQpO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnZGFyaycpIHtcbiAgICAgIGludGVudC5kYXJrID0gZGFya2VuKGludGVudC5tYWluLCB0b25hbE9mZnNldERhcmspO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdFByaW1hcnkobW9kZSA9ICdsaWdodCcpIHtcbiAgaWYgKG1vZGUgPT09ICdkYXJrJykge1xuICAgIHJldHVybiB7XG4gICAgICBtYWluOiBibHVlWzIwMF0sXG4gICAgICBsaWdodDogYmx1ZVs1MF0sXG4gICAgICBkYXJrOiBibHVlWzQwMF1cbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbWFpbjogYmx1ZVs3MDBdLFxuICAgIGxpZ2h0OiBibHVlWzQwMF0sXG4gICAgZGFyazogYmx1ZVs4MDBdXG4gIH07XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0U2Vjb25kYXJ5KG1vZGUgPSAnbGlnaHQnKSB7XG4gIGlmIChtb2RlID09PSAnZGFyaycpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWFpbjogcHVycGxlWzIwMF0sXG4gICAgICBsaWdodDogcHVycGxlWzUwXSxcbiAgICAgIGRhcms6IHB1cnBsZVs0MDBdXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG1haW46IHB1cnBsZVs1MDBdLFxuICAgIGxpZ2h0OiBwdXJwbGVbMzAwXSxcbiAgICBkYXJrOiBwdXJwbGVbNzAwXVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdEVycm9yKG1vZGUgPSAnbGlnaHQnKSB7XG4gIGlmIChtb2RlID09PSAnZGFyaycpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWFpbjogcmVkWzUwMF0sXG4gICAgICBsaWdodDogcmVkWzMwMF0sXG4gICAgICBkYXJrOiByZWRbNzAwXVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtYWluOiByZWRbNzAwXSxcbiAgICBsaWdodDogcmVkWzQwMF0sXG4gICAgZGFyazogcmVkWzgwMF1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRJbmZvKG1vZGUgPSAnbGlnaHQnKSB7XG4gIGlmIChtb2RlID09PSAnZGFyaycpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWFpbjogbGlnaHRCbHVlWzQwMF0sXG4gICAgICBsaWdodDogbGlnaHRCbHVlWzMwMF0sXG4gICAgICBkYXJrOiBsaWdodEJsdWVbNzAwXVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtYWluOiBsaWdodEJsdWVbNzAwXSxcbiAgICBsaWdodDogbGlnaHRCbHVlWzUwMF0sXG4gICAgZGFyazogbGlnaHRCbHVlWzkwMF1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRTdWNjZXNzKG1vZGUgPSAnbGlnaHQnKSB7XG4gIGlmIChtb2RlID09PSAnZGFyaycpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWFpbjogZ3JlZW5bNDAwXSxcbiAgICAgIGxpZ2h0OiBncmVlblszMDBdLFxuICAgICAgZGFyazogZ3JlZW5bNzAwXVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtYWluOiBncmVlbls4MDBdLFxuICAgIGxpZ2h0OiBncmVlbls1MDBdLFxuICAgIGRhcms6IGdyZWVuWzkwMF1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRXYXJuaW5nKG1vZGUgPSAnbGlnaHQnKSB7XG4gIGlmIChtb2RlID09PSAnZGFyaycpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWFpbjogb3JhbmdlWzQwMF0sXG4gICAgICBsaWdodDogb3JhbmdlWzMwMF0sXG4gICAgICBkYXJrOiBvcmFuZ2VbNzAwXVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtYWluOiAnI2VkNmMwMicsXG4gICAgLy8gY2xvc2VzdCB0byBvcmFuZ2VbODAwXSB0aGF0IHBhc3MgMzoxLlxuICAgIGxpZ2h0OiBvcmFuZ2VbNTAwXSxcbiAgICBkYXJrOiBvcmFuZ2VbOTAwXVxuICB9O1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlUGFsZXR0ZShwYWxldHRlKSB7XG4gIGNvbnN0IHtcbiAgICAgIG1vZGUgPSAnbGlnaHQnLFxuICAgICAgY29udHJhc3RUaHJlc2hvbGQgPSAzLFxuICAgICAgdG9uYWxPZmZzZXQgPSAwLjJcbiAgICB9ID0gcGFsZXR0ZSxcbiAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHBhbGV0dGUsIF9leGNsdWRlZCk7XG4gIGNvbnN0IHByaW1hcnkgPSBwYWxldHRlLnByaW1hcnkgfHwgZ2V0RGVmYXVsdFByaW1hcnkobW9kZSk7XG4gIGNvbnN0IHNlY29uZGFyeSA9IHBhbGV0dGUuc2Vjb25kYXJ5IHx8IGdldERlZmF1bHRTZWNvbmRhcnkobW9kZSk7XG4gIGNvbnN0IGVycm9yID0gcGFsZXR0ZS5lcnJvciB8fCBnZXREZWZhdWx0RXJyb3IobW9kZSk7XG4gIGNvbnN0IGluZm8gPSBwYWxldHRlLmluZm8gfHwgZ2V0RGVmYXVsdEluZm8obW9kZSk7XG4gIGNvbnN0IHN1Y2Nlc3MgPSBwYWxldHRlLnN1Y2Nlc3MgfHwgZ2V0RGVmYXVsdFN1Y2Nlc3MobW9kZSk7XG4gIGNvbnN0IHdhcm5pbmcgPSBwYWxldHRlLndhcm5pbmcgfHwgZ2V0RGVmYXVsdFdhcm5pbmcobW9kZSk7XG5cbiAgLy8gVXNlIHRoZSBzYW1lIGxvZ2ljIGFzXG4gIC8vIEJvb3RzdHJhcDogaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvMWQ2ZTM3MTBkZDQ0N2RlMWEyMDBmMjllOGZhNTIxZjhhMDkwOGY3MC9zY3NzL19mdW5jdGlvbnMuc2NzcyNMNTlcbiAgLy8gYW5kIG1hdGVyaWFsLWNvbXBvbmVudHMtd2ViIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvYWM0NmI4ODYzYzRkYWI5ZmMyMmM0YzY2MmRjNmJkMWI2NWRkNjUyZi9wYWNrYWdlcy9tZGMtdGhlbWUvX2Z1bmN0aW9ucy5zY3NzI0w1NFxuICBmdW5jdGlvbiBnZXRDb250cmFzdFRleHQoYmFja2dyb3VuZCkge1xuICAgIGNvbnN0IGNvbnRyYXN0VGV4dCA9IGdldENvbnRyYXN0UmF0aW8oYmFja2dyb3VuZCwgZGFyay50ZXh0LnByaW1hcnkpID49IGNvbnRyYXN0VGhyZXNob2xkID8gZGFyay50ZXh0LnByaW1hcnkgOiBsaWdodC50ZXh0LnByaW1hcnk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnN0IGNvbnRyYXN0ID0gZ2V0Q29udHJhc3RSYXRpbyhiYWNrZ3JvdW5kLCBjb250cmFzdFRleHQpO1xuICAgICAgaWYgKGNvbnRyYXN0IDwgMykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFtgTVVJOiBUaGUgY29udHJhc3QgcmF0aW8gb2YgJHtjb250cmFzdH06MSBmb3IgJHtjb250cmFzdFRleHR9IG9uICR7YmFja2dyb3VuZH1gLCAnZmFsbHMgYmVsb3cgdGhlIFdDQUcgcmVjb21tZW5kZWQgYWJzb2x1dGUgbWluaW11bSBjb250cmFzdCByYXRpbyBvZiAzOjEuJywgJ2h0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy1XQ0FHMjAtMjAwODEyMTEvI3Zpc3VhbC1hdWRpby1jb250cmFzdC1jb250cmFzdCddLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyYXN0VGV4dDtcbiAgfVxuICBjb25zdCBhdWdtZW50Q29sb3IgPSAoe1xuICAgIGNvbG9yLFxuICAgIG5hbWUsXG4gICAgbWFpblNoYWRlID0gNTAwLFxuICAgIGxpZ2h0U2hhZGUgPSAzMDAsXG4gICAgZGFya1NoYWRlID0gNzAwXG4gIH0pID0+IHtcbiAgICBjb2xvciA9IF9leHRlbmRzKHt9LCBjb2xvcik7XG4gICAgaWYgKCFjb2xvci5tYWluICYmIGNvbG9yW21haW5TaGFkZV0pIHtcbiAgICAgIGNvbG9yLm1haW4gPSBjb2xvclttYWluU2hhZGVdO1xuICAgIH1cbiAgICBpZiAoIWNvbG9yLmhhc093blByb3BlcnR5KCdtYWluJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBgTVVJOiBUaGUgY29sb3Ike25hbWUgPyBgICgke25hbWV9KWAgOiAnJ30gcHJvdmlkZWQgdG8gYXVnbWVudENvbG9yKGNvbG9yKSBpcyBpbnZhbGlkLlxuVGhlIGNvbG9yIG9iamVjdCBuZWVkcyB0byBoYXZlIGEgXFxgbWFpblxcYCBwcm9wZXJ0eSBvciBhIFxcYCR7bWFpblNoYWRlfVxcYCBwcm9wZXJ0eS5gIDogX2Zvcm1hdE11aUVycm9yTWVzc2FnZSgxMSwgbmFtZSA/IGAgKCR7bmFtZX0pYCA6ICcnLCBtYWluU2hhZGUpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb2xvci5tYWluICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGBNVUk6IFRoZSBjb2xvciR7bmFtZSA/IGAgKCR7bmFtZX0pYCA6ICcnfSBwcm92aWRlZCB0byBhdWdtZW50Q29sb3IoY29sb3IpIGlzIGludmFsaWQuXG5cXGBjb2xvci5tYWluXFxgIHNob3VsZCBiZSBhIHN0cmluZywgYnV0IFxcYCR7SlNPTi5zdHJpbmdpZnkoY29sb3IubWFpbil9XFxgIHdhcyBwcm92aWRlZCBpbnN0ZWFkLlxuXG5EaWQgeW91IGludGVuZCB0byB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmcgYXBwcm9hY2hlcz9cblxuaW1wb3J0IHsgZ3JlZW4gfSBmcm9tIFwiQG11aS9tYXRlcmlhbC9jb2xvcnNcIjtcblxuY29uc3QgdGhlbWUxID0gY3JlYXRlVGhlbWUoeyBwYWxldHRlOiB7XG4gIHByaW1hcnk6IGdyZWVuLFxufSB9KTtcblxuY29uc3QgdGhlbWUyID0gY3JlYXRlVGhlbWUoeyBwYWxldHRlOiB7XG4gIHByaW1hcnk6IHsgbWFpbjogZ3JlZW5bNTAwXSB9LFxufSB9KTtgIDogX2Zvcm1hdE11aUVycm9yTWVzc2FnZSgxMiwgbmFtZSA/IGAgKCR7bmFtZX0pYCA6ICcnLCBKU09OLnN0cmluZ2lmeShjb2xvci5tYWluKSkpO1xuICAgIH1cbiAgICBhZGRMaWdodE9yRGFyayhjb2xvciwgJ2xpZ2h0JywgbGlnaHRTaGFkZSwgdG9uYWxPZmZzZXQpO1xuICAgIGFkZExpZ2h0T3JEYXJrKGNvbG9yLCAnZGFyaycsIGRhcmtTaGFkZSwgdG9uYWxPZmZzZXQpO1xuICAgIGlmICghY29sb3IuY29udHJhc3RUZXh0KSB7XG4gICAgICBjb2xvci5jb250cmFzdFRleHQgPSBnZXRDb250cmFzdFRleHQoY29sb3IubWFpbik7XG4gICAgfVxuICAgIHJldHVybiBjb2xvcjtcbiAgfTtcbiAgY29uc3QgbW9kZXMgPSB7XG4gICAgZGFyayxcbiAgICBsaWdodFxuICB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICghbW9kZXNbbW9kZV0pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYE1VSTogVGhlIHBhbGV0dGUgbW9kZSBcXGAke21vZGV9XFxgIGlzIG5vdCBzdXBwb3J0ZWQuYCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHBhbGV0dGVPdXRwdXQgPSBkZWVwbWVyZ2UoX2V4dGVuZHMoe1xuICAgIC8vIEEgY29sbGVjdGlvbiBvZiBjb21tb24gY29sb3JzLlxuICAgIGNvbW1vbjogX2V4dGVuZHMoe30sIGNvbW1vbiksXG4gICAgLy8gcHJldmVudCBtdXRhYmxlIG9iamVjdC5cbiAgICAvLyBUaGUgcGFsZXR0ZSBtb2RlLCBjYW4gYmUgbGlnaHQgb3IgZGFyay5cbiAgICBtb2RlLFxuICAgIC8vIFRoZSBjb2xvcnMgdXNlZCB0byByZXByZXNlbnQgcHJpbWFyeSBpbnRlcmZhY2UgZWxlbWVudHMgZm9yIGEgdXNlci5cbiAgICBwcmltYXJ5OiBhdWdtZW50Q29sb3Ioe1xuICAgICAgY29sb3I6IHByaW1hcnksXG4gICAgICBuYW1lOiAncHJpbWFyeSdcbiAgICB9KSxcbiAgICAvLyBUaGUgY29sb3JzIHVzZWQgdG8gcmVwcmVzZW50IHNlY29uZGFyeSBpbnRlcmZhY2UgZWxlbWVudHMgZm9yIGEgdXNlci5cbiAgICBzZWNvbmRhcnk6IGF1Z21lbnRDb2xvcih7XG4gICAgICBjb2xvcjogc2Vjb25kYXJ5LFxuICAgICAgbmFtZTogJ3NlY29uZGFyeScsXG4gICAgICBtYWluU2hhZGU6ICdBNDAwJyxcbiAgICAgIGxpZ2h0U2hhZGU6ICdBMjAwJyxcbiAgICAgIGRhcmtTaGFkZTogJ0E3MDAnXG4gICAgfSksXG4gICAgLy8gVGhlIGNvbG9ycyB1c2VkIHRvIHJlcHJlc2VudCBpbnRlcmZhY2UgZWxlbWVudHMgdGhhdCB0aGUgdXNlciBzaG91bGQgYmUgbWFkZSBhd2FyZSBvZi5cbiAgICBlcnJvcjogYXVnbWVudENvbG9yKHtcbiAgICAgIGNvbG9yOiBlcnJvcixcbiAgICAgIG5hbWU6ICdlcnJvcidcbiAgICB9KSxcbiAgICAvLyBUaGUgY29sb3JzIHVzZWQgdG8gcmVwcmVzZW50IHBvdGVudGlhbGx5IGRhbmdlcm91cyBhY3Rpb25zIG9yIGltcG9ydGFudCBtZXNzYWdlcy5cbiAgICB3YXJuaW5nOiBhdWdtZW50Q29sb3Ioe1xuICAgICAgY29sb3I6IHdhcm5pbmcsXG4gICAgICBuYW1lOiAnd2FybmluZydcbiAgICB9KSxcbiAgICAvLyBUaGUgY29sb3JzIHVzZWQgdG8gcHJlc2VudCBpbmZvcm1hdGlvbiB0byB0aGUgdXNlciB0aGF0IGlzIG5ldXRyYWwgYW5kIG5vdCBuZWNlc3NhcmlseSBpbXBvcnRhbnQuXG4gICAgaW5mbzogYXVnbWVudENvbG9yKHtcbiAgICAgIGNvbG9yOiBpbmZvLFxuICAgICAgbmFtZTogJ2luZm8nXG4gICAgfSksXG4gICAgLy8gVGhlIGNvbG9ycyB1c2VkIHRvIGluZGljYXRlIHRoZSBzdWNjZXNzZnVsIGNvbXBsZXRpb24gb2YgYW4gYWN0aW9uIHRoYXQgdXNlciB0cmlnZ2VyZWQuXG4gICAgc3VjY2VzczogYXVnbWVudENvbG9yKHtcbiAgICAgIGNvbG9yOiBzdWNjZXNzLFxuICAgICAgbmFtZTogJ3N1Y2Nlc3MnXG4gICAgfSksXG4gICAgLy8gVGhlIGdyZXkgY29sb3JzLlxuICAgIGdyZXksXG4gICAgLy8gVXNlZCBieSBgZ2V0Q29udHJhc3RUZXh0KClgIHRvIG1heGltaXplIHRoZSBjb250cmFzdCBiZXR3ZWVuXG4gICAgLy8gdGhlIGJhY2tncm91bmQgYW5kIHRoZSB0ZXh0LlxuICAgIGNvbnRyYXN0VGhyZXNob2xkLFxuICAgIC8vIFRha2VzIGEgYmFja2dyb3VuZCBjb2xvciBhbmQgcmV0dXJucyB0aGUgdGV4dCBjb2xvciB0aGF0IG1heGltaXplcyB0aGUgY29udHJhc3QuXG4gICAgZ2V0Q29udHJhc3RUZXh0LFxuICAgIC8vIEdlbmVyYXRlIGEgcmljaCBjb2xvciBvYmplY3QuXG4gICAgYXVnbWVudENvbG9yLFxuICAgIC8vIFVzZWQgYnkgdGhlIGZ1bmN0aW9ucyBiZWxvdyB0byBzaGlmdCBhIGNvbG9yJ3MgbHVtaW5hbmNlIGJ5IGFwcHJveGltYXRlbHlcbiAgICAvLyB0d28gaW5kZXhlcyB3aXRoaW4gaXRzIHRvbmFsIHBhbGV0dGUuXG4gICAgLy8gRS5nLiwgc2hpZnQgZnJvbSBSZWQgNTAwIHRvIFJlZCAzMDAgb3IgUmVkIDcwMC5cbiAgICB0b25hbE9mZnNldFxuICB9LCBtb2Rlc1ttb2RlXSksIG90aGVyKTtcbiAgcmV0dXJuIHBhbGV0dGVPdXRwdXQ7XG59IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcbmltcG9ydCBfZm9ybWF0TXVpRXJyb3JNZXNzYWdlIGZyb20gXCJAbXVpL3V0aWxzL2Zvcm1hdE11aUVycm9yTWVzc2FnZVwiO1xuY29uc3QgX2V4Y2x1ZGVkID0gW1wiYnJlYWtwb2ludHNcIiwgXCJtaXhpbnNcIiwgXCJzcGFjaW5nXCIsIFwicGFsZXR0ZVwiLCBcInRyYW5zaXRpb25zXCIsIFwidHlwb2dyYXBoeVwiLCBcInNoYXBlXCJdO1xuaW1wb3J0IHsgZGVlcG1lcmdlIH0gZnJvbSAnQG11aS91dGlscyc7XG5pbXBvcnQgeyBjcmVhdGVUaGVtZSBhcyBzeXN0ZW1DcmVhdGVUaGVtZSwgdW5zdGFibGVfZGVmYXVsdFN4Q29uZmlnIGFzIGRlZmF1bHRTeENvbmZpZywgdW5zdGFibGVfc3R5bGVGdW5jdGlvblN4IGFzIHN0eWxlRnVuY3Rpb25TeCB9IGZyb20gJ0BtdWkvc3lzdGVtJztcbmltcG9ydCBnZW5lcmF0ZVV0aWxpdHlDbGFzcyBmcm9tICdAbXVpL3V0aWxzL2dlbmVyYXRlVXRpbGl0eUNsYXNzJztcbmltcG9ydCBjcmVhdGVNaXhpbnMgZnJvbSAnLi9jcmVhdGVNaXhpbnMnO1xuaW1wb3J0IGNyZWF0ZVBhbGV0dGUgZnJvbSAnLi9jcmVhdGVQYWxldHRlJztcbmltcG9ydCBjcmVhdGVUeXBvZ3JhcGh5IGZyb20gJy4vY3JlYXRlVHlwb2dyYXBoeSc7XG5pbXBvcnQgc2hhZG93cyBmcm9tICcuL3NoYWRvd3MnO1xuaW1wb3J0IGNyZWF0ZVRyYW5zaXRpb25zIGZyb20gJy4vY3JlYXRlVHJhbnNpdGlvbnMnO1xuaW1wb3J0IHpJbmRleCBmcm9tICcuL3pJbmRleCc7XG5mdW5jdGlvbiBjcmVhdGVUaGVtZShvcHRpb25zID0ge30sIC4uLmFyZ3MpIHtcbiAgY29uc3Qge1xuICAgICAgbWl4aW5zOiBtaXhpbnNJbnB1dCA9IHt9LFxuICAgICAgcGFsZXR0ZTogcGFsZXR0ZUlucHV0ID0ge30sXG4gICAgICB0cmFuc2l0aW9uczogdHJhbnNpdGlvbnNJbnB1dCA9IHt9LFxuICAgICAgdHlwb2dyYXBoeTogdHlwb2dyYXBoeUlucHV0ID0ge31cbiAgICB9ID0gb3B0aW9ucyxcbiAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKG9wdGlvbnMsIF9leGNsdWRlZCk7XG4gIGlmIChvcHRpb25zLnZhcnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gYE1VSTogXFxgdmFyc1xcYCBpcyBhIHByaXZhdGUgZmllbGQgdXNlZCBmb3IgQ1NTIHZhcmlhYmxlcyBzdXBwb3J0LlxuUGxlYXNlIHVzZSBhbm90aGVyIG5hbWUuYCA6IF9mb3JtYXRNdWlFcnJvck1lc3NhZ2UoMTgpKTtcbiAgfVxuICBjb25zdCBwYWxldHRlID0gY3JlYXRlUGFsZXR0ZShwYWxldHRlSW5wdXQpO1xuICBjb25zdCBzeXN0ZW1UaGVtZSA9IHN5c3RlbUNyZWF0ZVRoZW1lKG9wdGlvbnMpO1xuICBsZXQgbXVpVGhlbWUgPSBkZWVwbWVyZ2Uoc3lzdGVtVGhlbWUsIHtcbiAgICBtaXhpbnM6IGNyZWF0ZU1peGlucyhzeXN0ZW1UaGVtZS5icmVha3BvaW50cywgbWl4aW5zSW5wdXQpLFxuICAgIHBhbGV0dGUsXG4gICAgLy8gRG9uJ3QgdXNlIFsuLi5zaGFkb3dzXSB1bnRpbCB5b3UndmUgdmVyaWZpZWQgaXRzIHRyYW5zcGlsZWQgY29kZSBpcyBub3QgaW52b2tpbmcgdGhlIGl0ZXJhdG9yIHByb3RvY29sLlxuICAgIHNoYWRvd3M6IHNoYWRvd3Muc2xpY2UoKSxcbiAgICB0eXBvZ3JhcGh5OiBjcmVhdGVUeXBvZ3JhcGh5KHBhbGV0dGUsIHR5cG9ncmFwaHlJbnB1dCksXG4gICAgdHJhbnNpdGlvbnM6IGNyZWF0ZVRyYW5zaXRpb25zKHRyYW5zaXRpb25zSW5wdXQpLFxuICAgIHpJbmRleDogX2V4dGVuZHMoe30sIHpJbmRleClcbiAgfSk7XG4gIG11aVRoZW1lID0gZGVlcG1lcmdlKG11aVRoZW1lLCBvdGhlcik7XG4gIG11aVRoZW1lID0gYXJncy5yZWR1Y2UoKGFjYywgYXJndW1lbnQpID0+IGRlZXBtZXJnZShhY2MsIGFyZ3VtZW50KSwgbXVpVGhlbWUpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRPRE8gdjY6IFJlZmFjdG9yIHRvIHVzZSBnbG9iYWxTdGF0ZUNsYXNzZXNNYXBwaW5nIGZyb20gQG11aS91dGlscyBvbmNlIGByZWFkT25seWAgc3RhdGUgY2xhc3MgaXMgdXNlZCBpbiBSYXRpbmcgY29tcG9uZW50LlxuICAgIGNvbnN0IHN0YXRlQ2xhc3NlcyA9IFsnYWN0aXZlJywgJ2NoZWNrZWQnLCAnY29tcGxldGVkJywgJ2Rpc2FibGVkJywgJ2Vycm9yJywgJ2V4cGFuZGVkJywgJ2ZvY3VzZWQnLCAnZm9jdXNWaXNpYmxlJywgJ3JlcXVpcmVkJywgJ3NlbGVjdGVkJ107XG4gICAgY29uc3QgdHJhdmVyc2UgPSAobm9kZSwgY29tcG9uZW50KSA9PiB7XG4gICAgICBsZXQga2V5O1xuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluLCBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgZm9yIChrZXkgaW4gbm9kZSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGVba2V5XTtcbiAgICAgICAgaWYgKHN0YXRlQ2xhc3Nlcy5pbmRleE9mKGtleSkgIT09IC0xICYmIE9iamVjdC5rZXlzKGNoaWxkKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlQ2xhc3MgPSBnZW5lcmF0ZVV0aWxpdHlDbGFzcygnJywga2V5KTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoW2BNVUk6IFRoZSBcXGAke2NvbXBvbmVudH1cXGAgY29tcG9uZW50IGluY3JlYXNlcyBgICsgYHRoZSBDU1Mgc3BlY2lmaWNpdHkgb2YgdGhlIFxcYCR7a2V5fVxcYCBpbnRlcm5hbCBzdGF0ZS5gLCAnWW91IGNhbiBub3Qgb3ZlcnJpZGUgaXQgbGlrZSB0aGlzOiAnLCBKU09OLnN0cmluZ2lmeShub2RlLCBudWxsLCAyKSwgJycsIGBJbnN0ZWFkLCB5b3UgbmVlZCB0byB1c2UgdGhlICcmLiR7c3RhdGVDbGFzc30nIHN5bnRheDpgLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBbYCYuJHtzdGF0ZUNsYXNzfWBdOiBjaGlsZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBudWxsLCAyKSwgJycsICdodHRwczovL211aS5jb20vci9zdGF0ZS1jbGFzc2VzLWd1aWRlJ10uam9pbignXFxuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIHN0eWxlIHRvIHByZXZlbnQgZ2xvYmFsIGNvbmZsaWN0cy5cbiAgICAgICAgICBub2RlW2tleV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmtleXMobXVpVGhlbWUuY29tcG9uZW50cykuZm9yRWFjaChjb21wb25lbnQgPT4ge1xuICAgICAgY29uc3Qgc3R5bGVPdmVycmlkZXMgPSBtdWlUaGVtZS5jb21wb25lbnRzW2NvbXBvbmVudF0uc3R5bGVPdmVycmlkZXM7XG4gICAgICBpZiAoc3R5bGVPdmVycmlkZXMgJiYgY29tcG9uZW50LmluZGV4T2YoJ011aScpID09PSAwKSB7XG4gICAgICAgIHRyYXZlcnNlKHN0eWxlT3ZlcnJpZGVzLCBjb21wb25lbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG11aVRoZW1lLnVuc3RhYmxlX3N4Q29uZmlnID0gX2V4dGVuZHMoe30sIGRlZmF1bHRTeENvbmZpZywgb3RoZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG90aGVyLnVuc3RhYmxlX3N4Q29uZmlnKTtcbiAgbXVpVGhlbWUudW5zdGFibGVfc3ggPSBmdW5jdGlvbiBzeChwcm9wcykge1xuICAgIHJldHVybiBzdHlsZUZ1bmN0aW9uU3goe1xuICAgICAgc3g6IHByb3BzLFxuICAgICAgdGhlbWU6IHRoaXNcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIG11aVRoZW1lO1xufVxubGV0IHdhcm5lZE9uY2UgPSBmYWxzZTtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNdWlUaGVtZSguLi5hcmdzKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKCF3YXJuZWRPbmNlKSB7XG4gICAgICB3YXJuZWRPbmNlID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydNVUk6IHRoZSBjcmVhdGVNdWlUaGVtZSBmdW5jdGlvbiB3YXMgcmVuYW1lZCB0byBjcmVhdGVUaGVtZS4nLCAnJywgXCJZb3Ugc2hvdWxkIHVzZSBgaW1wb3J0IHsgY3JlYXRlVGhlbWUgfSBmcm9tICdAbXVpL21hdGVyaWFsL3N0eWxlcydgXCJdLmpvaW4oJ1xcbicpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVRoZW1lKC4uLmFyZ3MpO1xufVxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlVGhlbWU7IiwiaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmNvbnN0IF9leGNsdWRlZCA9IFtcImR1cmF0aW9uXCIsIFwiZWFzaW5nXCIsIFwiZGVsYXlcIl07XG4vLyBGb2xsb3cgaHR0cHM6Ly9tYXRlcmlhbC5nb29nbGUuY29tL21vdGlvbi9kdXJhdGlvbi1lYXNpbmcuaHRtbCNkdXJhdGlvbi1lYXNpbmctbmF0dXJhbC1lYXNpbmctY3VydmVzXG4vLyB0byBsZWFybiB0aGUgY29udGV4dCBpbiB3aGljaCBlYWNoIGVhc2luZyBzaG91bGQgYmUgdXNlZC5cbmV4cG9ydCBjb25zdCBlYXNpbmcgPSB7XG4gIC8vIFRoaXMgaXMgdGhlIG1vc3QgY29tbW9uIGVhc2luZyBjdXJ2ZS5cbiAgZWFzZUluT3V0OiAnY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKScsXG4gIC8vIE9iamVjdHMgZW50ZXIgdGhlIHNjcmVlbiBhdCBmdWxsIHZlbG9jaXR5IGZyb20gb2ZmLXNjcmVlbiBhbmRcbiAgLy8gc2xvd2x5IGRlY2VsZXJhdGUgdG8gYSByZXN0aW5nIHBvaW50LlxuICBlYXNlT3V0OiAnY3ViaWMtYmV6aWVyKDAuMCwgMCwgMC4yLCAxKScsXG4gIC8vIE9iamVjdHMgbGVhdmUgdGhlIHNjcmVlbiBhdCBmdWxsIHZlbG9jaXR5LiBUaGV5IGRvIG5vdCBkZWNlbGVyYXRlIHdoZW4gb2ZmLXNjcmVlbi5cbiAgZWFzZUluOiAnY3ViaWMtYmV6aWVyKDAuNCwgMCwgMSwgMSknLFxuICAvLyBUaGUgc2hhcnAgY3VydmUgaXMgdXNlZCBieSBvYmplY3RzIHRoYXQgbWF5IHJldHVybiB0byB0aGUgc2NyZWVuIGF0IGFueSB0aW1lLlxuICBzaGFycDogJ2N1YmljLWJlemllcigwLjQsIDAsIDAuNiwgMSknXG59O1xuXG4vLyBGb2xsb3cgaHR0cHM6Ly9tMi5tYXRlcmlhbC5pby9ndWlkZWxpbmVzL21vdGlvbi9kdXJhdGlvbi1lYXNpbmcuaHRtbCNkdXJhdGlvbi1lYXNpbmctY29tbW9uLWR1cmF0aW9uc1xuLy8gdG8gbGVhcm4gd2hlbiB1c2Ugd2hhdCB0aW1pbmdcbmV4cG9ydCBjb25zdCBkdXJhdGlvbiA9IHtcbiAgc2hvcnRlc3Q6IDE1MCxcbiAgc2hvcnRlcjogMjAwLFxuICBzaG9ydDogMjUwLFxuICAvLyBtb3N0IGJhc2ljIHJlY29tbWVuZGVkIHRpbWluZ1xuICBzdGFuZGFyZDogMzAwLFxuICAvLyB0aGlzIGlzIHRvIGJlIHVzZWQgaW4gY29tcGxleCBhbmltYXRpb25zXG4gIGNvbXBsZXg6IDM3NSxcbiAgLy8gcmVjb21tZW5kZWQgd2hlbiBzb21ldGhpbmcgaXMgZW50ZXJpbmcgc2NyZWVuXG4gIGVudGVyaW5nU2NyZWVuOiAyMjUsXG4gIC8vIHJlY29tbWVuZGVkIHdoZW4gc29tZXRoaW5nIGlzIGxlYXZpbmcgc2NyZWVuXG4gIGxlYXZpbmdTY3JlZW46IDE5NVxufTtcbmZ1bmN0aW9uIGZvcm1hdE1zKG1pbGxpc2Vjb25kcykge1xuICByZXR1cm4gYCR7TWF0aC5yb3VuZChtaWxsaXNlY29uZHMpfW1zYDtcbn1cbmZ1bmN0aW9uIGdldEF1dG9IZWlnaHREdXJhdGlvbihoZWlnaHQpIHtcbiAgaWYgKCFoZWlnaHQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCBjb25zdGFudCA9IGhlaWdodCAvIDM2O1xuXG4gIC8vIGh0dHBzOi8vd3d3LndvbGZyYW1hbHBoYS5jb20vaW5wdXQvP2k9KDQrJTJCKzE1KyorKHgrJTJGKzM2KykrKiorMC4yNSslMkIrKHgrJTJGKzM2KSslMkYrNSkrKisxMFxuICByZXR1cm4gTWF0aC5yb3VuZCgoNCArIDE1ICogY29uc3RhbnQgKiogMC4yNSArIGNvbnN0YW50IC8gNSkgKiAxMCk7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9ucyhpbnB1dFRyYW5zaXRpb25zKSB7XG4gIGNvbnN0IG1lcmdlZEVhc2luZyA9IF9leHRlbmRzKHt9LCBlYXNpbmcsIGlucHV0VHJhbnNpdGlvbnMuZWFzaW5nKTtcbiAgY29uc3QgbWVyZ2VkRHVyYXRpb24gPSBfZXh0ZW5kcyh7fSwgZHVyYXRpb24sIGlucHV0VHJhbnNpdGlvbnMuZHVyYXRpb24pO1xuICBjb25zdCBjcmVhdGUgPSAocHJvcHMgPSBbJ2FsbCddLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCB7XG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbk9wdGlvbiA9IG1lcmdlZER1cmF0aW9uLnN0YW5kYXJkLFxuICAgICAgICBlYXNpbmc6IGVhc2luZ09wdGlvbiA9IG1lcmdlZEVhc2luZy5lYXNlSW5PdXQsXG4gICAgICAgIGRlbGF5ID0gMFxuICAgICAgfSA9IG9wdGlvbnMsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKG9wdGlvbnMsIF9leGNsdWRlZCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnN0IGlzU3RyaW5nID0gdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgICAgIC8vIElFMTEgc3VwcG9ydCwgcmVwbGFjZSB3aXRoIE51bWJlci5pc05hTlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgICAgY29uc3QgaXNOdW1iZXIgPSB2YWx1ZSA9PiAhaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgICAgaWYgKCFpc1N0cmluZyhwcm9wcykgJiYgIUFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ01VSTogQXJndW1lbnQgXCJwcm9wc1wiIG11c3QgYmUgYSBzdHJpbmcgb3IgQXJyYXkuJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzTnVtYmVyKGR1cmF0aW9uT3B0aW9uKSAmJiAhaXNTdHJpbmcoZHVyYXRpb25PcHRpb24pKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYE1VSTogQXJndW1lbnQgXCJkdXJhdGlvblwiIG11c3QgYmUgYSBudW1iZXIgb3IgYSBzdHJpbmcgYnV0IGZvdW5kICR7ZHVyYXRpb25PcHRpb259LmApO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1N0cmluZyhlYXNpbmdPcHRpb24pKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ01VSTogQXJndW1lbnQgXCJlYXNpbmdcIiBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc051bWJlcihkZWxheSkgJiYgIWlzU3RyaW5nKGRlbGF5KSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdNVUk6IEFyZ3VtZW50IFwiZGVsYXlcIiBtdXN0IGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nLicpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFsnTVVJOiBTZWNvbmcgYXJndW1lbnQgb2YgdHJhbnNpdGlvbi5jcmVhdGUgbXVzdCBiZSBhbiBvYmplY3QuJywgXCJBcmd1bWVudHMgc2hvdWxkIGJlIGVpdGhlciBgY3JlYXRlKCdwcm9wMScsIG9wdGlvbnMpYCBvciBgY3JlYXRlKFsncHJvcDEnLCAncHJvcDInXSwgb3B0aW9ucylgXCJdLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3Qua2V5cyhvdGhlcikubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYE1VSTogVW5yZWNvZ25pemVkIGFyZ3VtZW50KHMpIFske09iamVjdC5rZXlzKG90aGVyKS5qb2luKCcsJyl9XS5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChBcnJheS5pc0FycmF5KHByb3BzKSA/IHByb3BzIDogW3Byb3BzXSkubWFwKGFuaW1hdGVkUHJvcCA9PiBgJHthbmltYXRlZFByb3B9ICR7dHlwZW9mIGR1cmF0aW9uT3B0aW9uID09PSAnc3RyaW5nJyA/IGR1cmF0aW9uT3B0aW9uIDogZm9ybWF0TXMoZHVyYXRpb25PcHRpb24pfSAke2Vhc2luZ09wdGlvbn0gJHt0eXBlb2YgZGVsYXkgPT09ICdzdHJpbmcnID8gZGVsYXkgOiBmb3JtYXRNcyhkZWxheSl9YCkuam9pbignLCcpO1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMoe1xuICAgIGdldEF1dG9IZWlnaHREdXJhdGlvbixcbiAgICBjcmVhdGVcbiAgfSwgaW5wdXRUcmFuc2l0aW9ucywge1xuICAgIGVhc2luZzogbWVyZ2VkRWFzaW5nLFxuICAgIGR1cmF0aW9uOiBtZXJnZWREdXJhdGlvblxuICB9KTtcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZVwiO1xuY29uc3QgX2V4Y2x1ZGVkID0gW1wiZm9udEZhbWlseVwiLCBcImZvbnRTaXplXCIsIFwiZm9udFdlaWdodExpZ2h0XCIsIFwiZm9udFdlaWdodFJlZ3VsYXJcIiwgXCJmb250V2VpZ2h0TWVkaXVtXCIsIFwiZm9udFdlaWdodEJvbGRcIiwgXCJodG1sRm9udFNpemVcIiwgXCJhbGxWYXJpYW50c1wiLCBcInB4VG9SZW1cIl07XG5pbXBvcnQgeyBkZWVwbWVyZ2UgfSBmcm9tICdAbXVpL3V0aWxzJztcbmZ1bmN0aW9uIHJvdW5kKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMWU1KSAvIDFlNTtcbn1cbmNvbnN0IGNhc2VBbGxDYXBzID0ge1xuICB0ZXh0VHJhbnNmb3JtOiAndXBwZXJjYXNlJ1xufTtcbmNvbnN0IGRlZmF1bHRGb250RmFtaWx5ID0gJ1wiUm9ib3RvXCIsIFwiSGVsdmV0aWNhXCIsIFwiQXJpYWxcIiwgc2Fucy1zZXJpZic7XG5cbi8qKlxuICogQHNlZSBAbGlua3todHRwczovL20yLm1hdGVyaWFsLmlvL2Rlc2lnbi90eXBvZ3JhcGh5L3RoZS10eXBlLXN5c3RlbS5odG1sfVxuICogQHNlZSBAbGlua3todHRwczovL20yLm1hdGVyaWFsLmlvL2Rlc2lnbi90eXBvZ3JhcGh5L3VuZGVyc3RhbmRpbmctdHlwb2dyYXBoeS5odG1sfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVUeXBvZ3JhcGh5KHBhbGV0dGUsIHR5cG9ncmFwaHkpIHtcbiAgY29uc3QgX3JlZiA9IHR5cGVvZiB0eXBvZ3JhcGh5ID09PSAnZnVuY3Rpb24nID8gdHlwb2dyYXBoeShwYWxldHRlKSA6IHR5cG9ncmFwaHksXG4gICAge1xuICAgICAgZm9udEZhbWlseSA9IGRlZmF1bHRGb250RmFtaWx5LFxuICAgICAgLy8gVGhlIGRlZmF1bHQgZm9udCBzaXplIG9mIHRoZSBNYXRlcmlhbCBTcGVjaWZpY2F0aW9uLlxuICAgICAgZm9udFNpemUgPSAxNCxcbiAgICAgIC8vIHB4XG4gICAgICBmb250V2VpZ2h0TGlnaHQgPSAzMDAsXG4gICAgICBmb250V2VpZ2h0UmVndWxhciA9IDQwMCxcbiAgICAgIGZvbnRXZWlnaHRNZWRpdW0gPSA1MDAsXG4gICAgICBmb250V2VpZ2h0Qm9sZCA9IDcwMCxcbiAgICAgIC8vIFRlbGwgTVVJIHdoYXQncyB0aGUgZm9udC1zaXplIG9uIHRoZSBodG1sIGVsZW1lbnQuXG4gICAgICAvLyAxNnB4IGlzIHRoZSBkZWZhdWx0IGZvbnQtc2l6ZSB1c2VkIGJ5IGJyb3dzZXJzLlxuICAgICAgaHRtbEZvbnRTaXplID0gMTYsXG4gICAgICAvLyBBcHBseSB0aGUgQ1NTIHByb3BlcnRpZXMgdG8gYWxsIHRoZSB2YXJpYW50cy5cbiAgICAgIGFsbFZhcmlhbnRzLFxuICAgICAgcHhUb1JlbTogcHhUb1JlbTJcbiAgICB9ID0gX3JlZixcbiAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHR5cGVvZiBmb250U2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ01VSTogYGZvbnRTaXplYCBpcyByZXF1aXJlZCB0byBiZSBhIG51bWJlci4nKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBodG1sRm9udFNpemUgIT09ICdudW1iZXInKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdNVUk6IGBodG1sRm9udFNpemVgIGlzIHJlcXVpcmVkIHRvIGJlIGEgbnVtYmVyLicpO1xuICAgIH1cbiAgfVxuICBjb25zdCBjb2VmID0gZm9udFNpemUgLyAxNDtcbiAgY29uc3QgcHhUb1JlbSA9IHB4VG9SZW0yIHx8IChzaXplID0+IGAke3NpemUgLyBodG1sRm9udFNpemUgKiBjb2VmfXJlbWApO1xuICBjb25zdCBidWlsZFZhcmlhbnQgPSAoZm9udFdlaWdodCwgc2l6ZSwgbGluZUhlaWdodCwgbGV0dGVyU3BhY2luZywgY2FzaW5nKSA9PiBfZXh0ZW5kcyh7XG4gICAgZm9udEZhbWlseSxcbiAgICBmb250V2VpZ2h0LFxuICAgIGZvbnRTaXplOiBweFRvUmVtKHNpemUpLFxuICAgIC8vIFVuaXRsZXNzIGZvbGxvd2luZyBodHRwczovL21leWVyd2ViLmNvbS9lcmljL3Rob3VnaHRzLzIwMDYvMDIvMDgvdW5pdGxlc3MtbGluZS1oZWlnaHRzL1xuICAgIGxpbmVIZWlnaHRcbiAgfSwgZm9udEZhbWlseSA9PT0gZGVmYXVsdEZvbnRGYW1pbHkgPyB7XG4gICAgbGV0dGVyU3BhY2luZzogYCR7cm91bmQobGV0dGVyU3BhY2luZyAvIHNpemUpfWVtYFxuICB9IDoge30sIGNhc2luZywgYWxsVmFyaWFudHMpO1xuICBjb25zdCB2YXJpYW50cyA9IHtcbiAgICBoMTogYnVpbGRWYXJpYW50KGZvbnRXZWlnaHRMaWdodCwgOTYsIDEuMTY3LCAtMS41KSxcbiAgICBoMjogYnVpbGRWYXJpYW50KGZvbnRXZWlnaHRMaWdodCwgNjAsIDEuMiwgLTAuNSksXG4gICAgaDM6IGJ1aWxkVmFyaWFudChmb250V2VpZ2h0UmVndWxhciwgNDgsIDEuMTY3LCAwKSxcbiAgICBoNDogYnVpbGRWYXJpYW50KGZvbnRXZWlnaHRSZWd1bGFyLCAzNCwgMS4yMzUsIDAuMjUpLFxuICAgIGg1OiBidWlsZFZhcmlhbnQoZm9udFdlaWdodFJlZ3VsYXIsIDI0LCAxLjMzNCwgMCksXG4gICAgaDY6IGJ1aWxkVmFyaWFudChmb250V2VpZ2h0TWVkaXVtLCAyMCwgMS42LCAwLjE1KSxcbiAgICBzdWJ0aXRsZTE6IGJ1aWxkVmFyaWFudChmb250V2VpZ2h0UmVndWxhciwgMTYsIDEuNzUsIDAuMTUpLFxuICAgIHN1YnRpdGxlMjogYnVpbGRWYXJpYW50KGZvbnRXZWlnaHRNZWRpdW0sIDE0LCAxLjU3LCAwLjEpLFxuICAgIGJvZHkxOiBidWlsZFZhcmlhbnQoZm9udFdlaWdodFJlZ3VsYXIsIDE2LCAxLjUsIDAuMTUpLFxuICAgIGJvZHkyOiBidWlsZFZhcmlhbnQoZm9udFdlaWdodFJlZ3VsYXIsIDE0LCAxLjQzLCAwLjE1KSxcbiAgICBidXR0b246IGJ1aWxkVmFyaWFudChmb250V2VpZ2h0TWVkaXVtLCAxNCwgMS43NSwgMC40LCBjYXNlQWxsQ2FwcyksXG4gICAgY2FwdGlvbjogYnVpbGRWYXJpYW50KGZvbnRXZWlnaHRSZWd1bGFyLCAxMiwgMS42NiwgMC40KSxcbiAgICBvdmVybGluZTogYnVpbGRWYXJpYW50KGZvbnRXZWlnaHRSZWd1bGFyLCAxMiwgMi42NiwgMSwgY2FzZUFsbENhcHMpLFxuICAgIC8vIFRPRE8gdjY6IFJlbW92ZSBoYW5kbGluZyBvZiAnaW5oZXJpdCcgdmFyaWFudCBmcm9tIHRoZSB0aGVtZSBhcyBpdCBpcyBhbHJlYWR5IGhhbmRsZWQgaW4gTWF0ZXJpYWwgVUkncyBUeXBvZ3JhcGh5IGNvbXBvbmVudC4gQWxzbywgcmVtZW1iZXIgdG8gcmVtb3ZlIHRoZSBhc3NvY2lhdGVkIHR5cGVzLlxuICAgIGluaGVyaXQ6IHtcbiAgICAgIGZvbnRGYW1pbHk6ICdpbmhlcml0JyxcbiAgICAgIGZvbnRXZWlnaHQ6ICdpbmhlcml0JyxcbiAgICAgIGZvbnRTaXplOiAnaW5oZXJpdCcsXG4gICAgICBsaW5lSGVpZ2h0OiAnaW5oZXJpdCcsXG4gICAgICBsZXR0ZXJTcGFjaW5nOiAnaW5oZXJpdCdcbiAgICB9XG4gIH07XG4gIHJldHVybiBkZWVwbWVyZ2UoX2V4dGVuZHMoe1xuICAgIGh0bWxGb250U2l6ZSxcbiAgICBweFRvUmVtLFxuICAgIGZvbnRGYW1pbHksXG4gICAgZm9udFNpemUsXG4gICAgZm9udFdlaWdodExpZ2h0LFxuICAgIGZvbnRXZWlnaHRSZWd1bGFyLFxuICAgIGZvbnRXZWlnaHRNZWRpdW0sXG4gICAgZm9udFdlaWdodEJvbGRcbiAgfSwgdmFyaWFudHMpLCBvdGhlciwge1xuICAgIGNsb25lOiBmYWxzZSAvLyBObyBuZWVkIHRvIGNsb25lIGRlZXBcbiAgfSk7XG59IiwiY29uc3Qgc2hhZG93S2V5VW1icmFPcGFjaXR5ID0gMC4yO1xuY29uc3Qgc2hhZG93S2V5UGVudW1icmFPcGFjaXR5ID0gMC4xNDtcbmNvbnN0IHNoYWRvd0FtYmllbnRTaGFkb3dPcGFjaXR5ID0gMC4xMjtcbmZ1bmN0aW9uIGNyZWF0ZVNoYWRvdyguLi5weCkge1xuICByZXR1cm4gW2Ake3B4WzBdfXB4ICR7cHhbMV19cHggJHtweFsyXX1weCAke3B4WzNdfXB4IHJnYmEoMCwwLDAsJHtzaGFkb3dLZXlVbWJyYU9wYWNpdHl9KWAsIGAke3B4WzRdfXB4ICR7cHhbNV19cHggJHtweFs2XX1weCAke3B4WzddfXB4IHJnYmEoMCwwLDAsJHtzaGFkb3dLZXlQZW51bWJyYU9wYWNpdHl9KWAsIGAke3B4WzhdfXB4ICR7cHhbOV19cHggJHtweFsxMF19cHggJHtweFsxMV19cHggcmdiYSgwLDAsMCwke3NoYWRvd0FtYmllbnRTaGFkb3dPcGFjaXR5fSlgXS5qb2luKCcsJyk7XG59XG5cbi8vIFZhbHVlcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvYmU4NzQ3Zjk0NTc0NjY5Y2I1ZTdhZGQxYTdjNTRmYTQxYTg5Y2VjNy9wYWNrYWdlcy9tZGMtZWxldmF0aW9uL192YXJpYWJsZXMuc2Nzc1xuY29uc3Qgc2hhZG93cyA9IFsnbm9uZScsIGNyZWF0ZVNoYWRvdygwLCAyLCAxLCAtMSwgMCwgMSwgMSwgMCwgMCwgMSwgMywgMCksIGNyZWF0ZVNoYWRvdygwLCAzLCAxLCAtMiwgMCwgMiwgMiwgMCwgMCwgMSwgNSwgMCksIGNyZWF0ZVNoYWRvdygwLCAzLCAzLCAtMiwgMCwgMywgNCwgMCwgMCwgMSwgOCwgMCksIGNyZWF0ZVNoYWRvdygwLCAyLCA0LCAtMSwgMCwgNCwgNSwgMCwgMCwgMSwgMTAsIDApLCBjcmVhdGVTaGFkb3coMCwgMywgNSwgLTEsIDAsIDUsIDgsIDAsIDAsIDEsIDE0LCAwKSwgY3JlYXRlU2hhZG93KDAsIDMsIDUsIC0xLCAwLCA2LCAxMCwgMCwgMCwgMSwgMTgsIDApLCBjcmVhdGVTaGFkb3coMCwgNCwgNSwgLTIsIDAsIDcsIDEwLCAxLCAwLCAyLCAxNiwgMSksIGNyZWF0ZVNoYWRvdygwLCA1LCA1LCAtMywgMCwgOCwgMTAsIDEsIDAsIDMsIDE0LCAyKSwgY3JlYXRlU2hhZG93KDAsIDUsIDYsIC0zLCAwLCA5LCAxMiwgMSwgMCwgMywgMTYsIDIpLCBjcmVhdGVTaGFkb3coMCwgNiwgNiwgLTMsIDAsIDEwLCAxNCwgMSwgMCwgNCwgMTgsIDMpLCBjcmVhdGVTaGFkb3coMCwgNiwgNywgLTQsIDAsIDExLCAxNSwgMSwgMCwgNCwgMjAsIDMpLCBjcmVhdGVTaGFkb3coMCwgNywgOCwgLTQsIDAsIDEyLCAxNywgMiwgMCwgNSwgMjIsIDQpLCBjcmVhdGVTaGFkb3coMCwgNywgOCwgLTQsIDAsIDEzLCAxOSwgMiwgMCwgNSwgMjQsIDQpLCBjcmVhdGVTaGFkb3coMCwgNywgOSwgLTQsIDAsIDE0LCAyMSwgMiwgMCwgNSwgMjYsIDQpLCBjcmVhdGVTaGFkb3coMCwgOCwgOSwgLTUsIDAsIDE1LCAyMiwgMiwgMCwgNiwgMjgsIDUpLCBjcmVhdGVTaGFkb3coMCwgOCwgMTAsIC01LCAwLCAxNiwgMjQsIDIsIDAsIDYsIDMwLCA1KSwgY3JlYXRlU2hhZG93KDAsIDgsIDExLCAtNSwgMCwgMTcsIDI2LCAyLCAwLCA2LCAzMiwgNSksIGNyZWF0ZVNoYWRvdygwLCA5LCAxMSwgLTUsIDAsIDE4LCAyOCwgMiwgMCwgNywgMzQsIDYpLCBjcmVhdGVTaGFkb3coMCwgOSwgMTIsIC02LCAwLCAxOSwgMjksIDIsIDAsIDcsIDM2LCA2KSwgY3JlYXRlU2hhZG93KDAsIDEwLCAxMywgLTYsIDAsIDIwLCAzMSwgMywgMCwgOCwgMzgsIDcpLCBjcmVhdGVTaGFkb3coMCwgMTAsIDEzLCAtNiwgMCwgMjEsIDMzLCAzLCAwLCA4LCA0MCwgNyksIGNyZWF0ZVNoYWRvdygwLCAxMCwgMTQsIC02LCAwLCAyMiwgMzUsIDMsIDAsIDgsIDQyLCA3KSwgY3JlYXRlU2hhZG93KDAsIDExLCAxNCwgLTcsIDAsIDIzLCAzNiwgMywgMCwgOSwgNDQsIDgpLCBjcmVhdGVTaGFkb3coMCwgMTEsIDE1LCAtNywgMCwgMjQsIDM4LCAzLCAwLCA5LCA0NiwgOCldO1xuZXhwb3J0IGRlZmF1bHQgc2hhZG93czsiLCIvLyBXZSBuZWVkIHRvIGNlbnRyYWxpemUgdGhlIHpJbmRleCBkZWZpbml0aW9ucyBhcyB0aGV5IHdvcmtcbi8vIGxpa2UgZ2xvYmFsIHZhbHVlcyBpbiB0aGUgYnJvd3Nlci5cbmNvbnN0IHpJbmRleCA9IHtcbiAgbW9iaWxlU3RlcHBlcjogMTAwMCxcbiAgZmFiOiAxMDUwLFxuICBzcGVlZERpYWw6IDEwNTAsXG4gIGFwcEJhcjogMTEwMCxcbiAgZHJhd2VyOiAxMjAwLFxuICBtb2RhbDogMTMwMCxcbiAgc25hY2tiYXI6IDE0MDAsXG4gIHRvb2x0aXA6IDE1MDBcbn07XG5leHBvcnQgZGVmYXVsdCB6SW5kZXg7IiwiaW1wb3J0IHJlc3BvbnNpdmVQcm9wVHlwZSBmcm9tICcuL3Jlc3BvbnNpdmVQcm9wVHlwZSc7XG5pbXBvcnQgc3R5bGUgZnJvbSAnLi9zdHlsZSc7XG5pbXBvcnQgY29tcG9zZSBmcm9tICcuL2NvbXBvc2UnO1xuaW1wb3J0IHsgY3JlYXRlVW5hcnlVbml0LCBnZXRWYWx1ZSB9IGZyb20gJy4vc3BhY2luZyc7XG5pbXBvcnQgeyBoYW5kbGVCcmVha3BvaW50cyB9IGZyb20gJy4vYnJlYWtwb2ludHMnO1xuZXhwb3J0IGZ1bmN0aW9uIGJvcmRlclRyYW5zZm9ybSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gYCR7dmFsdWV9cHggc29saWRgO1xufVxuZnVuY3Rpb24gY3JlYXRlQm9yZGVyU3R5bGUocHJvcCwgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBzdHlsZSh7XG4gICAgcHJvcCxcbiAgICB0aGVtZUtleTogJ2JvcmRlcnMnLFxuICAgIHRyYW5zZm9ybVxuICB9KTtcbn1cbmV4cG9ydCBjb25zdCBib3JkZXIgPSBjcmVhdGVCb3JkZXJTdHlsZSgnYm9yZGVyJywgYm9yZGVyVHJhbnNmb3JtKTtcbmV4cG9ydCBjb25zdCBib3JkZXJUb3AgPSBjcmVhdGVCb3JkZXJTdHlsZSgnYm9yZGVyVG9wJywgYm9yZGVyVHJhbnNmb3JtKTtcbmV4cG9ydCBjb25zdCBib3JkZXJSaWdodCA9IGNyZWF0ZUJvcmRlclN0eWxlKCdib3JkZXJSaWdodCcsIGJvcmRlclRyYW5zZm9ybSk7XG5leHBvcnQgY29uc3QgYm9yZGVyQm90dG9tID0gY3JlYXRlQm9yZGVyU3R5bGUoJ2JvcmRlckJvdHRvbScsIGJvcmRlclRyYW5zZm9ybSk7XG5leHBvcnQgY29uc3QgYm9yZGVyTGVmdCA9IGNyZWF0ZUJvcmRlclN0eWxlKCdib3JkZXJMZWZ0JywgYm9yZGVyVHJhbnNmb3JtKTtcbmV4cG9ydCBjb25zdCBib3JkZXJDb2xvciA9IGNyZWF0ZUJvcmRlclN0eWxlKCdib3JkZXJDb2xvcicpO1xuZXhwb3J0IGNvbnN0IGJvcmRlclRvcENvbG9yID0gY3JlYXRlQm9yZGVyU3R5bGUoJ2JvcmRlclRvcENvbG9yJyk7XG5leHBvcnQgY29uc3QgYm9yZGVyUmlnaHRDb2xvciA9IGNyZWF0ZUJvcmRlclN0eWxlKCdib3JkZXJSaWdodENvbG9yJyk7XG5leHBvcnQgY29uc3QgYm9yZGVyQm90dG9tQ29sb3IgPSBjcmVhdGVCb3JkZXJTdHlsZSgnYm9yZGVyQm90dG9tQ29sb3InKTtcbmV4cG9ydCBjb25zdCBib3JkZXJMZWZ0Q29sb3IgPSBjcmVhdGVCb3JkZXJTdHlsZSgnYm9yZGVyTGVmdENvbG9yJyk7XG5leHBvcnQgY29uc3Qgb3V0bGluZSA9IGNyZWF0ZUJvcmRlclN0eWxlKCdvdXRsaW5lJywgYm9yZGVyVHJhbnNmb3JtKTtcbmV4cG9ydCBjb25zdCBvdXRsaW5lQ29sb3IgPSBjcmVhdGVCb3JkZXJTdHlsZSgnb3V0bGluZUNvbG9yJyk7XG5cbi8vIGZhbHNlIHBvc2l0aXZlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZnVuY3Rpb24tY29tcG9uZW50LWRlZmluaXRpb25cbmV4cG9ydCBjb25zdCBib3JkZXJSYWRpdXMgPSBwcm9wcyA9PiB7XG4gIGlmIChwcm9wcy5ib3JkZXJSYWRpdXMgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5ib3JkZXJSYWRpdXMgIT09IG51bGwpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1lciA9IGNyZWF0ZVVuYXJ5VW5pdChwcm9wcy50aGVtZSwgJ3NoYXBlLmJvcmRlclJhZGl1cycsIDQsICdib3JkZXJSYWRpdXMnKTtcbiAgICBjb25zdCBzdHlsZUZyb21Qcm9wVmFsdWUgPSBwcm9wVmFsdWUgPT4gKHtcbiAgICAgIGJvcmRlclJhZGl1czogZ2V0VmFsdWUodHJhbnNmb3JtZXIsIHByb3BWYWx1ZSlcbiAgICB9KTtcbiAgICByZXR1cm4gaGFuZGxlQnJlYWtwb2ludHMocHJvcHMsIHByb3BzLmJvcmRlclJhZGl1cywgc3R5bGVGcm9tUHJvcFZhbHVlKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5ib3JkZXJSYWRpdXMucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHtcbiAgYm9yZGVyUmFkaXVzOiByZXNwb25zaXZlUHJvcFR5cGVcbn0gOiB7fTtcbmJvcmRlclJhZGl1cy5maWx0ZXJQcm9wcyA9IFsnYm9yZGVyUmFkaXVzJ107XG5jb25zdCBib3JkZXJzID0gY29tcG9zZShib3JkZXIsIGJvcmRlclRvcCwgYm9yZGVyUmlnaHQsIGJvcmRlckJvdHRvbSwgYm9yZGVyTGVmdCwgYm9yZGVyQ29sb3IsIGJvcmRlclRvcENvbG9yLCBib3JkZXJSaWdodENvbG9yLCBib3JkZXJCb3R0b21Db2xvciwgYm9yZGVyTGVmdENvbG9yLCBib3JkZXJSYWRpdXMsIG91dGxpbmUsIG91dGxpbmVDb2xvcik7XG5leHBvcnQgZGVmYXVsdCBib3JkZXJzOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IGRlZXBtZXJnZSB9IGZyb20gJ0BtdWkvdXRpbHMnO1xuaW1wb3J0IG1lcmdlIGZyb20gJy4vbWVyZ2UnO1xuXG4vLyBUaGUgYnJlYWtwb2ludCAqKnN0YXJ0KiogYXQgdGhpcyB2YWx1ZS5cbi8vIEZvciBpbnN0YW5jZSB3aXRoIHRoZSBmaXJzdCBicmVha3BvaW50IHhzOiBbeHMsIHNtWy5cbmV4cG9ydCBjb25zdCB2YWx1ZXMgPSB7XG4gIHhzOiAwLFxuICAvLyBwaG9uZVxuICBzbTogNjAwLFxuICAvLyB0YWJsZXRcbiAgbWQ6IDkwMCxcbiAgLy8gc21hbGwgbGFwdG9wXG4gIGxnOiAxMjAwLFxuICAvLyBkZXNrdG9wXG4gIHhsOiAxNTM2IC8vIGxhcmdlIHNjcmVlblxufTtcbmNvbnN0IGRlZmF1bHRCcmVha3BvaW50cyA9IHtcbiAgLy8gU29ydGVkIEFTQyBieSBzaXplLiBUaGF0J3MgaW1wb3J0YW50LlxuICAvLyBJdCBjYW4ndCBiZSBjb25maWd1cmVkIGFzIGl0J3MgdXNlZCBzdGF0aWNhbGx5IGZvciBwcm9wVHlwZXMuXG4gIGtleXM6IFsneHMnLCAnc20nLCAnbWQnLCAnbGcnLCAneGwnXSxcbiAgdXA6IGtleSA9PiBgQG1lZGlhIChtaW4td2lkdGg6JHt2YWx1ZXNba2V5XX1weClgXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUJyZWFrcG9pbnRzKHByb3BzLCBwcm9wVmFsdWUsIHN0eWxlRnJvbVByb3BWYWx1ZSkge1xuICBjb25zdCB0aGVtZSA9IHByb3BzLnRoZW1lIHx8IHt9O1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgY29uc3QgdGhlbWVCcmVha3BvaW50cyA9IHRoZW1lLmJyZWFrcG9pbnRzIHx8IGRlZmF1bHRCcmVha3BvaW50cztcbiAgICByZXR1cm4gcHJvcFZhbHVlLnJlZHVjZSgoYWNjLCBpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgYWNjW3RoZW1lQnJlYWtwb2ludHMudXAodGhlbWVCcmVha3BvaW50cy5rZXlzW2luZGV4XSldID0gc3R5bGVGcm9tUHJvcFZhbHVlKHByb3BWYWx1ZVtpbmRleF0pO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgdGhlbWVCcmVha3BvaW50cyA9IHRoZW1lLmJyZWFrcG9pbnRzIHx8IGRlZmF1bHRCcmVha3BvaW50cztcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocHJvcFZhbHVlKS5yZWR1Y2UoKGFjYywgYnJlYWtwb2ludCkgPT4ge1xuICAgICAgLy8ga2V5IGlzIGJyZWFrcG9pbnRcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGVtZUJyZWFrcG9pbnRzLnZhbHVlcyB8fCB2YWx1ZXMpLmluZGV4T2YoYnJlYWtwb2ludCkgIT09IC0xKSB7XG4gICAgICAgIGNvbnN0IG1lZGlhS2V5ID0gdGhlbWVCcmVha3BvaW50cy51cChicmVha3BvaW50KTtcbiAgICAgICAgYWNjW21lZGlhS2V5XSA9IHN0eWxlRnJvbVByb3BWYWx1ZShwcm9wVmFsdWVbYnJlYWtwb2ludF0sIGJyZWFrcG9pbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY3NzS2V5ID0gYnJlYWtwb2ludDtcbiAgICAgICAgYWNjW2Nzc0tleV0gPSBwcm9wVmFsdWVbY3NzS2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICB9XG4gIGNvbnN0IG91dHB1dCA9IHN0eWxlRnJvbVByb3BWYWx1ZShwcm9wVmFsdWUpO1xuICByZXR1cm4gb3V0cHV0O1xufVxuZnVuY3Rpb24gYnJlYWtwb2ludHMoc3R5bGVGdW5jdGlvbikge1xuICAvLyBmYWxzZSBwb3NpdGl2ZVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZnVuY3Rpb24tY29tcG9uZW50LWRlZmluaXRpb25cbiAgY29uc3QgbmV3U3R5bGVGdW5jdGlvbiA9IHByb3BzID0+IHtcbiAgICBjb25zdCB0aGVtZSA9IHByb3BzLnRoZW1lIHx8IHt9O1xuICAgIGNvbnN0IGJhc2UgPSBzdHlsZUZ1bmN0aW9uKHByb3BzKTtcbiAgICBjb25zdCB0aGVtZUJyZWFrcG9pbnRzID0gdGhlbWUuYnJlYWtwb2ludHMgfHwgZGVmYXVsdEJyZWFrcG9pbnRzO1xuICAgIGNvbnN0IGV4dGVuZGVkID0gdGhlbWVCcmVha3BvaW50cy5rZXlzLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgIGlmIChwcm9wc1trZXldKSB7XG4gICAgICAgIGFjYyA9IGFjYyB8fCB7fTtcbiAgICAgICAgYWNjW3RoZW1lQnJlYWtwb2ludHMudXAoa2V5KV0gPSBzdHlsZUZ1bmN0aW9uKF9leHRlbmRzKHtcbiAgICAgICAgICB0aGVtZVxuICAgICAgICB9LCBwcm9wc1trZXldKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIG51bGwpO1xuICAgIHJldHVybiBtZXJnZShiYXNlLCBleHRlbmRlZCk7XG4gIH07XG4gIG5ld1N0eWxlRnVuY3Rpb24ucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF9leHRlbmRzKHt9LCBzdHlsZUZ1bmN0aW9uLnByb3BUeXBlcywge1xuICAgIHhzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIHNtOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIG1kOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIGxnOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIHhsOiBQcm9wVHlwZXMub2JqZWN0XG4gIH0pIDoge307XG4gIG5ld1N0eWxlRnVuY3Rpb24uZmlsdGVyUHJvcHMgPSBbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJywgLi4uc3R5bGVGdW5jdGlvbi5maWx0ZXJQcm9wc107XG4gIHJldHVybiBuZXdTdHlsZUZ1bmN0aW9uO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVtcHR5QnJlYWtwb2ludE9iamVjdChicmVha3BvaW50c0lucHV0ID0ge30pIHtcbiAgdmFyIF9icmVha3BvaW50c0lucHV0JGtleTtcbiAgY29uc3QgYnJlYWtwb2ludHNJbk9yZGVyID0gKF9icmVha3BvaW50c0lucHV0JGtleSA9IGJyZWFrcG9pbnRzSW5wdXQua2V5cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9icmVha3BvaW50c0lucHV0JGtleS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgY29uc3QgYnJlYWtwb2ludFN0eWxlS2V5ID0gYnJlYWtwb2ludHNJbnB1dC51cChrZXkpO1xuICAgIGFjY1ticmVha3BvaW50U3R5bGVLZXldID0ge307XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gYnJlYWtwb2ludHNJbk9yZGVyIHx8IHt9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVVudXNlZEJyZWFrcG9pbnRzKGJyZWFrcG9pbnRLZXlzLCBzdHlsZSkge1xuICByZXR1cm4gYnJlYWtwb2ludEtleXMucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGNvbnN0IGJyZWFrcG9pbnRPdXRwdXQgPSBhY2Nba2V5XTtcbiAgICBjb25zdCBpc0JyZWFrcG9pbnRVbnVzZWQgPSAhYnJlYWtwb2ludE91dHB1dCB8fCBPYmplY3Qua2V5cyhicmVha3BvaW50T3V0cHV0KS5sZW5ndGggPT09IDA7XG4gICAgaWYgKGlzQnJlYWtwb2ludFVudXNlZCkge1xuICAgICAgZGVsZXRlIGFjY1trZXldO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCBzdHlsZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VCcmVha3BvaW50c0luT3JkZXIoYnJlYWtwb2ludHNJbnB1dCwgLi4uc3R5bGVzKSB7XG4gIGNvbnN0IGVtcHR5QnJlYWtwb2ludHMgPSBjcmVhdGVFbXB0eUJyZWFrcG9pbnRPYmplY3QoYnJlYWtwb2ludHNJbnB1dCk7XG4gIGNvbnN0IG1lcmdlZE91dHB1dCA9IFtlbXB0eUJyZWFrcG9pbnRzLCAuLi5zdHlsZXNdLnJlZHVjZSgocHJldiwgbmV4dCkgPT4gZGVlcG1lcmdlKHByZXYsIG5leHQpLCB7fSk7XG4gIHJldHVybiByZW1vdmVVbnVzZWRCcmVha3BvaW50cyhPYmplY3Qua2V5cyhlbXB0eUJyZWFrcG9pbnRzKSwgbWVyZ2VkT3V0cHV0KTtcbn1cblxuLy8gY29tcHV0ZSBiYXNlIGZvciByZXNwb25zaXZlIHZhbHVlczsgZS5nLixcbi8vIFsxLDIsM10gPT4ge3hzOiB0cnVlLCBzbTogdHJ1ZSwgbWQ6IHRydWV9XG4vLyB7eHM6IDEsIHNtOiAyLCBtZDogM30gPT4ge3hzOiB0cnVlLCBzbTogdHJ1ZSwgbWQ6IHRydWV9XG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUJyZWFrcG9pbnRzQmFzZShicmVha3BvaW50VmFsdWVzLCB0aGVtZUJyZWFrcG9pbnRzKSB7XG4gIC8vIGZpeGVkIHZhbHVlXG4gIGlmICh0eXBlb2YgYnJlYWtwb2ludFZhbHVlcyAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgYmFzZSA9IHt9O1xuICBjb25zdCBicmVha3BvaW50c0tleXMgPSBPYmplY3Qua2V5cyh0aGVtZUJyZWFrcG9pbnRzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYnJlYWtwb2ludFZhbHVlcykpIHtcbiAgICBicmVha3BvaW50c0tleXMuZm9yRWFjaCgoYnJlYWtwb2ludCwgaSkgPT4ge1xuICAgICAgaWYgKGkgPCBicmVha3BvaW50VmFsdWVzLmxlbmd0aCkge1xuICAgICAgICBiYXNlW2JyZWFrcG9pbnRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBicmVha3BvaW50c0tleXMuZm9yRWFjaChicmVha3BvaW50ID0+IHtcbiAgICAgIGlmIChicmVha3BvaW50VmFsdWVzW2JyZWFrcG9pbnRdICE9IG51bGwpIHtcbiAgICAgICAgYmFzZVticmVha3BvaW50XSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGJhc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUJyZWFrcG9pbnRWYWx1ZXMoe1xuICB2YWx1ZXM6IGJyZWFrcG9pbnRWYWx1ZXMsXG4gIGJyZWFrcG9pbnRzOiB0aGVtZUJyZWFrcG9pbnRzLFxuICBiYXNlOiBjdXN0b21CYXNlXG59KSB7XG4gIGNvbnN0IGJhc2UgPSBjdXN0b21CYXNlIHx8IGNvbXB1dGVCcmVha3BvaW50c0Jhc2UoYnJlYWtwb2ludFZhbHVlcywgdGhlbWVCcmVha3BvaW50cyk7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhiYXNlKTtcbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGJyZWFrcG9pbnRWYWx1ZXM7XG4gIH1cbiAgbGV0IHByZXZpb3VzO1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoKGFjYywgYnJlYWtwb2ludCwgaSkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGJyZWFrcG9pbnRWYWx1ZXMpKSB7XG4gICAgICBhY2NbYnJlYWtwb2ludF0gPSBicmVha3BvaW50VmFsdWVzW2ldICE9IG51bGwgPyBicmVha3BvaW50VmFsdWVzW2ldIDogYnJlYWtwb2ludFZhbHVlc1twcmV2aW91c107XG4gICAgICBwcmV2aW91cyA9IGk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYnJlYWtwb2ludFZhbHVlcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGFjY1ticmVha3BvaW50XSA9IGJyZWFrcG9pbnRWYWx1ZXNbYnJlYWtwb2ludF0gIT0gbnVsbCA/IGJyZWFrcG9pbnRWYWx1ZXNbYnJlYWtwb2ludF0gOiBicmVha3BvaW50VmFsdWVzW3ByZXZpb3VzXTtcbiAgICAgIHByZXZpb3VzID0gYnJlYWtwb2ludDtcbiAgICB9IGVsc2Uge1xuICAgICAgYWNjW2JyZWFrcG9pbnRdID0gYnJlYWtwb2ludFZhbHVlcztcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuZXhwb3J0IGRlZmF1bHQgYnJlYWtwb2ludHM7IiwiaW1wb3J0IF9mb3JtYXRNdWlFcnJvck1lc3NhZ2UgZnJvbSBcIkBtdWkvdXRpbHMvZm9ybWF0TXVpRXJyb3JNZXNzYWdlXCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gKi9cbmltcG9ydCB7IGNsYW1wIH0gZnJvbSAnQG11aS91dGlscyc7XG4vKipcbiAqIFJldHVybnMgYSBudW1iZXIgd2hvc2UgdmFsdWUgaXMgbGltaXRlZCB0byB0aGUgZ2l2ZW4gcmFuZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNsYW1wZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIGxvd2VyIGJvdW5kYXJ5IG9mIHRoZSBvdXRwdXQgcmFuZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIHVwcGVyIGJvdW5kYXJ5IG9mIHRoZSBvdXRwdXQgcmFuZ2VcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEEgbnVtYmVyIGluIHRoZSByYW5nZSBbbWluLCBtYXhdXG4gKi9cbmZ1bmN0aW9uIGNsYW1wV3JhcHBlcih2YWx1ZSwgbWluID0gMCwgbWF4ID0gMSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICh2YWx1ZSA8IG1pbiB8fCB2YWx1ZSA+IG1heCkge1xuICAgICAgY29uc29sZS5lcnJvcihgTVVJOiBUaGUgdmFsdWUgcHJvdmlkZWQgJHt2YWx1ZX0gaXMgb3V0IG9mIHJhbmdlIFske21pbn0sICR7bWF4fV0uYCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgY29sb3IgZnJvbSBDU1MgaGV4IGZvcm1hdCB0byBDU1MgcmdiIGZvcm1hdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciAtIEhleCBjb2xvciwgaS5lLiAjbm5uIG9yICNubm5ubm5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgQ1NTIHJnYiBjb2xvciBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvUmdiKGNvbG9yKSB7XG4gIGNvbG9yID0gY29sb3Iuc2xpY2UoMSk7XG4gIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChgLnsxLCR7Y29sb3IubGVuZ3RoID49IDYgPyAyIDogMX19YCwgJ2cnKTtcbiAgbGV0IGNvbG9ycyA9IGNvbG9yLm1hdGNoKHJlKTtcbiAgaWYgKGNvbG9ycyAmJiBjb2xvcnNbMF0ubGVuZ3RoID09PSAxKSB7XG4gICAgY29sb3JzID0gY29sb3JzLm1hcChuID0+IG4gKyBuKTtcbiAgfVxuICByZXR1cm4gY29sb3JzID8gYHJnYiR7Y29sb3JzLmxlbmd0aCA9PT0gNCA/ICdhJyA6ICcnfSgke2NvbG9ycy5tYXAoKG4sIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIGluZGV4IDwgMyA/IHBhcnNlSW50KG4sIDE2KSA6IE1hdGgucm91bmQocGFyc2VJbnQobiwgMTYpIC8gMjU1ICogMTAwMCkgLyAxMDAwO1xuICB9KS5qb2luKCcsICcpfSlgIDogJyc7XG59XG5mdW5jdGlvbiBpbnRUb0hleChpbnQpIHtcbiAgY29uc3QgaGV4ID0gaW50LnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIGhleC5sZW5ndGggPT09IDEgPyBgMCR7aGV4fWAgOiBoZXg7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgdHlwZSBhbmQgdmFsdWVzIG9mIGEgY29sb3IuXG4gKlxuICogTm90ZTogRG9lcyBub3Qgc3VwcG9ydCByZ2IgJSB2YWx1ZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgLSBDU1MgY29sb3IsIGkuZS4gb25lIG9mOiAjbm5uLCAjbm5ubm5uLCByZ2IoKSwgcmdiYSgpLCBoc2woKSwgaHNsYSgpLCBjb2xvcigpXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIEEgTVVJIGNvbG9yIG9iamVjdDoge3R5cGU6IHN0cmluZywgdmFsdWVzOiBudW1iZXJbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29tcG9zZUNvbG9yKGNvbG9yKSB7XG4gIC8vIElkZW1wb3RlbnRcbiAgaWYgKGNvbG9yLnR5cGUpIHtcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cbiAgaWYgKGNvbG9yLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgcmV0dXJuIGRlY29tcG9zZUNvbG9yKGhleFRvUmdiKGNvbG9yKSk7XG4gIH1cbiAgY29uc3QgbWFya2VyID0gY29sb3IuaW5kZXhPZignKCcpO1xuICBjb25zdCB0eXBlID0gY29sb3Iuc3Vic3RyaW5nKDAsIG1hcmtlcik7XG4gIGlmIChbJ3JnYicsICdyZ2JhJywgJ2hzbCcsICdoc2xhJywgJ2NvbG9yJ10uaW5kZXhPZih0eXBlKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gYE1VSTogVW5zdXBwb3J0ZWQgXFxgJHtjb2xvcn1cXGAgY29sb3IuXG5UaGUgZm9sbG93aW5nIGZvcm1hdHMgYXJlIHN1cHBvcnRlZDogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKSwgY29sb3IoKS5gIDogX2Zvcm1hdE11aUVycm9yTWVzc2FnZSg5LCBjb2xvcikpO1xuICB9XG4gIGxldCB2YWx1ZXMgPSBjb2xvci5zdWJzdHJpbmcobWFya2VyICsgMSwgY29sb3IubGVuZ3RoIC0gMSk7XG4gIGxldCBjb2xvclNwYWNlO1xuICBpZiAodHlwZSA9PT0gJ2NvbG9yJykge1xuICAgIHZhbHVlcyA9IHZhbHVlcy5zcGxpdCgnICcpO1xuICAgIGNvbG9yU3BhY2UgPSB2YWx1ZXMuc2hpZnQoKTtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gNCAmJiB2YWx1ZXNbM10uY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgIHZhbHVlc1szXSA9IHZhbHVlc1szXS5zbGljZSgxKTtcbiAgICB9XG4gICAgaWYgKFsnc3JnYicsICdkaXNwbGF5LXAzJywgJ2E5OC1yZ2InLCAncHJvcGhvdG8tcmdiJywgJ3JlYy0yMDIwJ10uaW5kZXhPZihjb2xvclNwYWNlKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBgTVVJOiB1bnN1cHBvcnRlZCBcXGAke2NvbG9yU3BhY2V9XFxgIGNvbG9yIHNwYWNlLlxuVGhlIGZvbGxvd2luZyBjb2xvciBzcGFjZXMgYXJlIHN1cHBvcnRlZDogc3JnYiwgZGlzcGxheS1wMywgYTk4LXJnYiwgcHJvcGhvdG8tcmdiLCByZWMtMjAyMC5gIDogX2Zvcm1hdE11aUVycm9yTWVzc2FnZSgxMCwgY29sb3JTcGFjZSkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZXMgPSB2YWx1ZXMuc3BsaXQoJywnKTtcbiAgfVxuICB2YWx1ZXMgPSB2YWx1ZXMubWFwKHZhbHVlID0+IHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIHZhbHVlcyxcbiAgICBjb2xvclNwYWNlXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGNoYW5uZWwgY3JlYXRlZCBmcm9tIHRoZSBpbnB1dCBjb2xvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgLSBDU1MgY29sb3IsIGkuZS4gb25lIG9mOiAjbm5uLCAjbm5ubm5uLCByZ2IoKSwgcmdiYSgpLCBoc2woKSwgaHNsYSgpLCBjb2xvcigpXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBjaGFubmVsIGZvciB0aGUgY29sb3IsIHRoYXQgY2FuIGJlIHVzZWQgaW4gcmdiYSBvciBoc2xhIGNvbG9yc1xuICovXG5leHBvcnQgY29uc3QgY29sb3JDaGFubmVsID0gY29sb3IgPT4ge1xuICBjb25zdCBkZWNvbXBvc2VkQ29sb3IgPSBkZWNvbXBvc2VDb2xvcihjb2xvcik7XG4gIHJldHVybiBkZWNvbXBvc2VkQ29sb3IudmFsdWVzLnNsaWNlKDAsIDMpLm1hcCgodmFsLCBpZHgpID0+IGRlY29tcG9zZWRDb2xvci50eXBlLmluZGV4T2YoJ2hzbCcpICE9PSAtMSAmJiBpZHggIT09IDAgPyBgJHt2YWx9JWAgOiB2YWwpLmpvaW4oJyAnKTtcbn07XG5leHBvcnQgY29uc3QgcHJpdmF0ZV9zYWZlQ29sb3JDaGFubmVsID0gKGNvbG9yLCB3YXJuaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNvbG9yQ2hhbm5lbChjb2xvcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKHdhcm5pbmcgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc29sZS53YXJuKHdhcm5pbmcpO1xuICAgIH1cbiAgICByZXR1cm4gY29sb3I7XG4gIH1cbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBjb2xvciBvYmplY3Qgd2l0aCB0eXBlIGFuZCB2YWx1ZXMgdG8gYSBzdHJpbmcuXG4gKiBAcGFyYW0ge29iamVjdH0gY29sb3IgLSBEZWNvbXBvc2VkIGNvbG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IudHlwZSAtIE9uZSBvZjogJ3JnYicsICdyZ2JhJywgJ2hzbCcsICdoc2xhJywgJ2NvbG9yJ1xuICogQHBhcmFtIHthcnJheX0gY29sb3IudmFsdWVzIC0gW24sbixuXSBvciBbbixuLG4sbl1cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgQ1NTIGNvbG9yIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVjb21wb3NlQ29sb3IoY29sb3IpIHtcbiAgY29uc3Qge1xuICAgIHR5cGUsXG4gICAgY29sb3JTcGFjZVxuICB9ID0gY29sb3I7XG4gIGxldCB7XG4gICAgdmFsdWVzXG4gIH0gPSBjb2xvcjtcbiAgaWYgKHR5cGUuaW5kZXhPZigncmdiJykgIT09IC0xKSB7XG4gICAgLy8gT25seSBjb252ZXJ0IHRoZSBmaXJzdCAzIHZhbHVlcyB0byBpbnQgKGkuZS4gbm90IGFscGhhKVxuICAgIHZhbHVlcyA9IHZhbHVlcy5tYXAoKG4sIGkpID0+IGkgPCAzID8gcGFyc2VJbnQobiwgMTApIDogbik7XG4gIH0gZWxzZSBpZiAodHlwZS5pbmRleE9mKCdoc2wnKSAhPT0gLTEpIHtcbiAgICB2YWx1ZXNbMV0gPSBgJHt2YWx1ZXNbMV19JWA7XG4gICAgdmFsdWVzWzJdID0gYCR7dmFsdWVzWzJdfSVgO1xuICB9XG4gIGlmICh0eXBlLmluZGV4T2YoJ2NvbG9yJykgIT09IC0xKSB7XG4gICAgdmFsdWVzID0gYCR7Y29sb3JTcGFjZX0gJHt2YWx1ZXMuam9pbignICcpfWA7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWVzID0gYCR7dmFsdWVzLmpvaW4oJywgJyl9YDtcbiAgfVxuICByZXR1cm4gYCR7dHlwZX0oJHt2YWx1ZXN9KWA7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBjb2xvciBmcm9tIENTUyByZ2IgZm9ybWF0IHRvIENTUyBoZXggZm9ybWF0LlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gUkdCIGNvbG9yLCBpLmUuIHJnYihuLCBuLCBuKVxuICogQHJldHVybnMge3N0cmluZ30gQSBDU1MgcmdiIGNvbG9yIHN0cmluZywgaS5lLiAjbm5ubm5uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZ2JUb0hleChjb2xvcikge1xuICAvLyBJZGVtcG90ZW50XG4gIGlmIChjb2xvci5pbmRleE9mKCcjJykgPT09IDApIHtcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cbiAgY29uc3Qge1xuICAgIHZhbHVlc1xuICB9ID0gZGVjb21wb3NlQ29sb3IoY29sb3IpO1xuICByZXR1cm4gYCMke3ZhbHVlcy5tYXAoKG4sIGkpID0+IGludFRvSGV4KGkgPT09IDMgPyBNYXRoLnJvdW5kKDI1NSAqIG4pIDogbikpLmpvaW4oJycpfWA7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBjb2xvciBmcm9tIGhzbCBmb3JtYXQgdG8gcmdiIGZvcm1hdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciAtIEhTTCBjb2xvciB2YWx1ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHJnYiBjb2xvciB2YWx1ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhzbFRvUmdiKGNvbG9yKSB7XG4gIGNvbG9yID0gZGVjb21wb3NlQ29sb3IoY29sb3IpO1xuICBjb25zdCB7XG4gICAgdmFsdWVzXG4gIH0gPSBjb2xvcjtcbiAgY29uc3QgaCA9IHZhbHVlc1swXTtcbiAgY29uc3QgcyA9IHZhbHVlc1sxXSAvIDEwMDtcbiAgY29uc3QgbCA9IHZhbHVlc1syXSAvIDEwMDtcbiAgY29uc3QgYSA9IHMgKiBNYXRoLm1pbihsLCAxIC0gbCk7XG4gIGNvbnN0IGYgPSAobiwgayA9IChuICsgaCAvIDMwKSAlIDEyKSA9PiBsIC0gYSAqIE1hdGgubWF4KE1hdGgubWluKGsgLSAzLCA5IC0gaywgMSksIC0xKTtcbiAgbGV0IHR5cGUgPSAncmdiJztcbiAgY29uc3QgcmdiID0gW01hdGgucm91bmQoZigwKSAqIDI1NSksIE1hdGgucm91bmQoZig4KSAqIDI1NSksIE1hdGgucm91bmQoZig0KSAqIDI1NSldO1xuICBpZiAoY29sb3IudHlwZSA9PT0gJ2hzbGEnKSB7XG4gICAgdHlwZSArPSAnYSc7XG4gICAgcmdiLnB1c2godmFsdWVzWzNdKTtcbiAgfVxuICByZXR1cm4gcmVjb21wb3NlQ29sb3Ioe1xuICAgIHR5cGUsXG4gICAgdmFsdWVzOiByZ2JcbiAgfSk7XG59XG4vKipcbiAqIFRoZSByZWxhdGl2ZSBicmlnaHRuZXNzIG9mIGFueSBwb2ludCBpbiBhIGNvbG9yIHNwYWNlLFxuICogbm9ybWFsaXplZCB0byAwIGZvciBkYXJrZXN0IGJsYWNrIGFuZCAxIGZvciBsaWdodGVzdCB3aGl0ZS5cbiAqXG4gKiBGb3JtdWxhOiBodHRwczovL3d3dy53My5vcmcvVFIvV0NBRzIwLVRFQ0hTL0cxNy5odG1sI0cxNy10ZXN0c1xuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gQ1NTIGNvbG9yLCBpLmUuIG9uZSBvZjogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKSwgY29sb3IoKVxuICogQHJldHVybnMge251bWJlcn0gVGhlIHJlbGF0aXZlIGJyaWdodG5lc3Mgb2YgdGhlIGNvbG9yIGluIHRoZSByYW5nZSAwIC0gMVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0THVtaW5hbmNlKGNvbG9yKSB7XG4gIGNvbG9yID0gZGVjb21wb3NlQ29sb3IoY29sb3IpO1xuICBsZXQgcmdiID0gY29sb3IudHlwZSA9PT0gJ2hzbCcgfHwgY29sb3IudHlwZSA9PT0gJ2hzbGEnID8gZGVjb21wb3NlQ29sb3IoaHNsVG9SZ2IoY29sb3IpKS52YWx1ZXMgOiBjb2xvci52YWx1ZXM7XG4gIHJnYiA9IHJnYi5tYXAodmFsID0+IHtcbiAgICBpZiAoY29sb3IudHlwZSAhPT0gJ2NvbG9yJykge1xuICAgICAgdmFsIC89IDI1NTsgLy8gbm9ybWFsaXplZFxuICAgIH1cbiAgICByZXR1cm4gdmFsIDw9IDAuMDM5MjggPyB2YWwgLyAxMi45MiA6ICgodmFsICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNDtcbiAgfSk7XG5cbiAgLy8gVHJ1bmNhdGUgYXQgMyBkaWdpdHNcbiAgcmV0dXJuIE51bWJlcigoMC4yMTI2ICogcmdiWzBdICsgMC43MTUyICogcmdiWzFdICsgMC4wNzIyICogcmdiWzJdKS50b0ZpeGVkKDMpKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBjb250cmFzdCByYXRpbyBiZXR3ZWVuIHR3byBjb2xvcnMuXG4gKlxuICogRm9ybXVsYTogaHR0cHM6Ly93d3cudzMub3JnL1RSL1dDQUcyMC1URUNIUy9HMTcuaHRtbCNHMTctdGVzdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb3JlZ3JvdW5kIC0gQ1NTIGNvbG9yLCBpLmUuIG9uZSBvZjogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKVxuICogQHBhcmFtIHtzdHJpbmd9IGJhY2tncm91bmQgLSBDU1MgY29sb3IsIGkuZS4gb25lIG9mOiAjbm5uLCAjbm5ubm5uLCByZ2IoKSwgcmdiYSgpLCBoc2woKSwgaHNsYSgpXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBBIGNvbnRyYXN0IHJhdGlvIHZhbHVlIGluIHRoZSByYW5nZSAwIC0gMjEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250cmFzdFJhdGlvKGZvcmVncm91bmQsIGJhY2tncm91bmQpIHtcbiAgY29uc3QgbHVtQSA9IGdldEx1bWluYW5jZShmb3JlZ3JvdW5kKTtcbiAgY29uc3QgbHVtQiA9IGdldEx1bWluYW5jZShiYWNrZ3JvdW5kKTtcbiAgcmV0dXJuIChNYXRoLm1heChsdW1BLCBsdW1CKSArIDAuMDUpIC8gKE1hdGgubWluKGx1bUEsIGx1bUIpICsgMC4wNSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgYWJzb2x1dGUgdHJhbnNwYXJlbmN5IG9mIGEgY29sb3IuXG4gKiBBbnkgZXhpc3RpbmcgYWxwaGEgdmFsdWVzIGFyZSBvdmVyd3JpdHRlbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciAtIENTUyBjb2xvciwgaS5lLiBvbmUgb2Y6ICNubm4sICNubm5ubm4sIHJnYigpLCByZ2JhKCksIGhzbCgpLCBoc2xhKCksIGNvbG9yKClcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHZhbHVlIHRvIHNldCB0aGUgYWxwaGEgY2hhbm5lbCB0byBpbiB0aGUgcmFuZ2UgMCAtIDFcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgQ1NTIGNvbG9yIHN0cmluZy4gSGV4IGlucHV0IHZhbHVlcyBhcmUgcmV0dXJuZWQgYXMgcmdiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbHBoYShjb2xvciwgdmFsdWUpIHtcbiAgY29sb3IgPSBkZWNvbXBvc2VDb2xvcihjb2xvcik7XG4gIHZhbHVlID0gY2xhbXBXcmFwcGVyKHZhbHVlKTtcbiAgaWYgKGNvbG9yLnR5cGUgPT09ICdyZ2InIHx8IGNvbG9yLnR5cGUgPT09ICdoc2wnKSB7XG4gICAgY29sb3IudHlwZSArPSAnYSc7XG4gIH1cbiAgaWYgKGNvbG9yLnR5cGUgPT09ICdjb2xvcicpIHtcbiAgICBjb2xvci52YWx1ZXNbM10gPSBgLyR7dmFsdWV9YDtcbiAgfSBlbHNlIHtcbiAgICBjb2xvci52YWx1ZXNbM10gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gcmVjb21wb3NlQ29sb3IoY29sb3IpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHByaXZhdGVfc2FmZUFscGhhKGNvbG9yLCB2YWx1ZSwgd2FybmluZykge1xuICB0cnkge1xuICAgIHJldHVybiBhbHBoYShjb2xvciwgdmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmICh3YXJuaW5nICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG59XG5cbi8qKlxuICogRGFya2VucyBhIGNvbG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gQ1NTIGNvbG9yLCBpLmUuIG9uZSBvZjogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKSwgY29sb3IoKVxuICogQHBhcmFtIHtudW1iZXJ9IGNvZWZmaWNpZW50IC0gbXVsdGlwbGllciBpbiB0aGUgcmFuZ2UgMCAtIDFcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgQ1NTIGNvbG9yIHN0cmluZy4gSGV4IGlucHV0IHZhbHVlcyBhcmUgcmV0dXJuZWQgYXMgcmdiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXJrZW4oY29sb3IsIGNvZWZmaWNpZW50KSB7XG4gIGNvbG9yID0gZGVjb21wb3NlQ29sb3IoY29sb3IpO1xuICBjb2VmZmljaWVudCA9IGNsYW1wV3JhcHBlcihjb2VmZmljaWVudCk7XG4gIGlmIChjb2xvci50eXBlLmluZGV4T2YoJ2hzbCcpICE9PSAtMSkge1xuICAgIGNvbG9yLnZhbHVlc1syXSAqPSAxIC0gY29lZmZpY2llbnQ7XG4gIH0gZWxzZSBpZiAoY29sb3IudHlwZS5pbmRleE9mKCdyZ2InKSAhPT0gLTEgfHwgY29sb3IudHlwZS5pbmRleE9mKCdjb2xvcicpICE9PSAtMSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSArPSAxKSB7XG4gICAgICBjb2xvci52YWx1ZXNbaV0gKj0gMSAtIGNvZWZmaWNpZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVjb21wb3NlQ29sb3IoY29sb3IpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHByaXZhdGVfc2FmZURhcmtlbihjb2xvciwgY29lZmZpY2llbnQsIHdhcm5pbmcpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGFya2VuKGNvbG9yLCBjb2VmZmljaWVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKHdhcm5pbmcgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc29sZS53YXJuKHdhcm5pbmcpO1xuICAgIH1cbiAgICByZXR1cm4gY29sb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBMaWdodGVucyBhIGNvbG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gQ1NTIGNvbG9yLCBpLmUuIG9uZSBvZjogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKSwgY29sb3IoKVxuICogQHBhcmFtIHtudW1iZXJ9IGNvZWZmaWNpZW50IC0gbXVsdGlwbGllciBpbiB0aGUgcmFuZ2UgMCAtIDFcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgQ1NTIGNvbG9yIHN0cmluZy4gSGV4IGlucHV0IHZhbHVlcyBhcmUgcmV0dXJuZWQgYXMgcmdiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaWdodGVuKGNvbG9yLCBjb2VmZmljaWVudCkge1xuICBjb2xvciA9IGRlY29tcG9zZUNvbG9yKGNvbG9yKTtcbiAgY29lZmZpY2llbnQgPSBjbGFtcFdyYXBwZXIoY29lZmZpY2llbnQpO1xuICBpZiAoY29sb3IudHlwZS5pbmRleE9mKCdoc2wnKSAhPT0gLTEpIHtcbiAgICBjb2xvci52YWx1ZXNbMl0gKz0gKDEwMCAtIGNvbG9yLnZhbHVlc1syXSkgKiBjb2VmZmljaWVudDtcbiAgfSBlbHNlIGlmIChjb2xvci50eXBlLmluZGV4T2YoJ3JnYicpICE9PSAtMSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSArPSAxKSB7XG4gICAgICBjb2xvci52YWx1ZXNbaV0gKz0gKDI1NSAtIGNvbG9yLnZhbHVlc1tpXSkgKiBjb2VmZmljaWVudDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY29sb3IudHlwZS5pbmRleE9mKCdjb2xvcicpICE9PSAtMSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSArPSAxKSB7XG4gICAgICBjb2xvci52YWx1ZXNbaV0gKz0gKDEgLSBjb2xvci52YWx1ZXNbaV0pICogY29lZmZpY2llbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWNvbXBvc2VDb2xvcihjb2xvcik7XG59XG5leHBvcnQgZnVuY3Rpb24gcHJpdmF0ZV9zYWZlTGlnaHRlbihjb2xvciwgY29lZmZpY2llbnQsIHdhcm5pbmcpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbGlnaHRlbihjb2xvciwgY29lZmZpY2llbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmICh3YXJuaW5nICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG59XG5cbi8qKlxuICogRGFya2VuIG9yIGxpZ2h0ZW4gYSBjb2xvciwgZGVwZW5kaW5nIG9uIGl0cyBsdW1pbmFuY2UuXG4gKiBMaWdodCBjb2xvcnMgYXJlIGRhcmtlbmVkLCBkYXJrIGNvbG9ycyBhcmUgbGlnaHRlbmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gQ1NTIGNvbG9yLCBpLmUuIG9uZSBvZjogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKSwgY29sb3IoKVxuICogQHBhcmFtIHtudW1iZXJ9IGNvZWZmaWNpZW50PTAuMTUgLSBtdWx0aXBsaWVyIGluIHRoZSByYW5nZSAwIC0gMVxuICogQHJldHVybnMge3N0cmluZ30gQSBDU1MgY29sb3Igc3RyaW5nLiBIZXggaW5wdXQgdmFsdWVzIGFyZSByZXR1cm5lZCBhcyByZ2JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVtcGhhc2l6ZShjb2xvciwgY29lZmZpY2llbnQgPSAwLjE1KSB7XG4gIHJldHVybiBnZXRMdW1pbmFuY2UoY29sb3IpID4gMC41ID8gZGFya2VuKGNvbG9yLCBjb2VmZmljaWVudCkgOiBsaWdodGVuKGNvbG9yLCBjb2VmZmljaWVudCk7XG59XG5leHBvcnQgZnVuY3Rpb24gcHJpdmF0ZV9zYWZlRW1waGFzaXplKGNvbG9yLCBjb2VmZmljaWVudCwgd2FybmluZykge1xuICB0cnkge1xuICAgIHJldHVybiBwcml2YXRlX3NhZmVFbXBoYXNpemUoY29sb3IsIGNvZWZmaWNpZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAod2FybmluZyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25zb2xlLndhcm4od2FybmluZyk7XG4gICAgfVxuICAgIHJldHVybiBjb2xvcjtcbiAgfVxufSIsImltcG9ydCBtZXJnZSBmcm9tICcuL21lcmdlJztcbmZ1bmN0aW9uIGNvbXBvc2UoLi4uc3R5bGVzKSB7XG4gIGNvbnN0IGhhbmRsZXJzID0gc3R5bGVzLnJlZHVjZSgoYWNjLCBzdHlsZSkgPT4ge1xuICAgIHN0eWxlLmZpbHRlclByb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICBhY2NbcHJvcF0gPSBzdHlsZTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG5cbiAgLy8gZmFsc2UgcG9zaXRpdmVcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Z1bmN0aW9uLWNvbXBvbmVudC1kZWZpbml0aW9uXG4gIGNvbnN0IGZuID0gcHJvcHMgPT4ge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhwcm9wcykucmVkdWNlKChhY2MsIHByb3ApID0+IHtcbiAgICAgIGlmIChoYW5kbGVyc1twcm9wXSkge1xuICAgICAgICByZXR1cm4gbWVyZ2UoYWNjLCBoYW5kbGVyc1twcm9wXShwcm9wcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gIH07XG4gIGZuLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBzdHlsZXMucmVkdWNlKChhY2MsIHN0eWxlKSA9PiBPYmplY3QuYXNzaWduKGFjYywgc3R5bGUucHJvcFR5cGVzKSwge30pIDoge307XG4gIGZuLmZpbHRlclByb3BzID0gc3R5bGVzLnJlZHVjZSgoYWNjLCBzdHlsZSkgPT4gYWNjLmNvbmNhdChzdHlsZS5maWx0ZXJQcm9wcyksIFtdKTtcbiAgcmV0dXJuIGZuO1xufVxuZXhwb3J0IGRlZmF1bHQgY29tcG9zZTsiLCJpbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcbmltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuY29uc3QgX2V4Y2x1ZGVkID0gW1widmFsdWVzXCIsIFwidW5pdFwiLCBcInN0ZXBcIl07XG4vLyBTb3J0ZWQgQVNDIGJ5IHNpemUuIFRoYXQncyBpbXBvcnRhbnQuXG4vLyBJdCBjYW4ndCBiZSBjb25maWd1cmVkIGFzIGl0J3MgdXNlZCBzdGF0aWNhbGx5IGZvciBwcm9wVHlwZXMuXG5leHBvcnQgY29uc3QgYnJlYWtwb2ludEtleXMgPSBbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJ107XG5jb25zdCBzb3J0QnJlYWtwb2ludHNWYWx1ZXMgPSB2YWx1ZXMgPT4ge1xuICBjb25zdCBicmVha3BvaW50c0FzQXJyYXkgPSBPYmplY3Qua2V5cyh2YWx1ZXMpLm1hcChrZXkgPT4gKHtcbiAgICBrZXksXG4gICAgdmFsOiB2YWx1ZXNba2V5XVxuICB9KSkgfHwgW107XG4gIC8vIFNvcnQgaW4gYXNjZW5kaW5nIG9yZGVyXG4gIGJyZWFrcG9pbnRzQXNBcnJheS5zb3J0KChicmVha3BvaW50MSwgYnJlYWtwb2ludDIpID0+IGJyZWFrcG9pbnQxLnZhbCAtIGJyZWFrcG9pbnQyLnZhbCk7XG4gIHJldHVybiBicmVha3BvaW50c0FzQXJyYXkucmVkdWNlKChhY2MsIG9iaikgPT4ge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgYWNjLCB7XG4gICAgICBbb2JqLmtleV06IG9iai52YWxcbiAgICB9KTtcbiAgfSwge30pO1xufTtcblxuLy8gS2VlcCBpbiBtaW5kIHRoYXQgQG1lZGlhIGlzIGluY2x1c2l2ZSBieSB0aGUgQ1NTIHNwZWNpZmljYXRpb24uXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVCcmVha3BvaW50cyhicmVha3BvaW50cykge1xuICBjb25zdCB7XG4gICAgICAvLyBUaGUgYnJlYWtwb2ludCAqKnN0YXJ0KiogYXQgdGhpcyB2YWx1ZS5cbiAgICAgIC8vIEZvciBpbnN0YW5jZSB3aXRoIHRoZSBmaXJzdCBicmVha3BvaW50IHhzOiBbeHMsIHNtKS5cbiAgICAgIHZhbHVlcyA9IHtcbiAgICAgICAgeHM6IDAsXG4gICAgICAgIC8vIHBob25lXG4gICAgICAgIHNtOiA2MDAsXG4gICAgICAgIC8vIHRhYmxldFxuICAgICAgICBtZDogOTAwLFxuICAgICAgICAvLyBzbWFsbCBsYXB0b3BcbiAgICAgICAgbGc6IDEyMDAsXG4gICAgICAgIC8vIGRlc2t0b3BcbiAgICAgICAgeGw6IDE1MzYgLy8gbGFyZ2Ugc2NyZWVuXG4gICAgICB9LFxuICAgICAgdW5pdCA9ICdweCcsXG4gICAgICBzdGVwID0gNVxuICAgIH0gPSBicmVha3BvaW50cyxcbiAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKGJyZWFrcG9pbnRzLCBfZXhjbHVkZWQpO1xuICBjb25zdCBzb3J0ZWRWYWx1ZXMgPSBzb3J0QnJlYWtwb2ludHNWYWx1ZXModmFsdWVzKTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvcnRlZFZhbHVlcyk7XG4gIGZ1bmN0aW9uIHVwKGtleSkge1xuICAgIGNvbnN0IHZhbHVlID0gdHlwZW9mIHZhbHVlc1trZXldID09PSAnbnVtYmVyJyA/IHZhbHVlc1trZXldIDoga2V5O1xuICAgIHJldHVybiBgQG1lZGlhIChtaW4td2lkdGg6JHt2YWx1ZX0ke3VuaXR9KWA7XG4gIH1cbiAgZnVuY3Rpb24gZG93bihrZXkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHR5cGVvZiB2YWx1ZXNba2V5XSA9PT0gJ251bWJlcicgPyB2YWx1ZXNba2V5XSA6IGtleTtcbiAgICByZXR1cm4gYEBtZWRpYSAobWF4LXdpZHRoOiR7dmFsdWUgLSBzdGVwIC8gMTAwfSR7dW5pdH0pYDtcbiAgfVxuICBmdW5jdGlvbiBiZXR3ZWVuKHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBlbmRJbmRleCA9IGtleXMuaW5kZXhPZihlbmQpO1xuICAgIHJldHVybiBgQG1lZGlhIChtaW4td2lkdGg6JHt0eXBlb2YgdmFsdWVzW3N0YXJ0XSA9PT0gJ251bWJlcicgPyB2YWx1ZXNbc3RhcnRdIDogc3RhcnR9JHt1bml0fSkgYW5kIGAgKyBgKG1heC13aWR0aDokeyhlbmRJbmRleCAhPT0gLTEgJiYgdHlwZW9mIHZhbHVlc1trZXlzW2VuZEluZGV4XV0gPT09ICdudW1iZXInID8gdmFsdWVzW2tleXNbZW5kSW5kZXhdXSA6IGVuZCkgLSBzdGVwIC8gMTAwfSR7dW5pdH0pYDtcbiAgfVxuICBmdW5jdGlvbiBvbmx5KGtleSkge1xuICAgIGlmIChrZXlzLmluZGV4T2Yoa2V5KSArIDEgPCBrZXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJldHdlZW4oa2V5LCBrZXlzW2tleXMuaW5kZXhPZihrZXkpICsgMV0pO1xuICAgIH1cbiAgICByZXR1cm4gdXAoa2V5KTtcbiAgfVxuICBmdW5jdGlvbiBub3Qoa2V5KSB7XG4gICAgLy8gaGFuZGxlIGZpcnN0IGFuZCBsYXN0IGtleSBzZXBhcmF0ZWx5LCBmb3IgYmV0dGVyIHJlYWRhYmlsaXR5XG4gICAgY29uc3Qga2V5SW5kZXggPSBrZXlzLmluZGV4T2Yoa2V5KTtcbiAgICBpZiAoa2V5SW5kZXggPT09IDApIHtcbiAgICAgIHJldHVybiB1cChrZXlzWzFdKTtcbiAgICB9XG4gICAgaWYgKGtleUluZGV4ID09PSBrZXlzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBkb3duKGtleXNba2V5SW5kZXhdKTtcbiAgICB9XG4gICAgcmV0dXJuIGJldHdlZW4oa2V5LCBrZXlzW2tleXMuaW5kZXhPZihrZXkpICsgMV0pLnJlcGxhY2UoJ0BtZWRpYScsICdAbWVkaWEgbm90IGFsbCBhbmQnKTtcbiAgfVxuICByZXR1cm4gX2V4dGVuZHMoe1xuICAgIGtleXMsXG4gICAgdmFsdWVzOiBzb3J0ZWRWYWx1ZXMsXG4gICAgdXAsXG4gICAgZG93bixcbiAgICBiZXR3ZWVuLFxuICAgIG9ubHksXG4gICAgbm90LFxuICAgIHVuaXRcbiAgfSwgb3RoZXIpO1xufSIsImltcG9ydCB7IGNyZWF0ZVVuYXJ5U3BhY2luZyB9IGZyb20gJy4uL3NwYWNpbmcnO1xuXG4vLyBUaGUgZGlmZmVyZW50IHNpZ25hdHVyZXMgaW1wbHkgZGlmZmVyZW50IG1lYW5pbmcgZm9yIHRoZWlyIGFyZ3VtZW50cyB0aGF0IGNhbid0IGJlIGV4cHJlc3NlZCBzdHJ1Y3R1cmFsbHkuXG4vLyBXZSBleHByZXNzIHRoZSBkaWZmZXJlbmNlIHdpdGggdmFyaWFibGUgbmFtZXMuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVNwYWNpbmcoc3BhY2luZ0lucHV0ID0gOCkge1xuICAvLyBBbHJlYWR5IHRyYW5zZm9ybWVkLlxuICBpZiAoc3BhY2luZ0lucHV0Lm11aSkge1xuICAgIHJldHVybiBzcGFjaW5nSW5wdXQ7XG4gIH1cblxuICAvLyBNYXRlcmlhbCBEZXNpZ24gbGF5b3V0cyBhcmUgdmlzdWFsbHkgYmFsYW5jZWQuIE1vc3QgbWVhc3VyZW1lbnRzIGFsaWduIHRvIGFuIDhkcCBncmlkLCB3aGljaCBhbGlnbnMgYm90aCBzcGFjaW5nIGFuZCB0aGUgb3ZlcmFsbCBsYXlvdXQuXG4gIC8vIFNtYWxsZXIgY29tcG9uZW50cywgc3VjaCBhcyBpY29ucywgY2FuIGFsaWduIHRvIGEgNGRwIGdyaWQuXG4gIC8vIGh0dHBzOi8vbTIubWF0ZXJpYWwuaW8vZGVzaWduL2xheW91dC91bmRlcnN0YW5kaW5nLWxheW91dC5odG1sXG4gIGNvbnN0IHRyYW5zZm9ybSA9IGNyZWF0ZVVuYXJ5U3BhY2luZyh7XG4gICAgc3BhY2luZzogc3BhY2luZ0lucHV0XG4gIH0pO1xuICBjb25zdCBzcGFjaW5nID0gKC4uLmFyZ3NJbnB1dCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIShhcmdzSW5wdXQubGVuZ3RoIDw9IDQpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYE1VSTogVG9vIG1hbnkgYXJndW1lbnRzIHByb3ZpZGVkLCBleHBlY3RlZCBiZXR3ZWVuIDAgYW5kIDQsIGdvdCAke2FyZ3NJbnB1dC5sZW5ndGh9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSBhcmdzSW5wdXQubGVuZ3RoID09PSAwID8gWzFdIDogYXJnc0lucHV0O1xuICAgIHJldHVybiBhcmdzLm1hcChhcmd1bWVudCA9PiB7XG4gICAgICBjb25zdCBvdXRwdXQgPSB0cmFuc2Zvcm0oYXJndW1lbnQpO1xuICAgICAgcmV0dXJuIHR5cGVvZiBvdXRwdXQgPT09ICdudW1iZXInID8gYCR7b3V0cHV0fXB4YCA6IG91dHB1dDtcbiAgICB9KS5qb2luKCcgJyk7XG4gIH07XG4gIHNwYWNpbmcubXVpID0gdHJ1ZTtcbiAgcmV0dXJuIHNwYWNpbmc7XG59IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcbmNvbnN0IF9leGNsdWRlZCA9IFtcImJyZWFrcG9pbnRzXCIsIFwicGFsZXR0ZVwiLCBcInNwYWNpbmdcIiwgXCJzaGFwZVwiXTtcbmltcG9ydCB7IGRlZXBtZXJnZSB9IGZyb20gJ0BtdWkvdXRpbHMnO1xuaW1wb3J0IGNyZWF0ZUJyZWFrcG9pbnRzIGZyb20gJy4vY3JlYXRlQnJlYWtwb2ludHMnO1xuaW1wb3J0IHNoYXBlIGZyb20gJy4vc2hhcGUnO1xuaW1wb3J0IGNyZWF0ZVNwYWNpbmcgZnJvbSAnLi9jcmVhdGVTcGFjaW5nJztcbmltcG9ydCBzdHlsZUZ1bmN0aW9uU3ggZnJvbSAnLi4vc3R5bGVGdW5jdGlvblN4L3N0eWxlRnVuY3Rpb25TeCc7XG5pbXBvcnQgZGVmYXVsdFN4Q29uZmlnIGZyb20gJy4uL3N0eWxlRnVuY3Rpb25TeC9kZWZhdWx0U3hDb25maWcnO1xuZnVuY3Rpb24gY3JlYXRlVGhlbWUob3B0aW9ucyA9IHt9LCAuLi5hcmdzKSB7XG4gIGNvbnN0IHtcbiAgICAgIGJyZWFrcG9pbnRzOiBicmVha3BvaW50c0lucHV0ID0ge30sXG4gICAgICBwYWxldHRlOiBwYWxldHRlSW5wdXQgPSB7fSxcbiAgICAgIHNwYWNpbmc6IHNwYWNpbmdJbnB1dCxcbiAgICAgIHNoYXBlOiBzaGFwZUlucHV0ID0ge31cbiAgICB9ID0gb3B0aW9ucyxcbiAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKG9wdGlvbnMsIF9leGNsdWRlZCk7XG4gIGNvbnN0IGJyZWFrcG9pbnRzID0gY3JlYXRlQnJlYWtwb2ludHMoYnJlYWtwb2ludHNJbnB1dCk7XG4gIGNvbnN0IHNwYWNpbmcgPSBjcmVhdGVTcGFjaW5nKHNwYWNpbmdJbnB1dCk7XG4gIGxldCBtdWlUaGVtZSA9IGRlZXBtZXJnZSh7XG4gICAgYnJlYWtwb2ludHMsXG4gICAgZGlyZWN0aW9uOiAnbHRyJyxcbiAgICBjb21wb25lbnRzOiB7fSxcbiAgICAvLyBJbmplY3QgY29tcG9uZW50IGRlZmluaXRpb25zLlxuICAgIHBhbGV0dGU6IF9leHRlbmRzKHtcbiAgICAgIG1vZGU6ICdsaWdodCdcbiAgICB9LCBwYWxldHRlSW5wdXQpLFxuICAgIHNwYWNpbmcsXG4gICAgc2hhcGU6IF9leHRlbmRzKHt9LCBzaGFwZSwgc2hhcGVJbnB1dClcbiAgfSwgb3RoZXIpO1xuICBtdWlUaGVtZSA9IGFyZ3MucmVkdWNlKChhY2MsIGFyZ3VtZW50KSA9PiBkZWVwbWVyZ2UoYWNjLCBhcmd1bWVudCksIG11aVRoZW1lKTtcbiAgbXVpVGhlbWUudW5zdGFibGVfc3hDb25maWcgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdFN4Q29uZmlnLCBvdGhlciA9PSBudWxsID8gdm9pZCAwIDogb3RoZXIudW5zdGFibGVfc3hDb25maWcpO1xuICBtdWlUaGVtZS51bnN0YWJsZV9zeCA9IGZ1bmN0aW9uIHN4KHByb3BzKSB7XG4gICAgcmV0dXJuIHN0eWxlRnVuY3Rpb25TeCh7XG4gICAgICBzeDogcHJvcHMsXG4gICAgICB0aGVtZTogdGhpc1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gbXVpVGhlbWU7XG59XG5leHBvcnQgZGVmYXVsdCBjcmVhdGVUaGVtZTsiLCJjb25zdCBzaGFwZSA9IHtcbiAgYm9yZGVyUmFkaXVzOiA0XG59O1xuZXhwb3J0IGRlZmF1bHQgc2hhcGU7IiwiaW1wb3J0IHN0eWxlIGZyb20gJy4vc3R5bGUnO1xuaW1wb3J0IGNvbXBvc2UgZnJvbSAnLi9jb21wb3NlJztcbmltcG9ydCB7IGNyZWF0ZVVuYXJ5VW5pdCwgZ2V0VmFsdWUgfSBmcm9tICcuL3NwYWNpbmcnO1xuaW1wb3J0IHsgaGFuZGxlQnJlYWtwb2ludHMgfSBmcm9tICcuL2JyZWFrcG9pbnRzJztcbmltcG9ydCByZXNwb25zaXZlUHJvcFR5cGUgZnJvbSAnLi9yZXNwb25zaXZlUHJvcFR5cGUnO1xuXG4vLyBmYWxzZSBwb3NpdGl2ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Z1bmN0aW9uLWNvbXBvbmVudC1kZWZpbml0aW9uXG5leHBvcnQgY29uc3QgZ2FwID0gcHJvcHMgPT4ge1xuICBpZiAocHJvcHMuZ2FwICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZ2FwICE9PSBudWxsKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtZXIgPSBjcmVhdGVVbmFyeVVuaXQocHJvcHMudGhlbWUsICdzcGFjaW5nJywgOCwgJ2dhcCcpO1xuICAgIGNvbnN0IHN0eWxlRnJvbVByb3BWYWx1ZSA9IHByb3BWYWx1ZSA9PiAoe1xuICAgICAgZ2FwOiBnZXRWYWx1ZSh0cmFuc2Zvcm1lciwgcHJvcFZhbHVlKVxuICAgIH0pO1xuICAgIHJldHVybiBoYW5kbGVCcmVha3BvaW50cyhwcm9wcywgcHJvcHMuZ2FwLCBzdHlsZUZyb21Qcm9wVmFsdWUpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbmdhcC5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8ge1xuICBnYXA6IHJlc3BvbnNpdmVQcm9wVHlwZVxufSA6IHt9O1xuZ2FwLmZpbHRlclByb3BzID0gWydnYXAnXTtcblxuLy8gZmFsc2UgcG9zaXRpdmVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9mdW5jdGlvbi1jb21wb25lbnQtZGVmaW5pdGlvblxuZXhwb3J0IGNvbnN0IGNvbHVtbkdhcCA9IHByb3BzID0+IHtcbiAgaWYgKHByb3BzLmNvbHVtbkdhcCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmNvbHVtbkdhcCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gY3JlYXRlVW5hcnlVbml0KHByb3BzLnRoZW1lLCAnc3BhY2luZycsIDgsICdjb2x1bW5HYXAnKTtcbiAgICBjb25zdCBzdHlsZUZyb21Qcm9wVmFsdWUgPSBwcm9wVmFsdWUgPT4gKHtcbiAgICAgIGNvbHVtbkdhcDogZ2V0VmFsdWUodHJhbnNmb3JtZXIsIHByb3BWYWx1ZSlcbiAgICB9KTtcbiAgICByZXR1cm4gaGFuZGxlQnJlYWtwb2ludHMocHJvcHMsIHByb3BzLmNvbHVtbkdhcCwgc3R5bGVGcm9tUHJvcFZhbHVlKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5jb2x1bW5HYXAucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHtcbiAgY29sdW1uR2FwOiByZXNwb25zaXZlUHJvcFR5cGVcbn0gOiB7fTtcbmNvbHVtbkdhcC5maWx0ZXJQcm9wcyA9IFsnY29sdW1uR2FwJ107XG5cbi8vIGZhbHNlIHBvc2l0aXZlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZnVuY3Rpb24tY29tcG9uZW50LWRlZmluaXRpb25cbmV4cG9ydCBjb25zdCByb3dHYXAgPSBwcm9wcyA9PiB7XG4gIGlmIChwcm9wcy5yb3dHYXAgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5yb3dHYXAgIT09IG51bGwpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1lciA9IGNyZWF0ZVVuYXJ5VW5pdChwcm9wcy50aGVtZSwgJ3NwYWNpbmcnLCA4LCAncm93R2FwJyk7XG4gICAgY29uc3Qgc3R5bGVGcm9tUHJvcFZhbHVlID0gcHJvcFZhbHVlID0+ICh7XG4gICAgICByb3dHYXA6IGdldFZhbHVlKHRyYW5zZm9ybWVyLCBwcm9wVmFsdWUpXG4gICAgfSk7XG4gICAgcmV0dXJuIGhhbmRsZUJyZWFrcG9pbnRzKHByb3BzLCBwcm9wcy5yb3dHYXAsIHN0eWxlRnJvbVByb3BWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xucm93R2FwLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB7XG4gIHJvd0dhcDogcmVzcG9uc2l2ZVByb3BUeXBlXG59IDoge307XG5yb3dHYXAuZmlsdGVyUHJvcHMgPSBbJ3Jvd0dhcCddO1xuZXhwb3J0IGNvbnN0IGdyaWRDb2x1bW4gPSBzdHlsZSh7XG4gIHByb3A6ICdncmlkQ29sdW1uJ1xufSk7XG5leHBvcnQgY29uc3QgZ3JpZFJvdyA9IHN0eWxlKHtcbiAgcHJvcDogJ2dyaWRSb3cnXG59KTtcbmV4cG9ydCBjb25zdCBncmlkQXV0b0Zsb3cgPSBzdHlsZSh7XG4gIHByb3A6ICdncmlkQXV0b0Zsb3cnXG59KTtcbmV4cG9ydCBjb25zdCBncmlkQXV0b0NvbHVtbnMgPSBzdHlsZSh7XG4gIHByb3A6ICdncmlkQXV0b0NvbHVtbnMnXG59KTtcbmV4cG9ydCBjb25zdCBncmlkQXV0b1Jvd3MgPSBzdHlsZSh7XG4gIHByb3A6ICdncmlkQXV0b1Jvd3MnXG59KTtcbmV4cG9ydCBjb25zdCBncmlkVGVtcGxhdGVDb2x1bW5zID0gc3R5bGUoe1xuICBwcm9wOiAnZ3JpZFRlbXBsYXRlQ29sdW1ucydcbn0pO1xuZXhwb3J0IGNvbnN0IGdyaWRUZW1wbGF0ZVJvd3MgPSBzdHlsZSh7XG4gIHByb3A6ICdncmlkVGVtcGxhdGVSb3dzJ1xufSk7XG5leHBvcnQgY29uc3QgZ3JpZFRlbXBsYXRlQXJlYXMgPSBzdHlsZSh7XG4gIHByb3A6ICdncmlkVGVtcGxhdGVBcmVhcydcbn0pO1xuZXhwb3J0IGNvbnN0IGdyaWRBcmVhID0gc3R5bGUoe1xuICBwcm9wOiAnZ3JpZEFyZWEnXG59KTtcbmNvbnN0IGdyaWQgPSBjb21wb3NlKGdhcCwgY29sdW1uR2FwLCByb3dHYXAsIGdyaWRDb2x1bW4sIGdyaWRSb3csIGdyaWRBdXRvRmxvdywgZ3JpZEF1dG9Db2x1bW5zLCBncmlkQXV0b1Jvd3MsIGdyaWRUZW1wbGF0ZUNvbHVtbnMsIGdyaWRUZW1wbGF0ZVJvd3MsIGdyaWRUZW1wbGF0ZUFyZWFzLCBncmlkQXJlYSk7XG5leHBvcnQgZGVmYXVsdCBncmlkOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lbW9pemUoZm4pIHtcbiAgY29uc3QgY2FjaGUgPSB7fTtcbiAgcmV0dXJuIGFyZyA9PiB7XG4gICAgaWYgKGNhY2hlW2FyZ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FjaGVbYXJnXSA9IGZuKGFyZyk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZVthcmddO1xuICB9O1xufSIsImltcG9ydCB7IGRlZXBtZXJnZSB9IGZyb20gJ0BtdWkvdXRpbHMnO1xuZnVuY3Rpb24gbWVyZ2UoYWNjLCBpdGVtKSB7XG4gIGlmICghaXRlbSkge1xuICAgIHJldHVybiBhY2M7XG4gIH1cbiAgcmV0dXJuIGRlZXBtZXJnZShhY2MsIGl0ZW0sIHtcbiAgICBjbG9uZTogZmFsc2UgLy8gTm8gbmVlZCB0byBjbG9uZSBkZWVwLCBpdCdzIHdheSBmYXN0ZXIuXG4gIH0pO1xufVxuZXhwb3J0IGRlZmF1bHQgbWVyZ2U7IiwiaW1wb3J0IHN0eWxlIGZyb20gJy4vc3R5bGUnO1xuaW1wb3J0IGNvbXBvc2UgZnJvbSAnLi9jb21wb3NlJztcbmV4cG9ydCBmdW5jdGlvbiBwYWxldHRlVHJhbnNmb3JtKHZhbHVlLCB1c2VyVmFsdWUpIHtcbiAgaWYgKHVzZXJWYWx1ZSA9PT0gJ2dyZXknKSB7XG4gICAgcmV0dXJuIHVzZXJWYWx1ZTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgY29uc3QgY29sb3IgPSBzdHlsZSh7XG4gIHByb3A6ICdjb2xvcicsXG4gIHRoZW1lS2V5OiAncGFsZXR0ZScsXG4gIHRyYW5zZm9ybTogcGFsZXR0ZVRyYW5zZm9ybVxufSk7XG5leHBvcnQgY29uc3QgYmdjb2xvciA9IHN0eWxlKHtcbiAgcHJvcDogJ2JnY29sb3InLFxuICBjc3NQcm9wZXJ0eTogJ2JhY2tncm91bmRDb2xvcicsXG4gIHRoZW1lS2V5OiAncGFsZXR0ZScsXG4gIHRyYW5zZm9ybTogcGFsZXR0ZVRyYW5zZm9ybVxufSk7XG5leHBvcnQgY29uc3QgYmFja2dyb3VuZENvbG9yID0gc3R5bGUoe1xuICBwcm9wOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgdGhlbWVLZXk6ICdwYWxldHRlJyxcbiAgdHJhbnNmb3JtOiBwYWxldHRlVHJhbnNmb3JtXG59KTtcbmNvbnN0IHBhbGV0dGUgPSBjb21wb3NlKGNvbG9yLCBiZ2NvbG9yLCBiYWNrZ3JvdW5kQ29sb3IpO1xuZXhwb3J0IGRlZmF1bHQgcGFsZXR0ZTsiLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuY29uc3QgcmVzcG9uc2l2ZVByb3BUeXBlID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5hcnJheV0pIDoge307XG5leHBvcnQgZGVmYXVsdCByZXNwb25zaXZlUHJvcFR5cGU7IiwiaW1wb3J0IHN0eWxlIGZyb20gJy4vc3R5bGUnO1xuaW1wb3J0IGNvbXBvc2UgZnJvbSAnLi9jb21wb3NlJztcbmltcG9ydCB7IGhhbmRsZUJyZWFrcG9pbnRzLCB2YWx1ZXMgYXMgYnJlYWtwb2ludHNWYWx1ZXMgfSBmcm9tICcuL2JyZWFrcG9pbnRzJztcbmV4cG9ydCBmdW5jdGlvbiBzaXppbmdUcmFuc2Zvcm0odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIDw9IDEgJiYgdmFsdWUgIT09IDAgPyBgJHt2YWx1ZSAqIDEwMH0lYCA6IHZhbHVlO1xufVxuZXhwb3J0IGNvbnN0IHdpZHRoID0gc3R5bGUoe1xuICBwcm9wOiAnd2lkdGgnLFxuICB0cmFuc2Zvcm06IHNpemluZ1RyYW5zZm9ybVxufSk7XG5leHBvcnQgY29uc3QgbWF4V2lkdGggPSBwcm9wcyA9PiB7XG4gIGlmIChwcm9wcy5tYXhXaWR0aCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLm1heFdpZHRoICE9PSBudWxsKSB7XG4gICAgY29uc3Qgc3R5bGVGcm9tUHJvcFZhbHVlID0gcHJvcFZhbHVlID0+IHtcbiAgICAgIHZhciBfcHJvcHMkdGhlbWUsIF9wcm9wcyR0aGVtZTI7XG4gICAgICBjb25zdCBicmVha3BvaW50ID0gKChfcHJvcHMkdGhlbWUgPSBwcm9wcy50aGVtZSkgPT0gbnVsbCB8fCAoX3Byb3BzJHRoZW1lID0gX3Byb3BzJHRoZW1lLmJyZWFrcG9pbnRzKSA9PSBudWxsIHx8IChfcHJvcHMkdGhlbWUgPSBfcHJvcHMkdGhlbWUudmFsdWVzKSA9PSBudWxsID8gdm9pZCAwIDogX3Byb3BzJHRoZW1lW3Byb3BWYWx1ZV0pIHx8IGJyZWFrcG9pbnRzVmFsdWVzW3Byb3BWYWx1ZV07XG4gICAgICBpZiAoIWJyZWFrcG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtYXhXaWR0aDogc2l6aW5nVHJhbnNmb3JtKHByb3BWYWx1ZSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICgoKF9wcm9wcyR0aGVtZTIgPSBwcm9wcy50aGVtZSkgPT0gbnVsbCB8fCAoX3Byb3BzJHRoZW1lMiA9IF9wcm9wcyR0aGVtZTIuYnJlYWtwb2ludHMpID09IG51bGwgPyB2b2lkIDAgOiBfcHJvcHMkdGhlbWUyLnVuaXQpICE9PSAncHgnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWF4V2lkdGg6IGAke2JyZWFrcG9pbnR9JHtwcm9wcy50aGVtZS5icmVha3BvaW50cy51bml0fWBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1heFdpZHRoOiBicmVha3BvaW50XG4gICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIGhhbmRsZUJyZWFrcG9pbnRzKHByb3BzLCBwcm9wcy5tYXhXaWR0aCwgc3R5bGVGcm9tUHJvcFZhbHVlKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5tYXhXaWR0aC5maWx0ZXJQcm9wcyA9IFsnbWF4V2lkdGgnXTtcbmV4cG9ydCBjb25zdCBtaW5XaWR0aCA9IHN0eWxlKHtcbiAgcHJvcDogJ21pbldpZHRoJyxcbiAgdHJhbnNmb3JtOiBzaXppbmdUcmFuc2Zvcm1cbn0pO1xuZXhwb3J0IGNvbnN0IGhlaWdodCA9IHN0eWxlKHtcbiAgcHJvcDogJ2hlaWdodCcsXG4gIHRyYW5zZm9ybTogc2l6aW5nVHJhbnNmb3JtXG59KTtcbmV4cG9ydCBjb25zdCBtYXhIZWlnaHQgPSBzdHlsZSh7XG4gIHByb3A6ICdtYXhIZWlnaHQnLFxuICB0cmFuc2Zvcm06IHNpemluZ1RyYW5zZm9ybVxufSk7XG5leHBvcnQgY29uc3QgbWluSGVpZ2h0ID0gc3R5bGUoe1xuICBwcm9wOiAnbWluSGVpZ2h0JyxcbiAgdHJhbnNmb3JtOiBzaXppbmdUcmFuc2Zvcm1cbn0pO1xuZXhwb3J0IGNvbnN0IHNpemVXaWR0aCA9IHN0eWxlKHtcbiAgcHJvcDogJ3NpemUnLFxuICBjc3NQcm9wZXJ0eTogJ3dpZHRoJyxcbiAgdHJhbnNmb3JtOiBzaXppbmdUcmFuc2Zvcm1cbn0pO1xuZXhwb3J0IGNvbnN0IHNpemVIZWlnaHQgPSBzdHlsZSh7XG4gIHByb3A6ICdzaXplJyxcbiAgY3NzUHJvcGVydHk6ICdoZWlnaHQnLFxuICB0cmFuc2Zvcm06IHNpemluZ1RyYW5zZm9ybVxufSk7XG5leHBvcnQgY29uc3QgYm94U2l6aW5nID0gc3R5bGUoe1xuICBwcm9wOiAnYm94U2l6aW5nJ1xufSk7XG5jb25zdCBzaXppbmcgPSBjb21wb3NlKHdpZHRoLCBtYXhXaWR0aCwgbWluV2lkdGgsIGhlaWdodCwgbWF4SGVpZ2h0LCBtaW5IZWlnaHQsIGJveFNpemluZyk7XG5leHBvcnQgZGVmYXVsdCBzaXppbmc7IiwiaW1wb3J0IHJlc3BvbnNpdmVQcm9wVHlwZSBmcm9tICcuL3Jlc3BvbnNpdmVQcm9wVHlwZSc7XG5pbXBvcnQgeyBoYW5kbGVCcmVha3BvaW50cyB9IGZyb20gJy4vYnJlYWtwb2ludHMnO1xuaW1wb3J0IHsgZ2V0UGF0aCB9IGZyb20gJy4vc3R5bGUnO1xuaW1wb3J0IG1lcmdlIGZyb20gJy4vbWVyZ2UnO1xuaW1wb3J0IG1lbW9pemUgZnJvbSAnLi9tZW1vaXplJztcbmNvbnN0IHByb3BlcnRpZXMgPSB7XG4gIG06ICdtYXJnaW4nLFxuICBwOiAncGFkZGluZydcbn07XG5jb25zdCBkaXJlY3Rpb25zID0ge1xuICB0OiAnVG9wJyxcbiAgcjogJ1JpZ2h0JyxcbiAgYjogJ0JvdHRvbScsXG4gIGw6ICdMZWZ0JyxcbiAgeDogWydMZWZ0JywgJ1JpZ2h0J10sXG4gIHk6IFsnVG9wJywgJ0JvdHRvbSddXG59O1xuY29uc3QgYWxpYXNlcyA9IHtcbiAgbWFyZ2luWDogJ214JyxcbiAgbWFyZ2luWTogJ215JyxcbiAgcGFkZGluZ1g6ICdweCcsXG4gIHBhZGRpbmdZOiAncHknXG59O1xuXG4vLyBtZW1vaXplKCkgaW1wYWN0OlxuLy8gRnJvbSAzMDAsMDAwIG9wcy9zZWNcbi8vIFRvIDM1MCwwMDAgb3BzL3NlY1xuY29uc3QgZ2V0Q3NzUHJvcGVydGllcyA9IG1lbW9pemUocHJvcCA9PiB7XG4gIC8vIEl0J3Mgbm90IGEgc2hvcnRoYW5kIG5vdGF0aW9uLlxuICBpZiAocHJvcC5sZW5ndGggPiAyKSB7XG4gICAgaWYgKGFsaWFzZXNbcHJvcF0pIHtcbiAgICAgIHByb3AgPSBhbGlhc2VzW3Byb3BdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3Byb3BdO1xuICAgIH1cbiAgfVxuICBjb25zdCBbYSwgYl0gPSBwcm9wLnNwbGl0KCcnKTtcbiAgY29uc3QgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2FdO1xuICBjb25zdCBkaXJlY3Rpb24gPSBkaXJlY3Rpb25zW2JdIHx8ICcnO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShkaXJlY3Rpb24pID8gZGlyZWN0aW9uLm1hcChkaXIgPT4gcHJvcGVydHkgKyBkaXIpIDogW3Byb3BlcnR5ICsgZGlyZWN0aW9uXTtcbn0pO1xuZXhwb3J0IGNvbnN0IG1hcmdpbktleXMgPSBbJ20nLCAnbXQnLCAnbXInLCAnbWInLCAnbWwnLCAnbXgnLCAnbXknLCAnbWFyZ2luJywgJ21hcmdpblRvcCcsICdtYXJnaW5SaWdodCcsICdtYXJnaW5Cb3R0b20nLCAnbWFyZ2luTGVmdCcsICdtYXJnaW5YJywgJ21hcmdpblknLCAnbWFyZ2luSW5saW5lJywgJ21hcmdpbklubGluZVN0YXJ0JywgJ21hcmdpbklubGluZUVuZCcsICdtYXJnaW5CbG9jaycsICdtYXJnaW5CbG9ja1N0YXJ0JywgJ21hcmdpbkJsb2NrRW5kJ107XG5leHBvcnQgY29uc3QgcGFkZGluZ0tleXMgPSBbJ3AnLCAncHQnLCAncHInLCAncGInLCAncGwnLCAncHgnLCAncHknLCAncGFkZGluZycsICdwYWRkaW5nVG9wJywgJ3BhZGRpbmdSaWdodCcsICdwYWRkaW5nQm90dG9tJywgJ3BhZGRpbmdMZWZ0JywgJ3BhZGRpbmdYJywgJ3BhZGRpbmdZJywgJ3BhZGRpbmdJbmxpbmUnLCAncGFkZGluZ0lubGluZVN0YXJ0JywgJ3BhZGRpbmdJbmxpbmVFbmQnLCAncGFkZGluZ0Jsb2NrJywgJ3BhZGRpbmdCbG9ja1N0YXJ0JywgJ3BhZGRpbmdCbG9ja0VuZCddO1xuY29uc3Qgc3BhY2luZ0tleXMgPSBbLi4ubWFyZ2luS2V5cywgLi4ucGFkZGluZ0tleXNdO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVVuYXJ5VW5pdCh0aGVtZSwgdGhlbWVLZXksIGRlZmF1bHRWYWx1ZSwgcHJvcE5hbWUpIHtcbiAgdmFyIF9nZXRQYXRoO1xuICBjb25zdCB0aGVtZVNwYWNpbmcgPSAoX2dldFBhdGggPSBnZXRQYXRoKHRoZW1lLCB0aGVtZUtleSwgZmFsc2UpKSAhPSBudWxsID8gX2dldFBhdGggOiBkZWZhdWx0VmFsdWU7XG4gIGlmICh0eXBlb2YgdGhlbWVTcGFjaW5nID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBhYnMgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBhYnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBhYnM7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodHlwZW9mIGFicyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBNVUk6IEV4cGVjdGVkICR7cHJvcE5hbWV9IGFyZ3VtZW50IHRvIGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nLCBnb3QgJHthYnN9LmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhlbWVTcGFjaW5nICogYWJzO1xuICAgIH07XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGhlbWVTcGFjaW5nKSkge1xuICAgIHJldHVybiBhYnMgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBhYnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBhYnM7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoYWJzKSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoW2BNVUk6IFRoZSBcXGB0aGVtZS4ke3RoZW1lS2V5fVxcYCBhcnJheSB0eXBlIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIG5vbiBpbnRlZ2VyIHZhbHVlcy5gICsgYFlvdSBzaG91bGQgZWl0aGVyIHVzZSBhbiBpbnRlZ2VyIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgYXMgaW5kZXgsIG9yIGRlZmluZSB0aGUgXFxgdGhlbWUuJHt0aGVtZUtleX1cXGAgYXMgYSBudW1iZXIuYF0uam9pbignXFxuJykpO1xuICAgICAgICB9IGVsc2UgaWYgKGFicyA+IHRoZW1lU3BhY2luZy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihbYE1VSTogVGhlIHZhbHVlIHByb3ZpZGVkICgke2Fic30pIG92ZXJmbG93cy5gLCBgVGhlIHN1cHBvcnRlZCB2YWx1ZXMgYXJlOiAke0pTT04uc3RyaW5naWZ5KHRoZW1lU3BhY2luZyl9LmAsIGAke2Fic30gPiAke3RoZW1lU3BhY2luZy5sZW5ndGggLSAxfSwgeW91IG5lZWQgdG8gYWRkIHRoZSBtaXNzaW5nIHZhbHVlcy5gXS5qb2luKCdcXG4nKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGVtZVNwYWNpbmdbYWJzXTtcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgdGhlbWVTcGFjaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRoZW1lU3BhY2luZztcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IoW2BNVUk6IFRoZSBcXGB0aGVtZS4ke3RoZW1lS2V5fVxcYCB2YWx1ZSAoJHt0aGVtZVNwYWNpbmd9KSBpcyBpbnZhbGlkLmAsICdJdCBzaG91bGQgYmUgYSBudW1iZXIsIGFuIGFycmF5IG9yIGEgZnVuY3Rpb24uJ10uam9pbignXFxuJykpO1xuICB9XG4gIHJldHVybiAoKSA9PiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVW5hcnlTcGFjaW5nKHRoZW1lKSB7XG4gIHJldHVybiBjcmVhdGVVbmFyeVVuaXQodGhlbWUsICdzcGFjaW5nJywgOCwgJ3NwYWNpbmcnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZSh0cmFuc2Zvcm1lciwgcHJvcFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAnc3RyaW5nJyB8fCBwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBwcm9wVmFsdWU7XG4gIH1cbiAgY29uc3QgYWJzID0gTWF0aC5hYnMocHJvcFZhbHVlKTtcbiAgY29uc3QgdHJhbnNmb3JtZWQgPSB0cmFuc2Zvcm1lcihhYnMpO1xuICBpZiAocHJvcFZhbHVlID49IDApIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiB0cmFuc2Zvcm1lZCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gLXRyYW5zZm9ybWVkO1xuICB9XG4gIHJldHVybiBgLSR7dHJhbnNmb3JtZWR9YDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHlsZUZyb21Qcm9wVmFsdWUoY3NzUHJvcGVydGllcywgdHJhbnNmb3JtZXIpIHtcbiAgcmV0dXJuIHByb3BWYWx1ZSA9PiBjc3NQcm9wZXJ0aWVzLnJlZHVjZSgoYWNjLCBjc3NQcm9wZXJ0eSkgPT4ge1xuICAgIGFjY1tjc3NQcm9wZXJ0eV0gPSBnZXRWYWx1ZSh0cmFuc2Zvcm1lciwgcHJvcFZhbHVlKTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiByZXNvbHZlQ3NzUHJvcGVydHkocHJvcHMsIGtleXMsIHByb3AsIHRyYW5zZm9ybWVyKSB7XG4gIC8vIFVzaW5nIGEgaGFzaCBjb21wdXRhdGlvbiBvdmVyIGFuIGFycmF5IGl0ZXJhdGlvbiBjb3VsZCBiZSBmYXN0ZXIsIGJ1dCB3aXRoIG9ubHkgMjggaXRlbXMsXG4gIC8vIGl0J3MgZG9lc24ndCB3b3J0aCB0aGUgYnVuZGxlIHNpemUuXG4gIGlmIChrZXlzLmluZGV4T2YocHJvcCkgPT09IC0xKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgY3NzUHJvcGVydGllcyA9IGdldENzc1Byb3BlcnRpZXMocHJvcCk7XG4gIGNvbnN0IHN0eWxlRnJvbVByb3BWYWx1ZSA9IGdldFN0eWxlRnJvbVByb3BWYWx1ZShjc3NQcm9wZXJ0aWVzLCB0cmFuc2Zvcm1lcik7XG4gIGNvbnN0IHByb3BWYWx1ZSA9IHByb3BzW3Byb3BdO1xuICByZXR1cm4gaGFuZGxlQnJlYWtwb2ludHMocHJvcHMsIHByb3BWYWx1ZSwgc3R5bGVGcm9tUHJvcFZhbHVlKTtcbn1cbmZ1bmN0aW9uIHN0eWxlKHByb3BzLCBrZXlzKSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVyID0gY3JlYXRlVW5hcnlTcGFjaW5nKHByb3BzLnRoZW1lKTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHByb3BzKS5tYXAocHJvcCA9PiByZXNvbHZlQ3NzUHJvcGVydHkocHJvcHMsIGtleXMsIHByb3AsIHRyYW5zZm9ybWVyKSkucmVkdWNlKG1lcmdlLCB7fSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFyZ2luKHByb3BzKSB7XG4gIHJldHVybiBzdHlsZShwcm9wcywgbWFyZ2luS2V5cyk7XG59XG5tYXJnaW4ucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IG1hcmdpbktleXMucmVkdWNlKChvYmosIGtleSkgPT4ge1xuICBvYmpba2V5XSA9IHJlc3BvbnNpdmVQcm9wVHlwZTtcbiAgcmV0dXJuIG9iajtcbn0sIHt9KSA6IHt9O1xubWFyZ2luLmZpbHRlclByb3BzID0gbWFyZ2luS2V5cztcbmV4cG9ydCBmdW5jdGlvbiBwYWRkaW5nKHByb3BzKSB7XG4gIHJldHVybiBzdHlsZShwcm9wcywgcGFkZGluZ0tleXMpO1xufVxucGFkZGluZy5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcGFkZGluZ0tleXMucmVkdWNlKChvYmosIGtleSkgPT4ge1xuICBvYmpba2V5XSA9IHJlc3BvbnNpdmVQcm9wVHlwZTtcbiAgcmV0dXJuIG9iajtcbn0sIHt9KSA6IHt9O1xucGFkZGluZy5maWx0ZXJQcm9wcyA9IHBhZGRpbmdLZXlzO1xuZnVuY3Rpb24gc3BhY2luZyhwcm9wcykge1xuICByZXR1cm4gc3R5bGUocHJvcHMsIHNwYWNpbmdLZXlzKTtcbn1cbnNwYWNpbmcucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHNwYWNpbmdLZXlzLnJlZHVjZSgob2JqLCBrZXkpID0+IHtcbiAgb2JqW2tleV0gPSByZXNwb25zaXZlUHJvcFR5cGU7XG4gIHJldHVybiBvYmo7XG59LCB7fSkgOiB7fTtcbnNwYWNpbmcuZmlsdGVyUHJvcHMgPSBzcGFjaW5nS2V5cztcbmV4cG9ydCBkZWZhdWx0IHNwYWNpbmc7IiwiaW1wb3J0IHsgdW5zdGFibGVfY2FwaXRhbGl6ZSBhcyBjYXBpdGFsaXplIH0gZnJvbSAnQG11aS91dGlscyc7XG5pbXBvcnQgcmVzcG9uc2l2ZVByb3BUeXBlIGZyb20gJy4vcmVzcG9uc2l2ZVByb3BUeXBlJztcbmltcG9ydCB7IGhhbmRsZUJyZWFrcG9pbnRzIH0gZnJvbSAnLi9icmVha3BvaW50cyc7XG5leHBvcnQgZnVuY3Rpb24gZ2V0UGF0aChvYmosIHBhdGgsIGNoZWNrVmFycyA9IHRydWUpIHtcbiAgaWYgKCFwYXRoIHx8IHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgQ1NTIHZhcmlhYmxlcyBhcmUgdXNlZFxuICBpZiAob2JqICYmIG9iai52YXJzICYmIGNoZWNrVmFycykge1xuICAgIGNvbnN0IHZhbCA9IGB2YXJzLiR7cGF0aH1gLnNwbGl0KCcuJykucmVkdWNlKChhY2MsIGl0ZW0pID0+IGFjYyAmJiBhY2NbaXRlbV0gPyBhY2NbaXRlbV0gOiBudWxsLCBvYmopO1xuICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhdGguc3BsaXQoJy4nKS5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgIGlmIChhY2MgJiYgYWNjW2l0ZW1dICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBhY2NbaXRlbV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LCBvYmopO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0eWxlVmFsdWUodGhlbWVNYXBwaW5nLCB0cmFuc2Zvcm0sIHByb3BWYWx1ZUZpbmFsLCB1c2VyVmFsdWUgPSBwcm9wVmFsdWVGaW5hbCkge1xuICBsZXQgdmFsdWU7XG4gIGlmICh0eXBlb2YgdGhlbWVNYXBwaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsdWUgPSB0aGVtZU1hcHBpbmcocHJvcFZhbHVlRmluYWwpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGhlbWVNYXBwaW5nKSkge1xuICAgIHZhbHVlID0gdGhlbWVNYXBwaW5nW3Byb3BWYWx1ZUZpbmFsXSB8fCB1c2VyVmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBnZXRQYXRoKHRoZW1lTWFwcGluZywgcHJvcFZhbHVlRmluYWwpIHx8IHVzZXJWYWx1ZTtcbiAgfVxuICBpZiAodHJhbnNmb3JtKSB7XG4gICAgdmFsdWUgPSB0cmFuc2Zvcm0odmFsdWUsIHVzZXJWYWx1ZSwgdGhlbWVNYXBwaW5nKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBzdHlsZShvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBwcm9wLFxuICAgIGNzc1Byb3BlcnR5ID0gb3B0aW9ucy5wcm9wLFxuICAgIHRoZW1lS2V5LFxuICAgIHRyYW5zZm9ybVxuICB9ID0gb3B0aW9ucztcblxuICAvLyBmYWxzZSBwb3NpdGl2ZVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZnVuY3Rpb24tY29tcG9uZW50LWRlZmluaXRpb25cbiAgY29uc3QgZm4gPSBwcm9wcyA9PiB7XG4gICAgaWYgKHByb3BzW3Byb3BdID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwcm9wVmFsdWUgPSBwcm9wc1twcm9wXTtcbiAgICBjb25zdCB0aGVtZSA9IHByb3BzLnRoZW1lO1xuICAgIGNvbnN0IHRoZW1lTWFwcGluZyA9IGdldFBhdGgodGhlbWUsIHRoZW1lS2V5KSB8fCB7fTtcbiAgICBjb25zdCBzdHlsZUZyb21Qcm9wVmFsdWUgPSBwcm9wVmFsdWVGaW5hbCA9PiB7XG4gICAgICBsZXQgdmFsdWUgPSBnZXRTdHlsZVZhbHVlKHRoZW1lTWFwcGluZywgdHJhbnNmb3JtLCBwcm9wVmFsdWVGaW5hbCk7XG4gICAgICBpZiAocHJvcFZhbHVlRmluYWwgPT09IHZhbHVlICYmIHR5cGVvZiBwcm9wVmFsdWVGaW5hbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gSGF2ZW4ndCBmb3VuZCB2YWx1ZVxuICAgICAgICB2YWx1ZSA9IGdldFN0eWxlVmFsdWUodGhlbWVNYXBwaW5nLCB0cmFuc2Zvcm0sIGAke3Byb3B9JHtwcm9wVmFsdWVGaW5hbCA9PT0gJ2RlZmF1bHQnID8gJycgOiBjYXBpdGFsaXplKHByb3BWYWx1ZUZpbmFsKX1gLCBwcm9wVmFsdWVGaW5hbCk7XG4gICAgICB9XG4gICAgICBpZiAoY3NzUHJvcGVydHkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtjc3NQcm9wZXJ0eV06IHZhbHVlXG4gICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIGhhbmRsZUJyZWFrcG9pbnRzKHByb3BzLCBwcm9wVmFsdWUsIHN0eWxlRnJvbVByb3BWYWx1ZSk7XG4gIH07XG4gIGZuLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB7XG4gICAgW3Byb3BdOiByZXNwb25zaXZlUHJvcFR5cGVcbiAgfSA6IHt9O1xuICBmbi5maWx0ZXJQcm9wcyA9IFtwcm9wXTtcbiAgcmV0dXJuIGZuO1xufVxuZXhwb3J0IGRlZmF1bHQgc3R5bGU7IiwiaW1wb3J0IHsgcGFkZGluZywgbWFyZ2luIH0gZnJvbSAnLi4vc3BhY2luZyc7XG5pbXBvcnQgeyBib3JkZXJSYWRpdXMsIGJvcmRlclRyYW5zZm9ybSB9IGZyb20gJy4uL2JvcmRlcnMnO1xuaW1wb3J0IHsgZ2FwLCByb3dHYXAsIGNvbHVtbkdhcCB9IGZyb20gJy4uL2Nzc0dyaWQnO1xuaW1wb3J0IHsgcGFsZXR0ZVRyYW5zZm9ybSB9IGZyb20gJy4uL3BhbGV0dGUnO1xuaW1wb3J0IHsgbWF4V2lkdGgsIHNpemluZ1RyYW5zZm9ybSB9IGZyb20gJy4uL3NpemluZyc7XG5jb25zdCBkZWZhdWx0U3hDb25maWcgPSB7XG4gIC8vIGJvcmRlcnNcbiAgYm9yZGVyOiB7XG4gICAgdGhlbWVLZXk6ICdib3JkZXJzJyxcbiAgICB0cmFuc2Zvcm06IGJvcmRlclRyYW5zZm9ybVxuICB9LFxuICBib3JkZXJUb3A6IHtcbiAgICB0aGVtZUtleTogJ2JvcmRlcnMnLFxuICAgIHRyYW5zZm9ybTogYm9yZGVyVHJhbnNmb3JtXG4gIH0sXG4gIGJvcmRlclJpZ2h0OiB7XG4gICAgdGhlbWVLZXk6ICdib3JkZXJzJyxcbiAgICB0cmFuc2Zvcm06IGJvcmRlclRyYW5zZm9ybVxuICB9LFxuICBib3JkZXJCb3R0b206IHtcbiAgICB0aGVtZUtleTogJ2JvcmRlcnMnLFxuICAgIHRyYW5zZm9ybTogYm9yZGVyVHJhbnNmb3JtXG4gIH0sXG4gIGJvcmRlckxlZnQ6IHtcbiAgICB0aGVtZUtleTogJ2JvcmRlcnMnLFxuICAgIHRyYW5zZm9ybTogYm9yZGVyVHJhbnNmb3JtXG4gIH0sXG4gIGJvcmRlckNvbG9yOiB7XG4gICAgdGhlbWVLZXk6ICdwYWxldHRlJ1xuICB9LFxuICBib3JkZXJUb3BDb2xvcjoge1xuICAgIHRoZW1lS2V5OiAncGFsZXR0ZSdcbiAgfSxcbiAgYm9yZGVyUmlnaHRDb2xvcjoge1xuICAgIHRoZW1lS2V5OiAncGFsZXR0ZSdcbiAgfSxcbiAgYm9yZGVyQm90dG9tQ29sb3I6IHtcbiAgICB0aGVtZUtleTogJ3BhbGV0dGUnXG4gIH0sXG4gIGJvcmRlckxlZnRDb2xvcjoge1xuICAgIHRoZW1lS2V5OiAncGFsZXR0ZSdcbiAgfSxcbiAgb3V0bGluZToge1xuICAgIHRoZW1lS2V5OiAnYm9yZGVycycsXG4gICAgdHJhbnNmb3JtOiBib3JkZXJUcmFuc2Zvcm1cbiAgfSxcbiAgb3V0bGluZUNvbG9yOiB7XG4gICAgdGhlbWVLZXk6ICdwYWxldHRlJ1xuICB9LFxuICBib3JkZXJSYWRpdXM6IHtcbiAgICB0aGVtZUtleTogJ3NoYXBlLmJvcmRlclJhZGl1cycsXG4gICAgc3R5bGU6IGJvcmRlclJhZGl1c1xuICB9LFxuICAvLyBwYWxldHRlXG4gIGNvbG9yOiB7XG4gICAgdGhlbWVLZXk6ICdwYWxldHRlJyxcbiAgICB0cmFuc2Zvcm06IHBhbGV0dGVUcmFuc2Zvcm1cbiAgfSxcbiAgYmdjb2xvcjoge1xuICAgIHRoZW1lS2V5OiAncGFsZXR0ZScsXG4gICAgY3NzUHJvcGVydHk6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICAgIHRyYW5zZm9ybTogcGFsZXR0ZVRyYW5zZm9ybVxuICB9LFxuICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICB0aGVtZUtleTogJ3BhbGV0dGUnLFxuICAgIHRyYW5zZm9ybTogcGFsZXR0ZVRyYW5zZm9ybVxuICB9LFxuICAvLyBzcGFjaW5nXG4gIHA6IHtcbiAgICBzdHlsZTogcGFkZGluZ1xuICB9LFxuICBwdDoge1xuICAgIHN0eWxlOiBwYWRkaW5nXG4gIH0sXG4gIHByOiB7XG4gICAgc3R5bGU6IHBhZGRpbmdcbiAgfSxcbiAgcGI6IHtcbiAgICBzdHlsZTogcGFkZGluZ1xuICB9LFxuICBwbDoge1xuICAgIHN0eWxlOiBwYWRkaW5nXG4gIH0sXG4gIHB4OiB7XG4gICAgc3R5bGU6IHBhZGRpbmdcbiAgfSxcbiAgcHk6IHtcbiAgICBzdHlsZTogcGFkZGluZ1xuICB9LFxuICBwYWRkaW5nOiB7XG4gICAgc3R5bGU6IHBhZGRpbmdcbiAgfSxcbiAgcGFkZGluZ1RvcDoge1xuICAgIHN0eWxlOiBwYWRkaW5nXG4gIH0sXG4gIHBhZGRpbmdSaWdodDoge1xuICAgIHN0eWxlOiBwYWRkaW5nXG4gIH0sXG4gIHBhZGRpbmdCb3R0b206IHtcbiAgICBzdHlsZTogcGFkZGluZ1xuICB9LFxuICBwYWRkaW5nTGVmdDoge1xuICAgIHN0eWxlOiBwYWRkaW5nXG4gIH0sXG4gIHBhZGRpbmdYOiB7XG4gICAgc3R5bGU6IHBhZGRpbmdcbiAgfSxcbiAgcGFkZGluZ1k6IHtcbiAgICBzdHlsZTogcGFkZGluZ1xuICB9LFxuICBwYWRkaW5nSW5saW5lOiB7XG4gICAgc3R5bGU6IHBhZGRpbmdcbiAgfSxcbiAgcGFkZGluZ0lubGluZVN0YXJ0OiB7XG4gICAgc3R5bGU6IHBhZGRpbmdcbiAgfSxcbiAgcGFkZGluZ0lubGluZUVuZDoge1xuICAgIHN0eWxlOiBwYWRkaW5nXG4gIH0sXG4gIHBhZGRpbmdCbG9jazoge1xuICAgIHN0eWxlOiBwYWRkaW5nXG4gIH0sXG4gIHBhZGRpbmdCbG9ja1N0YXJ0OiB7XG4gICAgc3R5bGU6IHBhZGRpbmdcbiAgfSxcbiAgcGFkZGluZ0Jsb2NrRW5kOiB7XG4gICAgc3R5bGU6IHBhZGRpbmdcbiAgfSxcbiAgbToge1xuICAgIHN0eWxlOiBtYXJnaW5cbiAgfSxcbiAgbXQ6IHtcbiAgICBzdHlsZTogbWFyZ2luXG4gIH0sXG4gIG1yOiB7XG4gICAgc3R5bGU6IG1hcmdpblxuICB9LFxuICBtYjoge1xuICAgIHN0eWxlOiBtYXJnaW5cbiAgfSxcbiAgbWw6IHtcbiAgICBzdHlsZTogbWFyZ2luXG4gIH0sXG4gIG14OiB7XG4gICAgc3R5bGU6IG1hcmdpblxuICB9LFxuICBteToge1xuICAgIHN0eWxlOiBtYXJnaW5cbiAgfSxcbiAgbWFyZ2luOiB7XG4gICAgc3R5bGU6IG1hcmdpblxuICB9LFxuICBtYXJnaW5Ub3A6IHtcbiAgICBzdHlsZTogbWFyZ2luXG4gIH0sXG4gIG1hcmdpblJpZ2h0OiB7XG4gICAgc3R5bGU6IG1hcmdpblxuICB9LFxuICBtYXJnaW5Cb3R0b206IHtcbiAgICBzdHlsZTogbWFyZ2luXG4gIH0sXG4gIG1hcmdpbkxlZnQ6IHtcbiAgICBzdHlsZTogbWFyZ2luXG4gIH0sXG4gIG1hcmdpblg6IHtcbiAgICBzdHlsZTogbWFyZ2luXG4gIH0sXG4gIG1hcmdpblk6IHtcbiAgICBzdHlsZTogbWFyZ2luXG4gIH0sXG4gIG1hcmdpbklubGluZToge1xuICAgIHN0eWxlOiBtYXJnaW5cbiAgfSxcbiAgbWFyZ2luSW5saW5lU3RhcnQ6IHtcbiAgICBzdHlsZTogbWFyZ2luXG4gIH0sXG4gIG1hcmdpbklubGluZUVuZDoge1xuICAgIHN0eWxlOiBtYXJnaW5cbiAgfSxcbiAgbWFyZ2luQmxvY2s6IHtcbiAgICBzdHlsZTogbWFyZ2luXG4gIH0sXG4gIG1hcmdpbkJsb2NrU3RhcnQ6IHtcbiAgICBzdHlsZTogbWFyZ2luXG4gIH0sXG4gIG1hcmdpbkJsb2NrRW5kOiB7XG4gICAgc3R5bGU6IG1hcmdpblxuICB9LFxuICAvLyBkaXNwbGF5XG4gIGRpc3BsYXlQcmludDoge1xuICAgIGNzc1Byb3BlcnR5OiBmYWxzZSxcbiAgICB0cmFuc2Zvcm06IHZhbHVlID0+ICh7XG4gICAgICAnQG1lZGlhIHByaW50Jzoge1xuICAgICAgICBkaXNwbGF5OiB2YWx1ZVxuICAgICAgfVxuICAgIH0pXG4gIH0sXG4gIGRpc3BsYXk6IHt9LFxuICBvdmVyZmxvdzoge30sXG4gIHRleHRPdmVyZmxvdzoge30sXG4gIHZpc2liaWxpdHk6IHt9LFxuICB3aGl0ZVNwYWNlOiB7fSxcbiAgLy8gZmxleGJveFxuICBmbGV4QmFzaXM6IHt9LFxuICBmbGV4RGlyZWN0aW9uOiB7fSxcbiAgZmxleFdyYXA6IHt9LFxuICBqdXN0aWZ5Q29udGVudDoge30sXG4gIGFsaWduSXRlbXM6IHt9LFxuICBhbGlnbkNvbnRlbnQ6IHt9LFxuICBvcmRlcjoge30sXG4gIGZsZXg6IHt9LFxuICBmbGV4R3Jvdzoge30sXG4gIGZsZXhTaHJpbms6IHt9LFxuICBhbGlnblNlbGY6IHt9LFxuICBqdXN0aWZ5SXRlbXM6IHt9LFxuICBqdXN0aWZ5U2VsZjoge30sXG4gIC8vIGdyaWRcbiAgZ2FwOiB7XG4gICAgc3R5bGU6IGdhcFxuICB9LFxuICByb3dHYXA6IHtcbiAgICBzdHlsZTogcm93R2FwXG4gIH0sXG4gIGNvbHVtbkdhcDoge1xuICAgIHN0eWxlOiBjb2x1bW5HYXBcbiAgfSxcbiAgZ3JpZENvbHVtbjoge30sXG4gIGdyaWRSb3c6IHt9LFxuICBncmlkQXV0b0Zsb3c6IHt9LFxuICBncmlkQXV0b0NvbHVtbnM6IHt9LFxuICBncmlkQXV0b1Jvd3M6IHt9LFxuICBncmlkVGVtcGxhdGVDb2x1bW5zOiB7fSxcbiAgZ3JpZFRlbXBsYXRlUm93czoge30sXG4gIGdyaWRUZW1wbGF0ZUFyZWFzOiB7fSxcbiAgZ3JpZEFyZWE6IHt9LFxuICAvLyBwb3NpdGlvbnNcbiAgcG9zaXRpb246IHt9LFxuICB6SW5kZXg6IHtcbiAgICB0aGVtZUtleTogJ3pJbmRleCdcbiAgfSxcbiAgdG9wOiB7fSxcbiAgcmlnaHQ6IHt9LFxuICBib3R0b206IHt9LFxuICBsZWZ0OiB7fSxcbiAgLy8gc2hhZG93c1xuICBib3hTaGFkb3c6IHtcbiAgICB0aGVtZUtleTogJ3NoYWRvd3MnXG4gIH0sXG4gIC8vIHNpemluZ1xuICB3aWR0aDoge1xuICAgIHRyYW5zZm9ybTogc2l6aW5nVHJhbnNmb3JtXG4gIH0sXG4gIG1heFdpZHRoOiB7XG4gICAgc3R5bGU6IG1heFdpZHRoXG4gIH0sXG4gIG1pbldpZHRoOiB7XG4gICAgdHJhbnNmb3JtOiBzaXppbmdUcmFuc2Zvcm1cbiAgfSxcbiAgaGVpZ2h0OiB7XG4gICAgdHJhbnNmb3JtOiBzaXppbmdUcmFuc2Zvcm1cbiAgfSxcbiAgbWF4SGVpZ2h0OiB7XG4gICAgdHJhbnNmb3JtOiBzaXppbmdUcmFuc2Zvcm1cbiAgfSxcbiAgbWluSGVpZ2h0OiB7XG4gICAgdHJhbnNmb3JtOiBzaXppbmdUcmFuc2Zvcm1cbiAgfSxcbiAgYm94U2l6aW5nOiB7fSxcbiAgLy8gdHlwb2dyYXBoeVxuICBmb250RmFtaWx5OiB7XG4gICAgdGhlbWVLZXk6ICd0eXBvZ3JhcGh5J1xuICB9LFxuICBmb250U2l6ZToge1xuICAgIHRoZW1lS2V5OiAndHlwb2dyYXBoeSdcbiAgfSxcbiAgZm9udFN0eWxlOiB7XG4gICAgdGhlbWVLZXk6ICd0eXBvZ3JhcGh5J1xuICB9LFxuICBmb250V2VpZ2h0OiB7XG4gICAgdGhlbWVLZXk6ICd0eXBvZ3JhcGh5J1xuICB9LFxuICBsZXR0ZXJTcGFjaW5nOiB7fSxcbiAgdGV4dFRyYW5zZm9ybToge30sXG4gIGxpbmVIZWlnaHQ6IHt9LFxuICB0ZXh0QWxpZ246IHt9LFxuICB0eXBvZ3JhcGh5OiB7XG4gICAgY3NzUHJvcGVydHk6IGZhbHNlLFxuICAgIHRoZW1lS2V5OiAndHlwb2dyYXBoeSdcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IGRlZmF1bHRTeENvbmZpZzsiLCJpbXBvcnQgeyB1bnN0YWJsZV9jYXBpdGFsaXplIGFzIGNhcGl0YWxpemUgfSBmcm9tICdAbXVpL3V0aWxzJztcbmltcG9ydCBtZXJnZSBmcm9tICcuLi9tZXJnZSc7XG5pbXBvcnQgeyBnZXRQYXRoLCBnZXRTdHlsZVZhbHVlIGFzIGdldFZhbHVlIH0gZnJvbSAnLi4vc3R5bGUnO1xuaW1wb3J0IHsgaGFuZGxlQnJlYWtwb2ludHMsIGNyZWF0ZUVtcHR5QnJlYWtwb2ludE9iamVjdCwgcmVtb3ZlVW51c2VkQnJlYWtwb2ludHMgfSBmcm9tICcuLi9icmVha3BvaW50cyc7XG5pbXBvcnQgZGVmYXVsdFN4Q29uZmlnIGZyb20gJy4vZGVmYXVsdFN4Q29uZmlnJztcbmZ1bmN0aW9uIG9iamVjdHNIYXZlU2FtZUtleXMoLi4ub2JqZWN0cykge1xuICBjb25zdCBhbGxLZXlzID0gb2JqZWN0cy5yZWR1Y2UoKGtleXMsIG9iamVjdCkgPT4ga2V5cy5jb25jYXQoT2JqZWN0LmtleXMob2JqZWN0KSksIFtdKTtcbiAgY29uc3QgdW5pb24gPSBuZXcgU2V0KGFsbEtleXMpO1xuICByZXR1cm4gb2JqZWN0cy5ldmVyeShvYmplY3QgPT4gdW5pb24uc2l6ZSA9PT0gT2JqZWN0LmtleXMob2JqZWN0KS5sZW5ndGgpO1xufVxuZnVuY3Rpb24gY2FsbElmRm4obWF5YmVGbiwgYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgbWF5YmVGbiA9PT0gJ2Z1bmN0aW9uJyA/IG1heWJlRm4oYXJnKSA6IG1heWJlRm47XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBmdW5jdGlvbiB1bnN0YWJsZV9jcmVhdGVTdHlsZUZ1bmN0aW9uU3goKSB7XG4gIGZ1bmN0aW9uIGdldFRoZW1lVmFsdWUocHJvcCwgdmFsLCB0aGVtZSwgY29uZmlnKSB7XG4gICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICBbcHJvcF06IHZhbCxcbiAgICAgIHRoZW1lXG4gICAgfTtcbiAgICBjb25zdCBvcHRpb25zID0gY29uZmlnW3Byb3BdO1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW3Byb3BdOiB2YWxcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNzc1Byb3BlcnR5ID0gcHJvcCxcbiAgICAgIHRoZW1lS2V5LFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgc3R5bGVcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFRPRE8gdjY6IHJlbW92ZSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tdWkvbWF0ZXJpYWwtdWkvcHVsbC8zODEyM1xuICAgIGlmICh0aGVtZUtleSA9PT0gJ3R5cG9ncmFwaHknICYmIHZhbCA9PT0gJ2luaGVyaXQnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbcHJvcF06IHZhbFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdGhlbWVNYXBwaW5nID0gZ2V0UGF0aCh0aGVtZSwgdGhlbWVLZXkpIHx8IHt9O1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgcmV0dXJuIHN0eWxlKHByb3BzKTtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGVGcm9tUHJvcFZhbHVlID0gcHJvcFZhbHVlRmluYWwgPT4ge1xuICAgICAgbGV0IHZhbHVlID0gZ2V0VmFsdWUodGhlbWVNYXBwaW5nLCB0cmFuc2Zvcm0sIHByb3BWYWx1ZUZpbmFsKTtcbiAgICAgIGlmIChwcm9wVmFsdWVGaW5hbCA9PT0gdmFsdWUgJiYgdHlwZW9mIHByb3BWYWx1ZUZpbmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBIYXZlbid0IGZvdW5kIHZhbHVlXG4gICAgICAgIHZhbHVlID0gZ2V0VmFsdWUodGhlbWVNYXBwaW5nLCB0cmFuc2Zvcm0sIGAke3Byb3B9JHtwcm9wVmFsdWVGaW5hbCA9PT0gJ2RlZmF1bHQnID8gJycgOiBjYXBpdGFsaXplKHByb3BWYWx1ZUZpbmFsKX1gLCBwcm9wVmFsdWVGaW5hbCk7XG4gICAgICB9XG4gICAgICBpZiAoY3NzUHJvcGVydHkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtjc3NQcm9wZXJ0eV06IHZhbHVlXG4gICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIGhhbmRsZUJyZWFrcG9pbnRzKHByb3BzLCB2YWwsIHN0eWxlRnJvbVByb3BWYWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gc3R5bGVGdW5jdGlvblN4KHByb3BzKSB7XG4gICAgdmFyIF90aGVtZSR1bnN0YWJsZV9zeENvbjtcbiAgICBjb25zdCB7XG4gICAgICBzeCxcbiAgICAgIHRoZW1lID0ge31cbiAgICB9ID0gcHJvcHMgfHwge307XG4gICAgaWYgKCFzeCkge1xuICAgICAgcmV0dXJuIG51bGw7IC8vIEVtb3Rpb24gJiBzdHlsZWQtY29tcG9uZW50cyB3aWxsIG5lZ2xlY3QgbnVsbFxuICAgIH1cbiAgICBjb25zdCBjb25maWcgPSAoX3RoZW1lJHVuc3RhYmxlX3N4Q29uID0gdGhlbWUudW5zdGFibGVfc3hDb25maWcpICE9IG51bGwgPyBfdGhlbWUkdW5zdGFibGVfc3hDb24gOiBkZWZhdWx0U3hDb25maWc7XG5cbiAgICAvKlxuICAgICAqIFJlY2VpdmUgYHN4SW5wdXRgIGFzIG9iamVjdCBvciBjYWxsYmFja1xuICAgICAqIGFuZCB0aGVuIHJlY3Vyc2l2ZWx5IGNoZWNrIGtleXMgJiB2YWx1ZXMgdG8gY3JlYXRlIG1lZGlhIHF1ZXJ5IG9iamVjdCBzdHlsZXMuXG4gICAgICogKHRoZSByZXN1bHQgd2lsbCBiZSB1c2VkIGluIGBzdHlsZWRgKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYXZlcnNlKHN4SW5wdXQpIHtcbiAgICAgIGxldCBzeE9iamVjdCA9IHN4SW5wdXQ7XG4gICAgICBpZiAodHlwZW9mIHN4SW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc3hPYmplY3QgPSBzeElucHV0KHRoZW1lKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN4SW5wdXQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIHZhbHVlXG4gICAgICAgIHJldHVybiBzeElucHV0O1xuICAgICAgfVxuICAgICAgaWYgKCFzeE9iamVjdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVtcHR5QnJlYWtwb2ludHMgPSBjcmVhdGVFbXB0eUJyZWFrcG9pbnRPYmplY3QodGhlbWUuYnJlYWtwb2ludHMpO1xuICAgICAgY29uc3QgYnJlYWtwb2ludHNLZXlzID0gT2JqZWN0LmtleXMoZW1wdHlCcmVha3BvaW50cyk7XG4gICAgICBsZXQgY3NzID0gZW1wdHlCcmVha3BvaW50cztcbiAgICAgIE9iamVjdC5rZXlzKHN4T2JqZWN0KS5mb3JFYWNoKHN0eWxlS2V5ID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjYWxsSWZGbihzeE9iamVjdFtzdHlsZUtleV0sIHRoZW1lKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKGNvbmZpZ1tzdHlsZUtleV0pIHtcbiAgICAgICAgICAgICAgY3NzID0gbWVyZ2UoY3NzLCBnZXRUaGVtZVZhbHVlKHN0eWxlS2V5LCB2YWx1ZSwgdGhlbWUsIGNvbmZpZykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgYnJlYWtwb2ludHNWYWx1ZXMgPSBoYW5kbGVCcmVha3BvaW50cyh7XG4gICAgICAgICAgICAgICAgdGhlbWVcbiAgICAgICAgICAgICAgfSwgdmFsdWUsIHggPT4gKHtcbiAgICAgICAgICAgICAgICBbc3R5bGVLZXldOiB4XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgaWYgKG9iamVjdHNIYXZlU2FtZUtleXMoYnJlYWtwb2ludHNWYWx1ZXMsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNzc1tzdHlsZUtleV0gPSBzdHlsZUZ1bmN0aW9uU3goe1xuICAgICAgICAgICAgICAgICAgc3g6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgdGhlbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjc3MgPSBtZXJnZShjc3MsIGJyZWFrcG9pbnRzVmFsdWVzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjc3MgPSBtZXJnZShjc3MsIGdldFRoZW1lVmFsdWUoc3R5bGVLZXksIHZhbHVlLCB0aGVtZSwgY29uZmlnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZW1vdmVVbnVzZWRCcmVha3BvaW50cyhicmVha3BvaW50c0tleXMsIGNzcyk7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHN4KSA/IHN4Lm1hcCh0cmF2ZXJzZSkgOiB0cmF2ZXJzZShzeCk7XG4gIH1cbiAgcmV0dXJuIHN0eWxlRnVuY3Rpb25TeDtcbn1cbmNvbnN0IHN0eWxlRnVuY3Rpb25TeCA9IHVuc3RhYmxlX2NyZWF0ZVN0eWxlRnVuY3Rpb25TeCgpO1xuc3R5bGVGdW5jdGlvblN4LmZpbHRlclByb3BzID0gWydzeCddO1xuZXhwb3J0IGRlZmF1bHQgc3R5bGVGdW5jdGlvblN4OyIsImNvbnN0IGRlZmF1bHRHZW5lcmF0b3IgPSBjb21wb25lbnROYW1lID0+IGNvbXBvbmVudE5hbWU7XG5jb25zdCBjcmVhdGVDbGFzc05hbWVHZW5lcmF0b3IgPSAoKSA9PiB7XG4gIGxldCBnZW5lcmF0ZSA9IGRlZmF1bHRHZW5lcmF0b3I7XG4gIHJldHVybiB7XG4gICAgY29uZmlndXJlKGdlbmVyYXRvcikge1xuICAgICAgZ2VuZXJhdGUgPSBnZW5lcmF0b3I7XG4gICAgfSxcbiAgICBnZW5lcmF0ZShjb21wb25lbnROYW1lKSB7XG4gICAgICByZXR1cm4gZ2VuZXJhdGUoY29tcG9uZW50TmFtZSk7XG4gICAgfSxcbiAgICByZXNldCgpIHtcbiAgICAgIGdlbmVyYXRlID0gZGVmYXVsdEdlbmVyYXRvcjtcbiAgICB9XG4gIH07XG59O1xuY29uc3QgQ2xhc3NOYW1lR2VuZXJhdG9yID0gY3JlYXRlQ2xhc3NOYW1lR2VuZXJhdG9yKCk7XG5leHBvcnQgZGVmYXVsdCBDbGFzc05hbWVHZW5lcmF0b3I7IiwiaW1wb3J0IF9mb3JtYXRNdWlFcnJvck1lc3NhZ2UgZnJvbSBcIkBtdWkvdXRpbHMvZm9ybWF0TXVpRXJyb3JNZXNzYWdlXCI7XG4vLyBJdCBzaG91bGQgdG8gYmUgbm90ZWQgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzbid0IGVxdWl2YWxlbnQgdG8gYHRleHQtdHJhbnNmb3JtOiBjYXBpdGFsaXplYC5cbi8vXG4vLyBBIHN0cmljdCBjYXBpdGFsaXphdGlvbiBzaG91bGQgdXBwZXJjYXNlIHRoZSBmaXJzdCBsZXR0ZXIgb2YgZWFjaCB3b3JkIGluIHRoZSBzZW50ZW5jZS5cbi8vIFdlIG9ubHkgaGFuZGxlIHRoZSBmaXJzdCB3b3JkLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGBNVUk6IFxcYGNhcGl0YWxpemUoc3RyaW5nKVxcYCBleHBlY3RzIGEgc3RyaW5nIGFyZ3VtZW50LmAgOiBfZm9ybWF0TXVpRXJyb3JNZXNzYWdlKDcpKTtcbiAgfVxuICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xufSIsImZ1bmN0aW9uIGNsYW1wKHZhbCwgbWluID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsIG1heCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKHZhbCwgbWF4KSk7XG59XG5leHBvcnQgZGVmYXVsdCBjbGFtcDsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvaXMtcGxhaW4tb2JqL2Jsb2IvbWFpbi9pbmRleC5qc1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoaXRlbSkge1xuICBpZiAodHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnIHx8IGl0ZW0gPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGl0ZW0pO1xuICByZXR1cm4gKHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGUgfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSkgPT09IG51bGwpICYmICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGl0ZW0pICYmICEoU3ltYm9sLml0ZXJhdG9yIGluIGl0ZW0pO1xufVxuZnVuY3Rpb24gZGVlcENsb25lKHNvdXJjZSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cbiAgY29uc3Qgb3V0cHV0ID0ge307XG4gIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgIG91dHB1dFtrZXldID0gZGVlcENsb25lKHNvdXJjZVtrZXldKTtcbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWVwbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMgPSB7XG4gIGNsb25lOiB0cnVlXG59KSB7XG4gIGNvbnN0IG91dHB1dCA9IG9wdGlvbnMuY2xvbmUgPyBfZXh0ZW5kcyh7fSwgdGFyZ2V0KSA6IHRhcmdldDtcbiAgaWYgKGlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiBpc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIC8vIEF2b2lkIHByb3RvdHlwZSBwb2xsdXRpb25cbiAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSAmJiBrZXkgaW4gdGFyZ2V0ICYmIGlzUGxhaW5PYmplY3QodGFyZ2V0W2tleV0pKSB7XG4gICAgICAgIC8vIFNpbmNlIGBvdXRwdXRgIGlzIGEgY2xvbmUgb2YgYHRhcmdldGAgYW5kIHdlIGhhdmUgbmFycm93ZWQgYHRhcmdldGAgaW4gdGhpcyBibG9jayB3ZSBjYW4gY2FzdCB0byB0aGUgc2FtZSB0eXBlLlxuICAgICAgICBvdXRwdXRba2V5XSA9IGRlZXBtZXJnZSh0YXJnZXRba2V5XSwgc291cmNlW2tleV0sIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmNsb25lKSB7XG4gICAgICAgIG91dHB1dFtrZXldID0gaXNQbGFpbk9iamVjdChzb3VyY2Vba2V5XSkgPyBkZWVwQ2xvbmUoc291cmNlW2tleV0pIDogc291cmNlW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59IiwiaW1wb3J0IENsYXNzTmFtZUdlbmVyYXRvciBmcm9tICcuLi9DbGFzc05hbWVHZW5lcmF0b3InO1xuZXhwb3J0IGNvbnN0IGdsb2JhbFN0YXRlQ2xhc3NlcyA9IHtcbiAgYWN0aXZlOiAnYWN0aXZlJyxcbiAgY2hlY2tlZDogJ2NoZWNrZWQnLFxuICBjb21wbGV0ZWQ6ICdjb21wbGV0ZWQnLFxuICBkaXNhYmxlZDogJ2Rpc2FibGVkJyxcbiAgZXJyb3I6ICdlcnJvcicsXG4gIGV4cGFuZGVkOiAnZXhwYW5kZWQnLFxuICBmb2N1c2VkOiAnZm9jdXNlZCcsXG4gIGZvY3VzVmlzaWJsZTogJ2ZvY3VzVmlzaWJsZScsXG4gIG9wZW46ICdvcGVuJyxcbiAgcmVhZE9ubHk6ICdyZWFkT25seScsXG4gIHJlcXVpcmVkOiAncmVxdWlyZWQnLFxuICBzZWxlY3RlZDogJ3NlbGVjdGVkJ1xufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdlbmVyYXRlVXRpbGl0eUNsYXNzKGNvbXBvbmVudE5hbWUsIHNsb3QsIGdsb2JhbFN0YXRlUHJlZml4ID0gJ011aScpIHtcbiAgY29uc3QgZ2xvYmFsU3RhdGVDbGFzcyA9IGdsb2JhbFN0YXRlQ2xhc3Nlc1tzbG90XTtcbiAgcmV0dXJuIGdsb2JhbFN0YXRlQ2xhc3MgPyBgJHtnbG9iYWxTdGF0ZVByZWZpeH0tJHtnbG9iYWxTdGF0ZUNsYXNzfWAgOiBgJHtDbGFzc05hbWVHZW5lcmF0b3IuZ2VuZXJhdGUoY29tcG9uZW50TmFtZSl9LSR7c2xvdH1gO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzR2xvYmFsU3RhdGUoc2xvdCkge1xuICByZXR1cm4gZ2xvYmFsU3RhdGVDbGFzc2VzW3Nsb3RdICE9PSB1bmRlZmluZWQ7XG59IiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB2YXIgaGFzID0gcmVxdWlyZSgnLi9saWIvaGFzJyk7XG5cbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHsgLyoqLyB9XG4gIH07XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICtcbiAgICAgICAgICAgICAgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJyArXG4gICAgICAgICAgICBsb2NhdGlvbiArICcgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgK1xuICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ZhaWxlZCAnICsgbG9jYXRpb24gKyAnIHR5cGU6ICcgKyBlcnJvci5tZXNzYWdlICsgKHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNldHMgd2FybmluZyBjYWNoZSB3aGVuIHRlc3RpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9saWIvaGFzJyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBiaWdpbnQ6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdiaWdpbnQnKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBlbGVtZW50VHlwZTogY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSwgZGF0YSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5kYXRhID0gZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgPyBkYXRhOiB7fTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBwcm9wIG9uIGAnICsgY29tcG9uZW50TmFtZSArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSxcbiAgICAgICAgICB7ZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGV9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIHZhciBjaGVja2VyUmVzdWx0ID0gY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGNoZWNrZXJSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja2VyUmVzdWx0LmRhdGEgJiYgaGFzKGNoZWNrZXJSZXN1bHQuZGF0YSwgJ2V4cGVjdGVkVHlwZScpKSB7XG4gICAgICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGNoZWNrZXJSZXN1bHQuZGF0YS5leHBlY3RlZFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlc01lc3NhZ2UgPSAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPiAwKSA/ICcsIGV4cGVjdGVkIG9uZSBvZiB0eXBlIFsnICsgZXhwZWN0ZWRUeXBlcy5qb2luKCcsICcpICsgJ10nOiAnJztcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AnICsgZXhwZWN0ZWRUeXBlc01lc3NhZ2UgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIHR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHByb3BGdWxsTmFtZSArICcuJyArIGtleSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZSArICdgLidcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCBnZXRQcmVjaXNlVHlwZShjaGVja2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb20gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoaGFzKHNoYXBlVHlwZXMsIGtleSkgJiYgdHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gaW52YWxpZFZhbGlkYXRvckVycm9yKGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIGtleSwgZ2V0UHJlY2lzZVR5cGUoY2hlY2tlcikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGZhbHN5IHZhbHVlIGNhbid0IGJlIGEgU3ltYm9sXG4gICAgaWYgKCFwcm9wVmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShSZWFjdElzLmlzRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTMuMVxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlOyAvLyBUT0RPOiBXZSBkb24ndCB1c2UgQXN5bmNNb2RlIG9yIENvbmN1cnJlbnRNb2RlIGFueW1vcmUuIFRoZXkgd2VyZSB0ZW1wb3Jhcnlcbi8vICh1bnN0YWJsZSkgQVBJcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkLiBDYW4gd2UgcmVtb3ZlIHRoZSBzeW1ib2xzP1xuXG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29uY3VycmVudF9tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJykgOiAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpIDogMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmJsb2NrJykgOiAweGVhZDk7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJykgOiAweGVhZDU7XG52YXIgUkVBQ1RfUkVTUE9OREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5yZXNwb25kZXInKSA6IDB4ZWFkNjtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKSA6IDB4ZWFkNztcblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUkVTUE9OREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfU0NPUEVfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFKTtcbn1cblxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59IC8vIEFzeW5jTW9kZSBpcyBkZXByZWNhdGVkIGFsb25nIHdpdGggaXNBc3luY01vZGVcblxudmFyIEFzeW5jTW9kZSA9IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbnZhciBDb25jdXJyZW50TW9kZSA9IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xudmFyIENvbnRleHRDb25zdW1lciA9IFJFQUNUX0NPTlRFWFRfVFlQRTtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSBSRUFDVF9QUk9WSURFUl9UWVBFO1xudmFyIEVsZW1lbnQgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG52YXIgRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xudmFyIExhenkgPSBSRUFDVF9MQVpZX1RZUEU7XG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcbnZhciBQb3J0YWwgPSBSRUFDVF9QT1JUQUxfVFlQRTtcbnZhciBQcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG52YXIgU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG52YXIgU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7IC8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuXG5mdW5jdGlvbiBpc0FzeW5jTW9kZShvYmplY3QpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUpIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gdHJ1ZTsgLy8gVXNpbmcgY29uc29sZVsnd2FybiddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcblxuICAgICAgY29uc29sZVsnd2FybiddKCdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNMYXp5KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5mdW5jdGlvbiBpc1BvcnRhbChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUHJvZmlsZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xufVxuXG5leHBvcnRzLkFzeW5jTW9kZSA9IEFzeW5jTW9kZTtcbmV4cG9ydHMuQ29uY3VycmVudE1vZGUgPSBDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuQ29udGV4dENvbnN1bWVyID0gQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5Gb3J3YXJkUmVmID0gRm9yd2FyZFJlZjtcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbmV4cG9ydHMuTGF6eSA9IExhenk7XG5leHBvcnRzLk1lbW8gPSBNZW1vO1xuZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XG5leHBvcnRzLlByb2ZpbGVyID0gUHJvZmlsZXI7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBTdHJpY3RNb2RlO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFN1c3BlbnNlO1xuZXhwb3J0cy5pc0FzeW5jTW9kZSA9IGlzQXN5bmNNb2RlO1xuZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlID0gaXNDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuaXNDb250ZXh0Q29uc3VtZXIgPSBpc0NvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXIgPSBpc0NvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0ZvcndhcmRSZWYgPSBpc0ZvcndhcmRSZWY7XG5leHBvcnRzLmlzRnJhZ21lbnQgPSBpc0ZyYWdtZW50O1xuZXhwb3J0cy5pc0xhenkgPSBpc0xhenk7XG5leHBvcnRzLmlzTWVtbyA9IGlzTWVtbztcbmV4cG9ydHMuaXNQb3J0YWwgPSBpc1BvcnRhbDtcbmV4cG9ydHMuaXNQcm9maWxlciA9IGlzUHJvZmlsZXI7XG5leHBvcnRzLmlzU3RyaWN0TW9kZSA9IGlzU3RyaWN0TW9kZTtcbmV4cG9ydHMuaXNTdXNwZW5zZSA9IGlzU3VzcGVuc2U7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZTtcbmV4cG9ydHMudHlwZU9mID0gdHlwZU9mO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufSIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQge2NyZWF0ZVRoZW1lfSBmcm9tIFwiQG11aS9tYXRlcmlhbFwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IGRhcmtUaGVtZSA9IGNyZWF0ZVRoZW1lKHtcclxuICAgIHBhbGV0dGU6IHtcclxuICAgICAgICBtb2RlOiBcImRhcmtcIlxyXG4gICAgfSxcclxuICAgIGNvbXBvbmVudHM6IHtcclxuICAgICAgICBNdWlDc3NCYXNlbGluZToge1xyXG4gICAgICAgICAgICBzdHlsZU92ZXJyaWRlczoge1xyXG4gICAgICAgICAgICAgICAgYm9keToge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhckNvbG9yOiBcIiNmZmZmZmYgIzk1OTU5NVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiJjo6LXdlYmtpdC1zY3JvbGxiYXIsICYgKjo6LXdlYmtpdC1zY3JvbGxiYXJcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogXCI1cHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBcIiY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iLCAmICo6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiA4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmZmZmZlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5IZWlnaHQ6IDI0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgXCImOjotd2Via2l0LXNjcm9sbGJhci10aHVtYjpmb2N1cywgJiAqOjotd2Via2l0LXNjcm9sbGJhci10aHVtYjpmb2N1c1wiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjNmI2YjZiXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBcIiY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iOmFjdGl2ZSwgJiAqOjotd2Via2l0LXNjcm9sbGJhci10aHVtYjphY3RpdmVcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzZiNmI2YlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgXCImOjotd2Via2l0LXNjcm9sbGJhci10aHVtYjpob3ZlciwgJiAqOjotd2Via2l0LXNjcm9sbGJhci10aHVtYjpob3ZlclwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjNmI2YjZiXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBcIiY6Oi13ZWJraXQtc2Nyb2xsYmFyLWNvcm5lciwgJiAqOjotd2Via2l0LXNjcm9sbGJhci1jb3JuZXJcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzk1OTU5NVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICB9LFxyXG59KSJdLCJuYW1lcyI6WyJjcmVhdGVUaGVtZSIsImRhcmtUaGVtZSIsInBhbGV0dGUiLCJtb2RlIiwiY29tcG9uZW50cyIsIk11aUNzc0Jhc2VsaW5lIiwic3R5bGVPdmVycmlkZXMiLCJib2R5Iiwic2Nyb2xsYmFyQ29sb3IiLCJ3aWR0aCIsImJhY2tncm91bmRDb2xvciIsImJvcmRlclJhZGl1cyIsIm1pbkhlaWdodCIsImJvcmRlciJdLCJzb3VyY2VSb290IjoiIn0=